Dans ce chapitre nous présentons un langage impératif permettant de modéliser C.
Nous donnons sa syntaxe ainsi qu'une sémantique opérationelle.

Ce langage servira de support aux systèmes de types décrits dans les
chapitres~\ref{cha:typbase}, \ref{cha:qualuser} et \ref{cha:qualsz}.

La traduction depuis C sera explicitée dans le chapitre~\ref{cha:implem}.

\section{Syntaxe}

\begin{figure}
\input{fig/syntax.tex}
\caption{Syntaxe d'un langage impératif - instructions}
\label{fig:syntx}
\end{figure}

\begin{figure}
\input{fig/syntax-data.tex}
\caption{Syntaxe - expressions}
\label{fig:syntx-data}
\end{figure}

\todo{Ajouter l'arithmétique des pointeurs + types}

Les figures~\ref{fig:syntx} et \ref{fig:syntx-data} définissent un langage
impératif. On suppose qu'on peut compiler un programme écrit en C vers ce
langage.

Un programme est un triplet $P = (\vec{f}, \vec{v}, b)$\footnote{Dans tout ce
chapitre on utilise la notation des vecteur pour les collections ordonnées :
$\vec{f} = (f_1, f_2, …, f_n)$, $\vec{v} = (v_1, v_2, …, v_p)$ (leur
cardinalités ne sont pas forcément égales).} constitué d'un ensemble de
fonctions, d'un ensemble de variables et d'un bloc d'instructions. Ce bloc sera
exécuté au lancement du programme ; il peut par exemple contenir le code
d'initialisation des variables globales et l'appel à la fonction principale.

\todo{expliquer pourquoi un while expr ne suffit pas}

Les différences principales avec C sont les suivantes :

\begin{itemize}
\item
  le flot de contrôle est simplifié : les seules constructions sont
  l'alternative, la boucle infinie et le saut en avant.
\item
  les expressions sont sans effets de bords. En particulier, leur
  évaluation peut être faite sans modifier l'environnement.
\item
  les opérateurs pour entiers et les flottants sont différenciées.
\end{itemize}

\section{Sémantique}

Dans cette section, nous définissons une sémantique pour ce langage impératif ;
elle pourra servir à l'implantation d'un interpréteur et à raisonner de manière
formelle sur les programmes. Mathématiquement, cela consiste en la définition
d'une relation de transition $\rightarrow$ entre états de l'interpréteur.

Cette relation est définie inductivement sur la syntaxe du programme. Plutôt que
de présenter l'induction explicitement, elle est représentée par des jugements
logiques et des règles d'inférences, de la forme :

\[
\irule{Nom}{P_1 \\ … \\ P_n}{C}
\]

Les $P_i$ sont les prémisses, et $C$ la conclusion. Cette règle s'interprète de
la manière suivante : si les $P_i$ sont prouvées, alors $C$ est prouvée.

Certaines règles n'ont pas de prémisse, ce sont des axiomes :

\[
\irule{Ax}{ }{A}
\]

Compte-tenu de la structure des règles, la preuve d'un jugement pourra donc être
vue sous la forme d'un arbre :

\[
  \irule{r1}{
    \irule{r2}
          {
            \irule{r3}
              { }
              {A_1}
              \\
            \irule{r4}
              { }
              {A_2}
          }
          {B_1}
    \\
    \irule{r5}
      {
        \irule{r6}
          { }
          {A_3}
        }{B_2}
      }{C}
\]

La relation de transition est faite entre états de l'interpréteur, , constitués
d'une part d'une continuation (section~\ref{sec:cont}, et d'autre part d'un
l'état $σ$ de la mémoire (section~\ref{sec:sigma}). Cette présentation est
proche de la sémantique de CMinor décrite dans\cite{cminorSL}

\begin{definition}[Relation de transition]
  La sémantique consiste en une relation de transition entre les états de
  l'interpréteur. Celle-ci est faite sous un environnement $Γ$ qui associe des
  adresses aux variables du programme.

  On note un tel pas $Γ ⊢ (k, σ) → (k', σ')$.
\end{definition}

\section{Continuations}
\label{sec:cont}

Pour représenter le flot de contrôle dans la sémantique, plusieurs choix sont
possibles. L'un est d'établir un graphe de flot de contrôle explicite et de
raisonner en termes de points de contrôle. Celui que nous retenons consiste à
voir l'exécution du programme en terme de continuations. Une continuation
capture ``ce qu'il reste à faire'' pour terminer l'exécution d'un programme.

Dans le cas le plus simple, il n'y a rien à faire (si le bloc d'initialisation
est vide par exemple ; ce sera aussi le cas de base de la plupart des autres
continuations). Cette continuation sera notée \kPass.

Il est aussi possible d'avoir à exécuter une instruction avant de passer à une
autre continuation. Cette séquence sera notée \kSeq{i}{k} (ou en notation
infixe, $i \cdot k$, avec la convention $i_1 \cdot i_2 \cdot k = i_1 \cdot (i_2
\cdot k) $).

Le flot de contrôle intraprocédural est uniquement réduit au saut en avant : on
peut nommer un bloc, et sauter à la sortie de celui-ci. Il faut donc pouvoir
capturer la continuation qui correspond à la sortie de ce bloc. Ce sera noté
$\kBlock{lbl}{k}$. Le saut en lui-même est une simple instruction, notée
$\npkGoto{lbl}$.

Enfin, le flot de contrôle interprocédural est similaire : l'appel d'une
fonction $f$ avec les arguments $\vec{v}$ et recevant l'adresse de retour dans
$a$ est noté $\kCall{f}{\vec{v}}{a}{k}$ ; et le retour d'une fonction est
\kRet{v}.

\gramlr{Continuations}{
\begin{align*}
k  \gramisa & \kPass                   & \textrm{Terminaison}
\\ \gramor  & \kSeq{i}{k}              & \textrm{Séquence}
\\ \gramor  & \kBlock{lbl}{k}          & \textrm{Sortie de bloc nommé}
\\ \gramor  & \kCall{f}{\vec{v}}{a}{k} & \textrm{Appel de fonction}
\\ \gramor  & \kRet{v}                 & \textrm{Retour de fonction}
\end{align*}
}

Parmi celles-ci, il y a deux cas de base (de terminaison) : \kPass et
$\kRet{\cdot}$. Le premier servira à terminer le bloc d'initialisation et le
second les corps de fonction.

\section{État mémoire}
\label{sec:sigma}

L'interpréteur défini ici manipule des valeurs :

\gramlr{Valeurs}{
\begin{align*}
v  \gramisa  & n           & \textrm{Entier}
\\ \gramor   & f           & \textrm{Flottant}
\\ \gramor   & \cNil       & \textrm{Pointeur nul}
\\ \gramor   & \&a         & \textrm{Pointeur sur l'adresse $a$}
\\ \gramor   & \&f         & \textrm{Pointeur sur la fonction $f$}
\\ \gramor   & \top        & \textrm{Valeur non initialisée}
\end{align*}
}

On note l'ensemble des valeurs \textsc{Val}.

\begin{definition}[État mémoire]
L'interpréteur possède une mémoire, indexée par un ensemble d'adresses noté
\textsc{Addr}. Un état mémoire $σ$ est une fonction partielle de \textsc{Addr}
vers \textsc{Val}.
\end{definition}

\todo{Il faut une opération genre fromBytes}

\begin{definition}[Fonction de transition]
La sémantique concrète que nous définissons ici est constituée de jugements
logiques. Le jugement principal est une relation de transition $\rightarrow$
entre états de l'interpréteur : il sera donc noté $Γ ⊢ (l, σ) \rightarrow (l', σ')$.
\end{definition}

\section{Interprétation}

\begin{definition}[État initial]

  Pour un programme $P = (\vec{f},\vec{v},b)$, on définit sa continuation
  initiale comme étant celle qui exécute son bloc d'initialisation : $k_0 (P) =
  \kSeq{b}{\kPass}$.

  L'environnement initial $Γ_0(P)$ associe à chaque globale à une certaine
  adresse.

  Enfin, l'état mémoire initial laisse toutes les variables globales non
  initialisées :

  \[ σ_0(P) = \{ v_i ↦ \top \} \]

\end{definition}

\begin{definition}[Exécution d'un programme]

  L'exécution d'un programme $P$ résulte en un état mémoire final $σ_f$ si :

  \[ Γ_0(P) ⊢ (k_0(P), σ_0(P)) → (\kPass, σ_f) \]

\end{definition}

Dans la suite, on définit la relation de transition. Selon la forme de la
continuation, deux grandes familles sont à distinguer : les instructions
classiques et celles qui manipulent le flot de contrôle.


\section{Sémantique des left-values}

La mémoire est organisée en adresses, mais pourtant dans le programme cette
notion n'est pas directement visible. Les accès sont réalisés à travers des
"left values". Dans le langage C, elles correspondent aux constructions qui
peuvent se retrouver à gauche du signe "=" dans une affectation.

\begin{definition}[Correspondance left-values / adresses]
  Sous un environnement $Γ$ et un état mémoire $σ$, une left-value peut
  correspondre à une adresse $a$. Ceci sera noté $Γ, σ ⊢ lv ↝ a$.
\end{definition}

\begin{mathpar}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  Γ, σ ⊢ v ↝ a
}
\and
\irule{Eval-Lv-Deref}{
  Γ, σ ⊢ e ⇒ \&a
}{
  Γ, σ ⊢ *e ↝ a
}
\and
\irule{Eval-Lv-Field}{
  Γ, σ ⊢ lv ↝ a
}{
  Γ, σ ⊢ lv.f ↝ a + f
}
\and
\irule{Eval-Lv-Array}{
  Γ, σ ⊢ lv ↝ a \\
  Γ, σ ⊢ e ⇒ n
}{
  Γ, σ ⊢ lv[e] ↝ a + n
}
\end{mathpar}

\section{Sémantique des expressions}

Les expressions sont les constructions syntaxiques de base du langage. Étant
donné un environnement et un état mémoire, on peut leur associer une valeur.

Par exemple, dans l'environnement qui à la variable $x$ associe l'adresse $a$ et
dans l'état mémoire qui à l'adresse $a$ associe la valeur $2$, l'expression $x +
3$ s'évalue en $5$.

\begin{definition}[Évaluation d'une expression]
  Sous un environnement $Γ$ et un état mémoire $σ$, une left-value peut
  produire une valeur $v$. Ceci sera noté $Γ, σ ⊢ e ⇒ v$.
\end{definition}

Dans le cas où l'expression est une constante, c'est directement le résultat.

\begin{mathpar}
\irule{Eval-Cst}{
}{
  Γ, σ ⊢ c ⇒ c
}
\end{mathpar}

Si l'expression est une left-value, on établit à quelle adresse elle correspond
et on récupère dans l'état mémoire à quelle valeur celle-ci correspond.

\begin{mathpar}
\irule{Eval-Lv}{
  Γ, σ ⊢ lv ↝ a \\
  (a, v) ∈ σ
}{
  Γ, σ ⊢ lv ⇒ v
}
\end{mathpar}

En ce qui concerne les opérations (unaires ou binaires), on commence par évaluer
les opérandes. Le résultat est l'opération "concrète" sur les valeurs, notée
$\widehat{\textrm{op}}$. Par exemple, pour la construction syntaxique $+$, on
utilise l'addition sur les valeurs $\widehat{+}$ (c'est-à-dire l'addition
usuelle).

\begin{mathpar}
\irule{Eval-Unop}{
  Γ, σ ⊢ e ⇒ v
}{
  Γ, σ ⊢ \textrm{op}~e ⇒ \widehat{\textrm{op}}~v
}
\and
\irule{Eval-Binop}{
  Γ, σ ⊢ e_1 ⇒ v_1 \\
  Γ, σ ⊢ e_2 ⇒ v_2
}{
  Γ, σ ⊢ e_1~\textrm{op}~e_2 ⇒ v_1~\widehat{\textrm{op}}~v_2
}
\end{mathpar}

Enfin, les adresses sont aussi des valeurs. Le cas des pointeurs sur fonction
est direct puisque toutes les fonctions sont globales ; pour le cas des
pointeurs sur données on commence par déterminer l'adresse de l'objet pointé
depuis l'état mémoire.

\begin{mathpar}
\irule{Eval-AddrOfFun}{
}{
  Γ, σ ⊢ \&f ⇒ \&f
}
\and
\irule{Eval-AddrOf}{
  Γ, σ ⊢ lv ↝ a
}{
  Γ, σ ⊢ \&lv ⇒ \&a
}
\end{mathpar}

\section{Sémantique des instructions}

Si $i$ est une séquence, on la décompose. De même, les blocs vides peuvent être
sautés :

\begin{mathpar}
  \irule{Instr-Seq}
    { }
    {Γ ⊢ ((i_1 ; i_2) \cdot k, σ) → (i_1 \cdot (i_2 \cdot k), σ)}
  \and
  \irule{Instr-Skip}
    { }
    {Γ ⊢ (ε \cdot k, σ) → (k, σ)}
\end{mathpar}

Si $i$ est une affectation, on évalue l'expression et on modifie l'état $σ$ en
conséquence.

\begin{mathpar}
  \irule{Instr-Assign}{
    Γ, σ ⊢ lv ↝ a \\
    Γ, σ ⊢ e ⇒ v
  }{
    Γ ⊢ (lv \leftarrow e \cdot k, σ) \rightarrow (k, σ [ a ↦ v ])
  }
\end{mathpar}

Déclarer une variable, c'est rendre accessible dans un bloc une variable non
initialisée, qui n'est plus accessible par la suite : Si on suppose qu'on peut
traverser le bloc interne $b$ sous un $σ$ enrichi d'une nouvelle variable $x$,
on peut donc traverser l'instruction \npkDecl{x}{b}.

\begin{mathpar}
  \irule{Instr-Decl}
    {
      Γ' = ? \\
      Γ' ⊢ (b . \kPass)
    }
    {
      Γ ⊢ (\npkDecl{x}{b} \cdot k, σ) → (k, σ')
    }
\end{mathpar}

\todo{Il faut un kdecl}

\section{Flot de contrôle intraprocédural}

Réaliser une boucle infinie revient à d'abord exécuter le bloc puis à exécuter à
nouveau la boucle :

\begin{mathpar}
\irule{Instr-While}
{ }
{ Γ ⊢ (\npkWhile{b} \cdot k, σ) → (b . \npkWhile{b} \cdot k, σ) }
\end{mathpar}

La capture d'une sortie de bloc nommé consiste à remplacer la continuation en
cours par une continuation $\kBlock{\cdot}{\cdot}$.

\begin{mathpar}
\irule{Instr-DoWith}
{ }
{ Γ ⊢ ((\npkDoWith{b}{lbl}) \cdot k, σ) → ( b \cdot \kBlock{lbl}{k}) }
\end{mathpar}

Pour le saut, deux cas sont à considérer. Dans le premier cas, on sort du bloc
le plus interne ; dans l'autre, on sort d'un bloc qui n'est pas final.

\begin{mathpar}
\irule{Instr-Goto-Int}
{ }
{ Γ ⊢ ( \npkGoto{lbl} \cdot … \cdot \kBlock{lbl}{k}, σ) → (k, σ) }
\and
\irule{Instr-Goto-Ext}
{ lbl ≠ lbl' }
{ Γ ⊢ ( \npkGoto{lbl} \cdot … \cdot \kBlock{lbl'}{k}, σ) → (\npkGoto{lbl} \cdot k, σ) }
\end{mathpar}

Pour la conditionnelle, on évalue la condition. Si elle s'évalue en un entier
non nul, la suite est le bloc "vrai", sinon c'est le bloc "faux".

\begin{mathpar}
\irule{Instr-If-True}
  { Γ, σ ⊢ e ⇒ n \\
    n ≠ 0
  }
  {
    Γ ⊢ (\npkIf{e}{i_t}{i_f} \cdot k, σ) → (i_t \cdot k, σ)
  }
\and
\irule{Instr-If-False}
  { Γ, σ ⊢ e ⇒ 0
  }
  {
    Γ ⊢ (\npkIf{e}{i_t}{i_f} \cdot k, σ) → (i_f \cdot k, σ)
  }
\end{mathpar}

\section{Appel de fonctions}

Pour $f = (\vec{v}, b)$, on note $k_0(f) = b \cdot \kPass$ et $\vec{params}(f) =
\vec{v}$.

Pour une instruction \npkReturn{e}, on évalue l'expression en une valeur $v$ et
on remplace la continuation courante par $\kRet{v}$.

\begin{mathpar}
  \irule{Instr-Return}
    { Γ, σ ⊢ e ⇒ v }
    { Γ ⊢ (\npkReturn{e} \cdot k, σ) → (\kRet{v}, σ)
    }
\end{mathpar}

L'appel de fonction se fait en deux étapes : tout d'abord, quand on rencontre un
appel de fonction, on évalue les arguments et la left-value de retour et on
construit une continuation $\kCall{f}{\vec{v}}{a}{k}$, qui remplace la continuation
courante.

\begin{mathpar}
  \irule{Instr-Fcall}
    { Γ, σ ⊢ lv ↝ a
   \\ Γ, σ ⊢ \vec{e} ⇒ \vec{v}
    }
    { Γ ⊢ (lv ← f(\vec{e}) \cdot k, σ) → (\kCall{f}{\vec{v}}{a}{k}, σ) }
\end{mathpar}

Pour évaluer celle-ci, on évalue le corps de la fonction dans un environnement
enrichi des paramètres de la fonction, jusqu'à ce que sa continuation soit
$\kRet{\cdot}$.

\begin{mathpar}
  \irule{Instr-Kcall}
    { Γ' = ? \\
      σ' = σ + \{ \vec{params}(f) := \vec{v} \} \\
      Γ' ⊢ (k_{0}(f), σ') → (\kRet{v_r}, σ'')
    }
    { Γ ⊢ (\kCall{f}{\vec{v}}{a}{k}, σ) → (k, σ'' [ a := v_r ]) }
\end{mathpar}

\section{Programmes bien formés}

La syntaxe décrite ci-dessus ne permet pas de donner du sens à tous les
programmes : par exemple les programmes suivants ne peut pas être évalué.

\newsavebox{\progmfa}

\begin{figure}
    \centering

\begin{SubFloat}{Saut vers une étiquette inexistante}
\begin{minipage}[b]{0.4\linewidth}
\begin{Verbatim}
{
  Goto l1
}
\end{Verbatim}
\end{minipage}
\end{SubFloat}
\begin{SubFloat}{Saut vers une étiquette non visible}
\begin{minipage}[b]{0.4\linewidth}
\begin{Verbatim}
{
  Do {
    Goto l2
  } With l1:
  Do {
  } With l2:
}
\end{Verbatim}
\end{minipage}
\end{SubFloat}

\vspace{1cm}

\begin{SubFloat}{Saut interprocédural}
\begin{minipage}[b]{0.4\linewidth}
\begin{Verbatim}
f(x) {
  Goto l1
}

{
  Do {
    f(1)
  } With l1:
}
\end{Verbatim}
\end{minipage}
\end{SubFloat}
\begin{SubFloat}{Retour dans bloc d'initialisation}
\begin{minipage}[b]{0.4\linewidth}
\begin{Verbatim}
{
  Return 0
}
\end{Verbatim}
\end{minipage}
\end{SubFloat}

  \caption{Programmes mal formés}
  \label{fig:progmf}
\end{figure}



Dans le premier cas la continuation est $\npkGoto{l1} \cdot \kPass$, et aucune
règle d'évaluation ne permet de la réduire : les seules possibilités pour une
continuation de la forme $\npkGoto{l} \cdot k$ sont lorsque $k = … \cdot … \cdot
\kBlock{l'}{k'}$. Syntaxiquement, c'est un problème de visibilité : au niveau
d'un $\npkGoto{l}$, l'étiquette $l$ doit être visible.

\def\WF#1{\textsc{wf}(#1)}
\def\NORET#1{\textsc{NoRet}(#1)}

\begin{mathpar}
\irule{WF-Prog}
  { \WF{\vec{f}} \\
    \NORET{b}
  }
  {\WF{(\vec{f}, \vec{v}, b)}}
\and \irule{WF-Func}{ ∅ ‣ body(f) }{ \WF{f} }
\and \irule{WF-Set}{ }{ L ‣ lv \leftarrow e}
\and \irule{WF-Fcall}{ }{ L ‣ lv \leftarrow funexp (args)}
\and \irule{WF-Return}{ }{ L ‣ \npkReturn{e}}
\and \irule{WF-While}{L ‣ b}{L ‣ \npkWhile{b}}
\and \irule{WF-Decl}{L ‣ b}{L ‣ \npkDecl{nom}{b}}
\and \irule{WF-If}{L ‣ b_1 \\ L ‣ b_2}{L ‣ \npkIf{e}{b_1}{b_2}}
\and \irule{WF-DoWith}{L,lbl ‣ b}{L ‣ \npkDoWith{b}{lbl}}
\and \irule{WF-Goto}{lbl ∈ L}{L ‣ \npkGoto{lbl}}

\and \irule{NR-Set}{\NORET{b}}{ \NORET{lv \leftarrow e;b}}
\and \irule{NR-Fcall}{\NORET{b}}{lv \leftarrow funexp (args);b}
\and \irule{NR-While}{\NORET{b_1} \\ \NORET{b_2}}{\npkWhile{b_1};b_2}
\and \irule{NR-Decl}{ \NORET{b_1} \\ \NORET{b_2}}{\npkDecl{nom}{b_1};b_2}
\and \irule{NR-If}{ \NORET{b_1} \\ \NORET{b_2} \\ \NORET{b_3}}{\npkIf{e}{b_1}{b_2};b_3}
\and \irule{NR-DoWith}{ \NORET{b_1} \\ \NORET{b_2}}{\npkDoWith{b_1}{lbl};b_2}
\and \irule{NR-Goto}{ \NORET{b} }{\npkGoto{lbl};b}
\end{mathpar}

\begin{center}\rule{3in}{0.4pt}\end{center}

Il y a deux règles à respecter :

\begin{itemize}
\item
  les étiquettes des instructions $\npkGoto{\cdot}$ sont visibles
\item
  le bloc d'initialisation ne contient pas d'instruction
  $\npkReturn{\cdot}$
\end{itemize}
