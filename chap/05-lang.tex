Dans ce chapitre nous présentons un langage impératif permettant de modéliser C.
Nous donnons sa syntaxe ainsi qu'une sémantique opérationelle.

Ce langage servira de support aux systèmes de types décrits dans les
chapitres~\ref{cha:typbase}, \ref{cha:qualuser} et \ref{cha:qualsz}.

La traduction depuis C sera explicitée dans le chapitre~\ref{cha:implem}.

\section{Syntaxe}

\begin{figure}
\input{fig/syntax.tex}
\caption{Syntaxe d'un langage impératif}
\label{fig:syntx}
\end{figure}

\todo{Ajouter l'arithmétique des pointeurs + types}

La figure~\ref{fig:syntx} définit un langage impératif. On suppose qu'on peut
compiler un programme écrit en C vers ce langage.

Un programme est un triplet $P = (\vec{f}, \vec{v}, b)$\footnote{Dans tout ce
chapitre on utilise la notation des vecteur pour les collections ordonnées :
$\vec{f} = (f_1, f_2, …, f_n)$, $\vec{v} = (v_1, v_2, …, v_p)$ (leur
cardinalités ne sont pas forcément égales).} constitué d'un ensemble de
fonctions, d'un ensemble de variables et d'un bloc d'instructions. Ce bloc sera
exécuté au lancement du programme ; il peut par exemple contenir le code
d'initialisation des variables globales et l'appel à la fonction principale.

\todo{expliquer pourquoi un while expr ne suffit pas}

Les différences principales avec C sont les suivantes :

\begin{itemize}
\item
  le flot de contrôle est simplifié : les seules constructions sont
  l'alternative, la boucle infinie et le saut en avant.
\item
  les expressions sont sans effets de bords. En particulier, leur
  évaluation peut être faite sans modifier l'environnement.
\item
  les opérateurs pour entiers et les flottants sont différenciées.
\end{itemize}

\section{Sémantique}

Dans cette section, nous définissons une sémantique pour ce langage impératif ;
elle pourra servir à l'implantation d'un interpréteur et à raisonner de manière
formelle sur les programmes. Mathématiquement, cela consiste en la définition
d'une relation de transition $\rightarrow$ entre états de l'interpréteur.

Cette relation est définie inductivement sur la syntaxe du programme. Plutôt que
de présenter l'induction explicitement, elle est représentée par des jugements
logiques et des règles d'inférences, de la forme :

\[
\irule{Nom}{P_1 \\ … \\ P_n}{C}
\]

Les $P_i$ sont les prémisses, et $C$ la conclusion. Cette règle s'interprète de
la manière suivante : si les $P_i$ sont prouvées, alors $C$ est prouvée.

Certaines règles n'ont pas de prémisse, ce sont des axiomes :

\[
\irule{Ax}{ }{A}
\]

Compte-tenu de la structure des règles, la preuve d'un jugement pourra donc être
vue sous la forme d'un arbre :

\[
  \irule{r1}{
    \irule{r2}
          {
            \irule{r3}
              { }
              {A_1}
              \\
            \irule{r4}
              { }
              {A_2}
          }
          {B_1}
    \\
    \irule{r5}
      {
        \irule{r6}
          { }
          {A_3}
        }{B_2}
      }{C}
\]

La relation de transition est faite entre états de l'interpréteur, , constitués
d'une part d'une continuation (section~\ref{sec:cont}, et d'autre part d'un
l'état $σ$ de la mémoire (section~\ref{sec:sigma}). Cette présentation est
proche de la sémantique de CMinor décrite dans\cite{cminorSL}

\begin{definition}[Relation de transition]
  La sémantique consiste en une relation de transition entre les états de
  l'interpréteur. Celle-ci est faite sous un environnement $Γ$ qui associe des
  adresses aux variables du programme.

  On note un tel pas $Γ ⊢ (k, σ) → (k', σ')$.
\end{definition}

\section{Continuations}
\label{sec:cont}

Pour représenter le flot de contrôle dans la sémantique, plusieurs choix sont
possibles. L'un est d'établir un graphe de flot de contrôle explicite et de
raisonner en termes de points de contrôle. Celui que nous retenons consiste à
voir l'exécution du programme en terme de continuations. Une continuation
capture ``ce qu'il reste à faire'' pour terminer l'exécution d'un programme.

Dans le cas le plus simple, il n'y a rien à faire (si le bloc d'initialisation
est vide par exemple ; ce sera aussi le cas de base de la plupart des autres
continuations). Cette continuation sera notée \kPass.

Il est aussi possible d'avoir à exécuter une instruction avant de passer à une
autre continuation. Cette séquence sera notée \kSeq{i}{k} (ou en notation
infixe, $i \cdot k$.

Le flot de contrôle intraprocédural est uniquement réduit au saut en avant : on
peut nommer un bloc, et sauter à la sortie de celui-ci. Le saut en lui-même est
donc une continuation, noté \kGoto{lbl}. Pour retrouver à quelle continuation
cette étiquette correspond, il faut un moyen de capturer une continuation en la
nommant, ce qui sera noté \kBlock{lbl}{k}.

Enfin, le flot de contrôle interprocédural est similaire : l'appel d'une
fonction $f$ avec les arguments $\vec{v}$ et recevant l'adresse de retour dans
$a$ est noté $\kCall{f}{\vec{v}}{a}$ ; et le retour d'une fonction est \kRet{v}.

\gramlr{Continuations}{
\begin{align*}
k  \gramisa & \kPass                & \textrm{Terminaison}
\\ \gramor  & \kSeq{i}{k}           & \textrm{Séquence}
\\ \gramor  & \kBlock{lbl}{k}       & \textrm{Sortie de bloc nommé}
\\ \gramor  & \kGoto{lbl}           & \textrm{Saut}
\\ \gramor  & \kCall{f}{\vec{v}}{a} & \textrm{Appel de fonction}
\\ \gramor  & \kRet{v}              & \textrm{Retour de fonction}
\end{align*}
}

\section{État mémoire}
\label{sec:sigma}

L'interpréteur défini ici manipule des valeurs :

\gramlr{Valeurs}{
\begin{align*}
v  \gramisa  & n           & \textrm{Entier}
\\ \gramor   & f           & \textrm{Flottant}
\\ \gramor   & \cNil       & \textrm{Pointeur nul}
\\ \gramor   & \&a         & \textrm{Pointeur sur l'adresse $a$}
\\ \gramor   & \&f         & \textrm{Pointeur sur la fonction $f$}
\\ \gramor   & \top        & \textrm{Valeur non initialisée}
\end{align*}
}

On note l'ensemble des valeurs \textsc{Val}.

\begin{definition}[État mémoire]
L'interpréteur possède une mémoire, indexée par un ensemble d'adresses noté
\textsc{Addr}. Un état mémoire $σ$ est une fonction partielle de \textsc{Addr}
vers \textsc{Val}.
\end{definition}

\todo{Il faut une opération genre fromBytes}

\begin{definition}[Fonction de transition]
La sémantique concrète que nous définissons ici est constituée de jugements
logiques. Le jugement principal est une relation de transition $\rightarrow$
entre états de l'interpréteur : il sera donc noté $Γ ⊢ (l, σ) \rightarrow (l', σ')$.
\end{definition}

\section{Sémantique des left-values}

La mémoire est organisée en adresses, mais pourtant dans le programme cette
notion n'est pas directement visible. Les accès sont réalisés à travers des
"left values". Dans le langage C, elles correspondent aux constructions qui
peuvent se retrouver à gauche du signe "=" dans une affectation.

\begin{definition}[Correspondance left-values / adresses]
  Sous un environnement $Γ$ et un état mémoire $σ$, une left-value peut
  correspondre à une adresse $a$. Ceci sera noté $Γ, σ ⊢ lv ↝ a$.
\end{definition}

\begin{mathpar}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  Γ, σ ⊢ v ↝ a
}
\and
\irule{Eval-Lv-Deref}{
  Γ, σ ⊢ e ⇒ \&a
}{
  Γ, σ ⊢ *e ↝ a
}
\and
\irule{Eval-Lv-Field}{
  Γ, σ ⊢ lv ↝ a
}{
  Γ, σ ⊢ lv.f ↝ a + f
}
\and
\irule{Eval-Lv-Array}{
  Γ, σ ⊢ lv ↝ a \\
  Γ, σ ⊢ e ⇒ n
}{
  Γ, σ ⊢ lv[e] ↝ a + n
}
\end{mathpar}

\section{Sémantique des expressions}

Les expressions sont les constructions syntaxiques de base du langage. Étant
donné un environnement et un état mémoire, on peut leur associer une valeur.

Par exemple, dans l'environnement qui à la variable $x$ associe l'adresse $a$ et
dans l'état mémoire qui à l'adresse $a$ associe la valeur $2$, l'expression $x +
3$ s'évalue en $5$.

\begin{definition}[Évaluation d'une expression]
  Sous un environnement $Γ$ et un état mémoire $σ$, une left-value peut
  produire une valeur $v$. Ceci sera noté $Γ, σ ⊢ e ⇒ v$.
\end{definition}

Dans le cas où l'expression est une constante, c'est directement le résultat.

\begin{mathpar}
\irule{Eval-Cst}{
}{
  Γ, σ ⊢ c ⇒ c
}
\end{mathpar}

Si l'expression est une left-value, on établit à quelle adresse elle correspond
et on récupère dans l'état mémoire à quelle valeur celle-ci correspond.

\begin{mathpar}
\irule{Eval-Lv}{
  Γ, σ ⊢ lv ↝ a \\
  (a, v) ∈ σ
}{
  Γ, σ ⊢ lv ⇒ v
}
\end{mathpar}

En ce qui concerne les opérations (unaires ou binaires), on commence par évaluer
les opérandes. Le résultat est l'opération "concrète" sur les valeurs, notée
$\widehat{\textrm{op}}$. Par exemple, pour la construction syntaxique $+$, on
utilise l'addition sur les valeurs $\widehat{+}$ (c'est-à-dire l'addition
usuelle).

\begin{mathpar}
\irule{Eval-Unop}{
  Γ, σ ⊢ e ⇒ v
}{
  Γ, σ ⊢ \textrm{op}~e ⇒ \widehat{\textrm{op}}~v
}
\and
\irule{Eval-Binop}{
  Γ, σ ⊢ e_1 ⇒ v_1 \\
  Γ, σ ⊢ e_2 ⇒ v_2
}{
  Γ, σ ⊢ e_1~\textrm{op}~e_2 ⇒ v_1~\widehat{\textrm{op}}~v_2
}
\end{mathpar}

Enfin, les adresses sont aussi des valeurs. Le cas des pointeurs sur fonction
est direct puisque toutes les fonctions sont globales ; pour le cas des
pointeurs sur données on commence par déterminer l'adresse de l'objet pointé
depuis l'état mémoire.

\begin{mathpar}
\irule{Eval-AddrOfFun}{
}{
  Γ, σ ⊢ \&f ⇒ \&f
}
\and
\irule{Eval-AddrOf}{
  Γ, σ ⊢ lv ↝ a
}{
  Γ, σ ⊢ \&lv ⇒ \&a
}
\end{mathpar}

\section{État initial}

\begin{definition}[État initial]
  $P = (\vec{f},\vec{v},b)$

  $k_0 (P) = \kSeq{b}{\kPass}$

  $σ_0(P) = $ toutes les globales à $\top$ (le bloc d'init contient les init à 0)

  $Γ_0(P) = $ toutes les globales à une certaine adresse. ASLR etc.
\end{definition}

\begin{definition}[Exécution d'un programme]
  $Γ_0 ⊢ (k_0(P), σ_0(P) → (\kPass, σ_f)$
\end{definition}

Dans la suite, on définit la relation de transition. Selon la forme de la
continuation, deux grandes familles sont à distinguer : les instructions
classiques et celles qui manipulent le flot de contrôle.

\section{Sémantique des instructions}

Si $i$ est une séquence, on la décompose. De même, les blocs vides peuvent être
sautés :

\begin{mathpar}
  \irule{Instr-Seq}
    { }
    {Γ ⊢ ((i_1 ; i_2) \cdot k, σ) → (i_1 \cdot (i_2 \cdot k), σ)}
  \and
  \irule{Instr-Skip}
    { }
    {Γ ⊢ (ε \cdot k, σ) → (k, σ)}
\end{mathpar}

Si $i$ est une affectation, on évalue l'expression et on modifie l'état $σ$ en
conséquence.

\begin{mathpar}
  \irule{Instr-Assign}{
    Γ, σ ⊢ lv ↝ a \\
    Γ, σ ⊢ e ⇒ v
  }{
    Γ ⊢ (lv \leftarrow e \cdot k, σ) \rightarrow (k, σ [ a ↦ v ])
  }
\end{mathpar}

Déclarer une variable, c'est rendre accessible dans un bloc une variable non
initialisée, qui n'est plus accessible par la suite : Si on suppose qu'on peut
traverser le bloc interne $b$ sous un $σ$ enrichi d'une nouvelle variable $x$,
on peut donc traverser l'instruction \npkDecl{x}{b}.

\begin{mathpar}
  \irule{Instr-Decl}
    {
      Γ' = ? \\
      Γ' ⊢ (b . \kPass)
    }
    {
      Γ ⊢ (\npkDecl{x}{b} \cdot k, σ) → (k, σ')
    }
\end{mathpar}

\todo{Il faut un kdecl}

\section{Flot de contrôle intraprocédural}

Réaliser une boucle infinie revient à d'abord exécuter le bloc puis à exécuter à
nouveau la boucle :

\begin{mathpar}
\irule{Instr-While}
{ }
{ Γ ⊢ (\npkWhile{b} \cdot k, σ) → (b . \npkWhile{b} \cdot k, σ) }
\end{mathpar}

La capture d'une sortie de bloc nommé est directe :

\begin{mathpar}
\irule{Instr-DoWith}
{ }
{ Γ ⊢ (\npkDoWith{b}{lbl} \cdot k, σ) → ( b \cdot \kBlock{lbl}{k}) }
\end{mathpar}

Pouer le saut, deux cas sont à considérer. Dans le premier cas, on sort du bloc
le plus interne ; dans l'autre, on sort d'un bloc qui n'est pas final.

\begin{mathpar}
\irule{Instr-Goto-Int}
{ }
{ Γ ⊢ ( \kGoto{lbl} \cdot … \cdot \kBlock{lbl}{k}, σ) → (k, σ) }
\and
\irule{Instr-Goto-Ext}
{ lbl ≠ lbl' }
{ Γ ⊢ ( \kGoto{lbl} \cdot … \cdot \kBlock{lbl'}{k}, σ) → (\kGoto{lbl} \cdot k, σ) }
\end{mathpar}

Pour la conditionnelle, on évalue la condition. Si elle s'évalue en un entier
non nul, la suite est le bloc "vrai", sinon c'est le bloc "faux".

\begin{mathpar}
\irule{Instr-If-True}
  { Γ, σ ⊢ e ⇒ n \\
    n ≠ 0
  }
  {
    Γ ⊢ (\npkIf{e}{i_t}{i_f} \cdot k, σ) → (i_t \cdot k, σ)
  }
\and
\irule{Instr-If-False}
  { Γ, σ ⊢ e ⇒ 0
  }
  {
    Γ ⊢ (\npkIf{e}{i_t}{i_f} \cdot k, σ) → (i_f \cdot k, σ)
  }
\end{mathpar}

\section{Appel de fonctions}

\begin{mathpar}
  \irule{Instr-Fcall}
    { Γ, σ ⊢ lv ↝ a
   \\ Γ, σ ⊢ \vec{e} ⇒ \vec{v}
    }
    { Γ ⊢ (lv ← f(\vec{e}) \cdot k, σ) → (\kCall{f}{\vec{v}}{a} \cdot k, σ) }
  \and
  \irule{Instr-Kcall}
    { Γ' = ? \\
      Γ' ⊢ (k_{0}(f), σ) → (\kRet{v}, σ')
    }
    { Γ ⊢ (\kCall{f}{\vec{v}}{a} \cdot k, σ) → (k, σ' [ a := v_r ]) }
  \and
  \irule{Instr-Return}
    { Γ, σ ⊢ e ⇒ v }
    { Γ ⊢ (\npkReturn{e} \cdot k, σ) → (\kRet{v}, σ)
    }
\end{mathpar}
