L'idée derrière CQual se rapprochant de la nôtre, et cet outil ayant été
appliqué aux types de vulnérabilités qui nous intéressent~\cite{cquk-usenix04},
il est utile de détailler pourquoi notre approche est différente de ces travaux.

Tout d'abord, CQual modifie fondamentalement l'ensemble du système de types (via
le jugement de typage) et insère des qualificateurs à tous les niveaux de types.
Au contraire, nous ne modifions le système de types que là où cela est
nécessaire, c'est-à-dire sur les types pointeurs.

D'autre part, le système de types de CQual fait intervenir de manière
fondamentale une relation de sous-typage. Le problème de déréférencement des
pointeurs utilisateurs peut être traité dans ce cadre en posant $\qKernel
\preceq \qUser$ pour restreindre certaines opérations aux pointeurs $\qKernel$.

Notre approche, au contraire, n'utilise pas de sous-typage, mais consiste à
définir un type abstrait $\ptrU{t}$ partageant certaines propriétés avec
$\ptrK{t}$ (comme la taille et la représentation) mais incompatible avec
certaines opérations. C'est à rapprocher du système de masquage par interface
des langages ML, ou encore de la définition de types abstraits par le mot-clef
\texttt{newtype} en Haskell.





Dans le cas des pointeurs, même si le noyau Linux (et la plupart des systèmes
d'exploitation) ne comportent que deux espaces d'adressage, il est commun dans
les systèmes embarqués de manipuler des pointeurs provenant d'espaces mémoire
indépendants : par exemple, de la de la mémoire flash, de la RAM, ou une EEPROM
de configuration. Ces différentes mémoires possèdent des adresses, et un
pointeur est interprété comme faisant référence à une ou l'autre selon le code
dont il est tiré. Dans ces cas, la notion de sous-typage n'est pas adaptée.
