\epigraph{
On two occasions I have been asked, "Pray, Mr. Babbage, if you put into the
machine wrong figures, will the right answers come out?"… I am not able rightly
to apprehend the kind of confusion of ideas that could provoke such a question.
}
{--- \textup{Charles Babbage}, Passages from the Life of a Philosopher}

Dans ce chapitre nous présentons \langname, un langage impératif inspiré de C.
Sa syntaxe est tout d'abord décrite ; puis une sémantique opérationnelle est
explicitée.

Ce langage servira de support au systèmes de types décrit dans le
chapitre~\ref{cha:typbase} et enrichi dans le chapitre~\ref{cha:qualifs}.

La traduction depuis C sera explicitée dans le chapitre~\ref{cha:implem}.

\section{Notations}

\subsection*{Ensembles inductifs}

Dans ce chapitre (et les chapitres suivants), on définit de nombreux ensembles
inductifs. Plutôt que d'écrire la construction explicite par point fixe, on
emploie une notation en grammaire.

Étudions l'exemple des listes chaînées composées d'élements de $ℕ$.

Notons $L$ cet ensemble ; si $[]$ est la liste vide et $n::l$ la liste formée
d'une ``tête'' $n ∈ ℕ$ et d'une ``queue'' $l ∈ L$. Toute liste est donc d'une des
formes suivantes :

\begin{itemize}
\item $[]$
\item $n_1::[]$
\item $n_1::n_2::[]$
\item etc.
\end{itemize}

On peut donc $L$ de la manière inductive suivante :

\def\opfix{\textrm{fix}\xspace}

\begin{align*}
  \textsc{L} & = \opfix (L') \\
  L'(E) & = \{[]\} \cup \{ n::l / n ∈ ℕ, l ∈ E \} \\
\end{align*}

où

\begin{align*}
  \opfix (f) & = \bigcup_{n=0}^{\infty} f^{n}(∅) \\
  f^0(x) & = x \\
  ∀ n > 0, f^n(x) & = f^{n-1}(f (x)) \\
\end{align*}

(L'itération $n$ de l'union correspond aux listes comprenant au plus $n$
éléments)

Plutôt que d'écrire cette définition précise mais chargée, on écrira à la place
une définition en compréhension :

\begin{align*}
\gramdef{Listes}{l}
  {[]}{Liste vide}
  {n::l}{Construction de liste}
  {END}
\end{align*}

Chaque ensemble est identifié de manière unique par les noms de variables
métasyntaxiques : $n$ pour les entiers et $l$ pour les listes ici. Si plusieurs
métavariables du même ensemble doivent apparaître, elles sont indicées. Par
exemple, on peut définir des arbres binaires d'entiers de la manière suivante :

\begin{align*}
\gramdef{Arbres binaires}{a}
              { \textsc{F}              }{Feuille}
              { \textsc{N}(a_1, n, a_2) }{Nœud}
          {END}
\end{align*}

Cette notation a aussi l'avantage de s'étendre facilement aux définitions
mutuellement récursives.

\subsection*{Inférence}

La sémantique opérationnelle consiste en la définition d'une relation de
transition $\cdot\rightarrow\cdot$ entre états de l'interpréteur\footnote{Dans le
chapitre~\ref{cha:typbase}, la relation de typage $\cdot ⊢ \cdot : \cdot$ sera
définie par la même technique.}.

Cette relation est définie inductivement sur la syntaxe du programme. Plutôt que
de présenter l'induction explicitement, elle est représentée par des jugements
logiques et des règles d'inférences, de la forme :

\[
\irule{Nom}{P_1 \\ … \\ P_n}{C}
\]

Les $P_i$ sont les prémisses, et $C$ la conclusion. Cette règle s'interprète de
la manière suivante : si les $P_i$ sont prouvées, alors $C$ est prouvée.

Certaines règles n'ont pas de prémisse, ce sont des axiomes :

\[
\iaxiom{Ax}{A}
\]

Compte-tenu de la structure des règles, la preuve d'un jugement pourra donc être
vue sous la forme d'un arbre :

\[
  \irule{r1}{
    \irule{r2}
          {
            \iaxiom{r3}{A_1}
              \\
            \iaxiom{r4}{A_2}
          }
          {B_1}
    \\
    \irule{r5}
      {
        \iaxiom{r6} {A_3}
      }{B_2}
      }{C}
\]

\subsection*{Lentilles}

La notion d'accesseur utilisée ici est directement inspirée des \emph{lentilles}
utilisées en programmation fonctionnelle, décrite dans~\cite{PierceLenses}
et~\cite{LaarhovenLenses}.

\begin{definition}[Lentille]

Étant donnés deux ensembles $R$ et $A$, une \emph{lentille} $ℒ ∈ \setLens{R}{A}$
(ou \emph{accesseur}) est un moyen d'accéder en lecture ou en écriture à
sous-valeur de type $A$ au sein d'une valeur de type $R$ (pour \emph{record}).
Elle est consistuée des opérations suivantes :

\begin{itemize}
\item
  une fonction de lecture $\mathrm{get}_ℒ : R → A$
\item
  une fonction de mise à jour $\mathrm{put}_ℒ : (A × R) → R$
\end{itemize}

telles que pour tous $a∈A, a'∈A, r∈R$ :

\begin{align*}
\tag{GetPut}
\mathrm{put}_ℒ(\mathrm{get}_ℒ(r), r) = & r \\
\tag{PutGet}
\mathrm{get}_ℒ(\mathrm{put}_ℒ(a, r)) = & a \\
\tag{PutPut}
\mathrm{put}_ℒ(a', \mathrm{put}_ℒ(a, r)) = & \mathrm{put}_ℒ(a', r) \\
\end{align*}

On note $ℒ =
\mkLens{\mathrm{get}_{ℒ}}{\mathrm{put}_{ℒ}}$.

\textsc{GetPut} signifie que si on lit une valeur puis qu'on la réecrit, l'objet
n'est pas modifié ; \textsc{PutGet} décrit l'opération inverse : si on écrit
une valeur dans le champ, c'est la valeur qui sera lue ; enfin, \textsc{PutPut}
évoque le fait que chaque écriture est totale : quand deux écritures se suivent,
seule la seconde compte.

\end{definition}

Une illustration se trouve dans la figure~\ref{fig:lens-howto}.

\begin{figure}

  \begin{align*}
  \lensGet{ℒ}{\lensNodeBig{green!30}{blue!30}} = & \lensInner{blue!30} \\
  \lensPut{ℒ}{\lensInner{red!30}}{\lensNodeBig{green!30}{blue!30}} = & \lensNodeBig{green!30}{red!30} \\
  \end{align*}

\caption{Fonctionnement d'une lentille}
\label{fig:lens-howto}
\end{figure}

\begin{example}[Lentilles de tête et de queue de liste]

Soit $E$ un ensemble. On considère $L(E)$, l'ensemble des listes d'éléments de
$E$.

On définit les fonctions suivantes. Notons qu'elles ne sont pas définies sur la
liste vide $[]$, qui pourra être traité comme un cas d'erreur.

\begin{align*}
  \mathrm{get}_T     (t::q) = & t \\
  \mathrm{put}_T (t', t::q) = & t'::q \\
  \mathrm{get}_Q     (t::q) = & q \\
  \mathrm{put}_Q (q', t::q) = & t::q' \\
\end{align*}

Alors
$T = \mkLens{\mathrm{get}_T}{\mathrm{put}_T} ∈ \setLens{L(E)}{E}$
et
$Q = \mkLens{\mathrm{get}_Q}{\mathrm{put}_Q} ∈ \setLens{L(E)}{L(E)}$.

On a par exemple :

$\mathrm{get}_T (1::6::1::8::[]) = 1$

et :

$\mathrm{put}_Q (7, 3::6::1::5::[]) = 7::6::1::5::[]$.

\end{example}

\begin{definition}[Lentille indexée]

Les objets de certains ensembles $R$ sont composés de plusieurs sous-objets
accessibles à travers un indice $i ∈ I$. Une lentille indexée est une fonction
$Δ$ qui associe à un indice $i$ une lentille entre $R$ et un de ses champs
$A_i$:

\[
  ∀ i ∈ I, ∃ A_i, Δ(i) ∈ \setLens{R}{A_i}
\]

On note alors :

\begin{align*}
r [ i ]_Δ \eqdef & \mathrm{get}_{Δ(i)}(r) \\
r [ i ← a ]_Δ \eqdef & \mathrm{put}_{Δ(i)}(a, r) \\
\end{align*}

\end{definition}

Un exemple est illustré dans la figure~\ref{fig:lens-idx-ex}.

\begin{figure}

  \begin{align*}
    \lensGet{Δ(b)}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} = & \lensInnerStar{blue!30} \\
    \lensGet{Δ(c)}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} = & \lensInner{blue!30} \\
    \lensPut{Δ(b)}{\lensInnerStar{red!30}}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} = &
      \lensNodeBigIdx{green!30}{blue!30}{red!30}{blue!30}{blue!30} \\
    \lensPut{Δ(c)}{\lensInner{red!30}}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} = &
      \lensNodeBigIdx{green!30}{blue!30}{blue!30}{red!30}{blue!30} \\
  \end{align*}

\caption{Fonctionnement d'une lentille indexée}
\label{fig:lens-idx-ex}
\end{figure}

\begin{example}[Lentille "n\ieme élément d'un tuple"]

Soient $n ∈ ℕ$, et $n$ ensembles $E_1, …, E_n$.

Pour tout $i ∈ [1; n]$, on définit :

\begin{align*}
g_i((x_1, …, x_n)) = & x_i \\
p_i(y, (x_1, …, x_n)) = & (x_1, …, x_{i-1}, y, x_{i+1}, …, x_n)\\
\end{align*}

Définissons $T(i) = \mkLens{g_i}{p_i}$. Alors $T(i) ∈ \setLens{(E_1×…×E_n)}{E_i}$.

Donc $T$ est une lentille indexée, et on a par exemple :

\begin{align*}
(3,1,4,1,5) [2]_T = & \mathrm{get}_{T(2)} ((3, 1, 4, 1, 5)) \\
                  = & 1 \\
\\
(9,2,6,5,3) [3 ← 1]_T = & \mathrm{put}_{T(3)} (1, (9,2,6,5,3)) \\
                      = & (9,2,1,5,3)
\end{align*}
\end{example}

\begin{definition}[Composition de lentilles]
  \label{def:lens-comp}

  Soient $ℒ_1 ∈ \setLens{A}{B}$ et $ℒ_2 ∈ \setLens{B}{C}$.

  La composition de $ℒ_1$ et $ℒ_2$ est la lentille
  $ℒ ∈ \setLens{A}{C}$ définie de la manière suivante:

  \begin{align*}
    \mathrm{get}_{ℒ} (r) =&
        \mathrm{get}_{ℒ_2}
        (\mathrm{get}_{ℒ_1} r) \\
    \mathrm{put}_{ℒ} (a, r) =&
        \mathrm{put}_{ℒ_1} (\mathrm{put}_{ℒ_2}
        (a, \mathrm{get}_{ℒ_1} r), r) \\
  \end{align*}

  On notera alors $ℒ = ℒ_1 \ggg ℒ_2$.

\end{definition}

\begin{figure}

\centering

\shorthandoff{!}
\begin{tikzpicture}
[node distance=2cm
,bignode/.style={draw,shape=rectangle,minimum size=1cm,fill=green!30}
,smallnode/.style={draw,shape=circle,minimum size=8mm,fill=blue!30}
,trinode/.style={draw,shape=regular polygon,regular polygon sides=3}
]
\node[bignode] (A) {};
\node[right of=A,smallnode] (B) {};
\node[right of=B,trinode,fill=violet] (C) {};
\node[below of=B,smallnode] (D) {};
\node[below of=A,node distance=4cm,bignode] (E) {};

\draw[->] (A) to node[auto] {get} (B);
\draw[->] (B) to (D);
\draw[->] (A) to (E);
\draw (C) |- node[auto,near end,swap] {put} ($(B)!0.5!(D)$);
\draw (D) |- node[auto,near end,swap] {put} ($(A)!0.75!(E)$);

\node[smallnode] at (A) {};
\node[trinode,fill=orange] at (A) {};

\node[trinode,fill=orange] at (B) {};

\node[trinode,fill=violet] at (D) {};

\node[smallnode] at (E) {};
\node[trinode,fill=violet] at (E) {};

\end{tikzpicture}
\shorthandoff{!}

\caption{Composition de lentilles}
\label{fig:compo-lens}
\end{figure}

Cette définition est illustrée dans la figure~\ref{fig:compo-lens}. Une preuve
que la composition est une lentille est donnée en annexe~\ref{proof:compo-lens}.

\section{But et comparaison à C}

Le langage C~\cite{KandR} est un langage impératif, conçu pour être un
``assembleur portable''. Ses types de données et les opérations associées sont
donc naturellement très bas niveau.

Les types de données de C sont établis pour représenter les mots mémoire
manipulables par les processeurs : essentiellement des entiers et flottants de
plusieurs tailles. Les types composés correespondent à des zones de mémoire
contigües, homogènes (dans le cas des tableaux) ou hétérogènes (dans le cas des
structures).

Une des spécificités de C est qu'il expose au programmeur la notion de pointeur,
c'est à dire des variables qui représentent directement une adresse en mémoire.
Les pointeurs peuvent être typés (on garde une indication sur le type de l'objet
stocké à cette adresse) ou non typés.

Le système de types rudimentaire de C ne permet pas d'avoir beaucoup de
garanties sur la sûreté du programme. En effet, aucune vérification n'est
effectuée en dehors de celles faites par le programmeur.

Le but ici est d'établir un langage plus simple mais qui permettra de raisonner
sur une certaine classe de programmes C.

% TODO mettre ailleurs ?

\paragraph{Fonctions et procédures :} Un des problèmes classiques dans les
langages impératifs est de distinguer les fonctions (qui retournent une valeur)
et les procédures (qui n'en retournent pas). La solution choisie par C est de
marquer les procédures comme retournant un ``faux'' type \texttt{void}. Mais
c'est uniquement syntaxique : il n'est pas possible de manipuler cette valeur de
retour de type \texttt{void}.

L'autre possibilité, souvent prise dans les langages fonctionnels, est de ne pas
faire de distinction entre ces deux cas et d'interdire les procédures. Les
fonctions ne retournant pas de valeur ``intéressante'' renvoient alors une
valeur d'un type à un seul élément appelé \eUnit\footnote{Cette notation évoque
un $n$-uplet à 0 composante.}, et donc le type sera noté \tUnit.

En C, puisqu'il n'y a pas de valeurs de type \texttt{void}, la notation
\texttt{void *} a un sens particulier : elle désigne les pointeurs de type non
défini, qui sont compatibles avec n'importe quel autre type de pointeur (c'est
la seule forme --- rudimentaire --- de généricité qu'offre le langage). Ici, la
valeur \eUnit est une valeur comme les autres, et on peut constuire un pointeur
de type $\tUnit *$ qui n'aura pas de signification particulière : c'est
seulement un pointeur vers une valeur de type \tUnit.

\paragraph{Tableaux :} ce sont des valeurs composées qui contiennent un certain
nombre de valeurs d'un même type. Par exemple, 100 entiers. On accède à ces
valeurs par un indice entier, qui dans le cas général n'est pas connu à la
compilation. C'est une erreur ($\serr{array}$) d'accéder à un tableau en dehors de
ses bornes, c'est à dire en dehors de $[0;n-1]$ pour un tableau à $n$
éléments\footnote{Comme le fait remarquer Dijkstra, seule la numérotation à
partir de 0 a du sens\cite{EWD831}.}.
% TODO dans les valeurs les tableaux sont numérotés à partir de 1...

Les tableaux sont notés $[e_1; …; e_n]$, et le cas dégénéré ($n = 0$) est
interdit.

\paragraph{Structures :} comme les tableaux, ce sont des valeurs composées mais
hétérogènes. Les différents éléments (appelés \emph{champs}) sont désignés par
noms $l$ (pour \emph{label}) et de manière statique (il n'y a pas de mécanisme
pour faire référence à un nom dans le programme).

Les structures sont notées $\{ l_1 : e_1 ; … ; l_n : e_n \}$ et comme dans le
cas des tableaux, le cas dégénéré ($n = 0$) est interdit.

Dans le programme, le nom de champ $l$ est complété de la définition complète de
la structure $S$. Celle-ci n'est pas utilisée dans l'évaluation et sera donc
décrite au chapitre~\ref{cha:typbase}. Bien sûr, écrire la totalité de la
structure dans le code du programme serait fastidieux. Nous décrirons dans le
chapitre~\ref{cha:implem} comment obtenir automatiquement ces annotations depuis
un langage comme C qui utilise des noms de structures.

% TODO le faire

\section{Principes}

Nous voulons capturer l'essence de C. Les traits principaux sont les suivants :

\paragraph{Types de données :} très simples. Entiers machine, flottants,
pointeurs et types composés (structures et tableaux) composés de ceux-ci.

\paragraph{Variables :} elles sont mutables, et on peut passer des données par
valeur ou par pointeur.

\paragraph{Flôt de contrôle :} il repose sur les construction ``if'' et
``while''. Les autres types de boucle (``for'' et ``do/while'') peuvent être
construits avec ces opérateurs.

\paragraph{Fonctions :} le code est organisé en fonctions ``simples'',
c'est-à-dire qui ne sont pas des fermetures. Même si le corps
d'une fonction peut être inclus dans le corps d'une autre, il n'est pas possible
d'accéder aux variables de la portée entourante depuis la fonction intérieure.

\section{Syntaxe}

Les figures~\ref{fig:stx-data}, \ref{fig:stx} et \ref{fig:stx-ops} présentent
notre langage intermédiaire. Il contient la plupart des fonctionnalités
présentes dans les langages impératifs comme C.

Un programme est organisé en fonctions, qui contiennent des instructions, qui
elles-mêmes manipulent des expressions.

Le flot de contrôle est simplifié par rapport à C : il ne contient que
l'alternative ("if") et la boucle "while". Les autres formes de boucle
("do/while" et "for") peuvent être émulées par une boucle "while".

Les fonctionnalités manquantes, et comment les émuler, seront discutés dans le
chapitre~\ref{cha:conclusion}. % TODO vraiment ?

Pour l'alternative, on introduit également la forme courte $\iThen{e}{i} =
\iIf{e}{i}{\iPass}$.

Les opérateurs sont donnés dans la figure~\ref{fig:stx-ops}.

% TODO un mot sur les constantes dont \eUnit

\begin{figure}

  \begin{align*}
  \gramdef{Constantes}{c}
                 { i      }{ Entier }
                 { d      }{ Flottant }
                 { \eNull }{ Pointeur nul }
                 { \eUnit }{ Valeur unité }
                 {END}
  \\
  \gramdef{Expressions}{e}
                 { c               }{ Constante }
                 { lv              }{ Accès mémoire }
                 { \opun~e         }{ Opération unaire }
                 { e~\opbin~e      }{ Opération binaire }
                 { \& lv           }{ Pointeur }
                 { lv ← e          }{ Affectation }
                 { \{ l_1 : e_1 ;
                    ; l_n : e_n \} }{ Structure }
                 { \{e_1 ;…; e_n\} }{ Tableau }
                 { f               }{ Fonction }
                 { e (e_1, …, e_n) }{ Appel de fonction }
                 {END}
  \\
  \gramdef{Left-values}{lv}
                  { x      }{ Variable }
                  { *lv    }{ Déréférencement }
                  { lv.l_S }{ Accès à un champ }
                  { lv[e]  }{ Accès à un élément }
                  {END}
  \end{align*}

  \caption{Syntaxe - expressions}
  \label{fig:stx-data}
\end{figure}

\begin{figure}

  \begin{align*}
  \gramdef{Instructions}{i}
                 { \iPass          }{Instruction vide}
                 { i;i             }{Séquence}
                 { e               }{Expression}
                 { \iDecl{x}{e}{i} }{Déclaration de variable}
                 { \iIf{e}{i}{i}   }{Alternative}
                 { \iWhile{e}{i}   }{Boucle}
                 { \iReturn{e}     }{Retour de fonction}
                 {END}
  \\
  \gramdef{Fonctions}{f}
                 { \mathrm{fun} (x_1, …, x_n) \{ i \} }{Arguments, corps}
                 {END}
  \\
  \gramdef{Phrases}{p}
                 { x = e }{Variable globale}
                 { e     }{Évaluation d'expression}
                 {END}
  \\
  \gramdef{Programme}{P}
                 { (p_1, …, p_n)}{Phrases}
                 {END}
  \end{align*}

  \caption{Syntaxe - instructions}
  \label{fig:stx}
\end{figure}

\begin{figure}

  \begin{align*}
  \gramdef{Opérateurs binaires}{\opbin}
      { +,-,\times,/,\% }{Arithmétique entière}
      { +.,-.,\times.,/.}{Arithmétique flottante}
      { +_p, -_p        }{Arithmétique de pointeurs}
      { =,≠,≤,≥,<,>     }{Comparaisons}
      { \&,|,\opxor     }{Opérateurs bit à bit}
      { \&\&,||         }{Opérateurs logiques}
      { \ll, \gg        }{Décalages}
      {END}
  \\
  \gramdef{Opérateurs unaires}{\opun}
      { +,-   }{Arithmétique entière}
      { +.,-. }{Arithmétique flottante}
      { \sim  }{Négation bit à bit}
      { !     }{Négation logique}
      {END}
  \end{align*}

  \caption{Syntaxe - opérateurs}
  \label{fig:stx-ops}
\end{figure}

\section{Définitions préliminaires}

On suppose avoir à notre disposition un ensemble infini dénombrable
d'identificateurs \sId (par exemple des chaînes de caractères).

$X^*$ est l'ensemble des suites finies de $X$, indexées à partir de 1. Si $u ∈
X^*$, on note $|u|$ le nombre d'éléments de $u$ (le cardinal de son ensemble de
définition). Pour $1 ≤ i ≤ |u|$, on note $u_i = u(i)$ le i-ème élément de la
suite.

On peut aussi voir les suites comme des listes : on note $[]$ la suite vide,
telle que $|[]| = 0$. On définit en outre la construction de suite de la manière
suivante : si $x ∈ X$ et $u ∈ X^*$, la liste $x::u ∈ X^*$ est la liste $v$ telle
que :

\begin{align*}
  v_1 = & x \\
  ∀ i ∈ [1; |u|] , v_{i+1} = & u_i
\end{align*}

La concaténation des listes $u$ et $v$ est la liste $u@v = w$ telle que :

\begin{align*}
|w| = & |u| + |v| \\
∀ i ∈ [1 ; |u|] , w_i = & u_i \\
∀ j ∈ [1 ; |v|] , w_{|u| + j} = & v_j
\end{align*}

\section{Mémoire}

L'interprète que nous nous apprêtons à définir manipule des valeurs qui sont
associées aux variables du programme.

La mémoire est constituée de variables, qui contiennent des valeurs. Ces
variables sont organisées, d'une part en un ensemble de variables globales, et
d'autre part en une pile de contextes d'appel\footnote{qu'on appellera donc
aussi cadres de pile pour \emph{stack frames} en anglais}. Cette structure
empilée permet de représenter les différents contextes à chaque appel de
fonction : par exemple, si une fonction s'appelle récursivement, plusieurs
instances de ses variables locales sont présentes dans le programme.

La structure de pile des locales permet de les organiser en niveaux
indépendants: à chaque appel de fonction, un nouveau cadre de pile est créé,
comprenant ses paramètres et ses variables locales. Au contraire, pour les
globales il n'y a pas de système d'empilement, puisque ces variables sont
accessibles depuis tout point du programme.

Pour identifier de manière non ambigüe une variable, on note simplement $x$ la
variable globale nommée $x$, et $(n, x)$ la variable locale nommée $x$ dans le
$n$\ieme cadre de pile\footnote{Les paramètres de fonction sont traités comme
des variables locales et se retrouvent dans le cadre correspondant.}.

Les affectations peuvent avoir la forme $x ← e$ où $x$ est une variable et $e$
est une expression, mais pas seulement. En effet, à gauche de $←$ on trouve en
général non pas une variable mais une left-value. Pour représenter quelle partie
de la mémoire doit être accédée par cette left-value, on introduit la notion de
chemin $φ$. Un chemin est en quelque sorte une left-value symbolique évaluée :
les cas sont similaires, sauf que tous les indices sont évalués. Par exemple, $φ
= (5, x).p$ représente le champ "$p$" de la variable $x$ dans le 5\ieme cadre de
pile.

Les valeurs, quant à elles, peuvent avoir les formes suivantes (résumé sur la
figure~\ref{fig:interp-val}) :

\begin{itemize}
\item

$\widehat{c}$ : une constante. La notation circonflexe permet de distinguer
les constructions syntaxique des constructions sémantiques. Par exemple, à la
syntaxe $3$ correspond la valeur $\widehat{3}$.

Les valeurs entières sont les entiers signés sur 32 bits, c'est à dire entre
$-2^{31}$ à $2^{31}-1$. Mais ce choix est arbitraire : de la même manière, on
aurait pu choisir des nombres à 64 bits ou même de précision arbitraire.
Les flottants sont les flottants IEEE 754 de 32 bits \cite{ieee754}.

\item

$φ$ : une référence mémoire. Ce chemin correspond à un pointeur sur une
left-value. Par exemple, l'expression $\&x$ s'évalue en $φ = (5, x)$ si $x$
désigne lexicalement une variable dans le 5\ieme cadre de pile.

\item

$\widehat{ \{ l_1 : v_1 ; … ; l_n : v_n \} }$ : une structure. Comme
précédemment, on note $\widehat{\{\cdot\}}$ pour dénoter les valeurs.

\item

$\widehat{ \{v_1 ;…; v_n\} }$ : un tableau. Pareillement, $\widehat{\{\cdot\}}$
permet de désigner les valeurs. Par exemple, si $x$ vaut $2$ et $y$ vaut $3$,
l'expression $\{ x, y \}$ s'évaluera en valeur $\widehat{\{ 2, 3 \}}$

\item

$\widehat{f}$ : une fonction. Les valeurs fonctions comportent l'intégralité de
la définition de la fonction (liste de paramètres, de variables locales et
corps). Remarquons que contrairement à certains langages, l'environnement n'est
pas capturé (il n'y a pas de clôture lexicale).

% TODO citer sur les closures ?

\item $Ω$ : une erreur. Par exemple le résultat de $5 / 0$ est $\serr{div}$.

% TODO regrouper la présentation des différents cas d'erreur

\end{itemize}

\begin{figure}%{{{

  \begin{align*}
  \gramdef{Valeurs}{v}
      { \widehat{c}     }{Constante}
      { φ               }{Référence mémoire}
      { \widehat{
         \{ l_1 : v_1 ;
       … ; l_n : v_n \}
       }                }{Structure}
      { \widehat{
        \{v_1 ;…; v_n\}
        }               }{Tableau}
      { \widehat{f}     }{Fonction}
      { Ω               }{Erreur}
      {END}
  \\
  \gramdef{Chemins}{φ}
     { a    }{Adresse}
     { *φ   }{Déréférencement}
     { φ.l  }{Accès à un champ}
     { φ[n] }{Accès à un élément}
     {END}
  \\
  \gramdef{Adresses}{a}
     { (n, x) }{Variable locale}
     { x      }{Variable globale}
     {END}
  \\
  \gramdef{Erreur}{Ω}
    { \serr{array} }{Débordement de tableau}
    { \serr{ptr}   }{Erreur de pointeur}
    { \serr{div}   }{Division par zéro}
    { \serr{field} }{Erreur de champ}
    {END}
  \end{align*}

  \caption{Valeurs}
  \label{fig:interp-val}
\end{figure}%}}}

La figure~\ref{fig:interp} résume comment ces valeurs sont organisées. Une pile
est une liste de cadre de piles, et un cadre de pile est une liste de couples
(nom, valeur). Un état mémoire $m$ est un couple $(s, g)$ où $s$ est une pile
et $g$ un cadre de pile (qui représente les variables globales).

Enfin, l'interprétation est définie comme une relation $\cdot → \cdot$ entre
états $Ξ$ ; ces états sont d'une des formes suivantes :

\begin{itemize}
\item
  un couple $\msi{m}{e}$ où $e$ est une expression et $m$ un état
  mémoire. $m$ est l'état mémoire sous lequel l'évaluation sera
  réalisée. Par exemple $\mm{([], [x,3])}{3}{([], [x,3])}{\widehat{3}}$
  L'évaluation des expressions est détaillée dans la
  section~\ref{sec:eval-exp}.
% TODO widehat sur le 3 ? est-ce qu'il faut distinguer les valeurs?
\item
  un couple $\msi{m}{i}$ où $i$ est une instruction et $m$ un état
  mémoire. La réduction instructions est traitée dans la
  section~\ref{sec:eval-instr}.
\item
  une erreur $Ω$. La propagation des erreurs est détaillée dans la
  section~\ref{sec:eval-errors}.
\end{itemize}

\begin{figure}%{{{

  \begin{align*}
  \gramdef{Pile}{s}
    { [] }{Pile vide}
    { \{ x_1 ↦v_1; … ; x_n ↦v_n\} :: s }{Ajout d'un cadre}
    {END}
  \\
  \gramdef{État mémoire}{m}
    { (s, \{ x_1 ↦v_1; … ; x_n ↦v_n\})}{Pile, globales}
    {END}
  \\
  \gramdef{État d'interpréteur}{Ξ}
    { \msi{m}{e} }{Expression, mémoire}
    { \msi{m}{i} }{Instruction, mémoire}
    { Ω          }{Erreur}
    {END}
  \end{align*}

  \caption{Composantes d'un état mémoire}
  \label{fig:interp}
\end{figure}%}}}

\section{Opérations sur les valeurs}
\label{sec:sem-ops}

Un certain nombre d'opérations est possibles sur les valeurs
(figure~\ref{fig:stx-ops}) :

\begin{itemize}
\item
  les opérations arithmétiques $+$, $-$, $×$, $/$ et $\%$ sur les entiers.
  L'opérateur $\%$ correspond au modulo (reste de la division euclidienne).
  En cas de division par zéro, l'erreur $\serr{div}$ est levée.
\item
  les versions ``pointées'' $+.$, $-.$, $×.$ et $/.$ sur les flottants
\item
  les opérations d'arithmétique de pointeur $+_p$ et $-_p$ qui à un chemin
  mémoire et un entier associent un chemin mémoire.
\item
  les opérations d'égalité $=$ et $≠$. L'égalité entre entiers ou entre
  flottants est immédiate. Deux valeurs composées (tableaux ou structures) sont
  égales si elles ont la meme "forme" (même taille pour les tableaux, et même
  champs pour les structures) et que toutes leurs sous-valeurs sont égales deux
  à deux. Les références mémoire $φ$ sont égales lorsque les chemins qu'ils
  décrivent sont syntaxiquement égaux
  \footnote{
    Il est donc possible que deux pointeurs pointent sur la même adresse mais
    soient considérés différents. La raison pour ce choix est que la comparaison
    doit pouvoir se faire sans accéder à la mémoire.
    % TODO exemple
  }.
\item
  les opérations de comparaison $≤,≥,<,>$ sont définies avec leur sémantique
  habituelle sur les entiers et les flottants. Sur les références mémoires,
  elles sont définies dans le cas où les deux opérarandes sont de la forme
  $φ[\cdot]$ par : $φ[n]~\opbin~φ[m] \eqdef n~\opbin~m$. Dans les autres cas,
  l'erreur $\serr{ptr}$ est renvoyée.
\item
  les opérateurs bit à bit sont définis sur les entiers. $\&$, $|$ et $\opxor$
  représentent respectivement la conjonction, la disjonction et la disjonction
  exclusive (XOR).
\item
  des versions logiques de la conjonction ($\&\&$) et de la disjonction ($||$)
  sont également présentes. Leur sémantique est donnée par le tableau suivant :

  \begin{center}
    \begin{tabular}{rr|cc}
       $n$ &  $m$ & $n~\&\&~m$ & $n~||~m$ \\
      \hline
       $0$ &  $0$ & $0$        & $0$      \\
       $0$ & $≠0$ & $0$        & $1$      \\
      $≠0$ &  $0$ & $0$        & $1$      \\
      $≠0$ & $≠0$ & $1$        & $1$      \\
    \end{tabular}
  \end{center}

\item
  des opérateurs de décalage à gauche ($\ll$) et à droite ($\gg$) sont présents.
  Eux aussi ne s'appliquent qu'aux entiers.

\item
  les opérateurs arithmétiques unaires $+$, $-$, $+.$ et $-.$ sont équivalents à
  l'opération binaire correspondante avec $0$ ou $0.$ comme première opérande.

\item
  $\sim$ inverse tous les bits de son opérande. $!$ est une version logique,
  c'est à dire que $!0 = 1$ et si $n ≠ 0$, $!n = 0$.
\end{itemize}

% TODO que se passe-t'il dans les autres cas ? introduire un \serr{typ} ?

\section{Opérations sur les états mémoire}
\label{sec:memops}

% TODO faire un blabla similaire sur les instructions

\begin{definition}[Recherche de variable]

  La recherche de variable permet d'associer à une variable $x$ une adresse $a$.

  Chaque fonction peut accéder aux variables locales de la fonction en cours,
  ainsi qu'aux variables globales.

  \begin{align*}
    \mathrm{Lookup} ((s, g), x) = & (|s|, x)
                                    \mbox{ si }|s| > 0
                                    \mbox{ et }∃ (x, v) ∈ s_1 \\
    \mathrm{Lookup} ((s, g), x) = & x \mbox{ si } (x, v) ∈ g
  \end{align*}

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. En retournant à
l'appelant, il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  On définit l'empilement d'un cadre de pile $c = ((x_1, v_1), …, (x_n, v_n))$
  sur un état mémoire $m = (s, g)$ (figure~\ref{fig:stackops-push}):

  \[
    \mathrm{Push}((s, g), c) = (c::s, g)
  \]

  On définit aussi l'extension du dernier cadre de pile
  (figure~\ref{fig:stackops-extend}):

  \[
    \mathrm{Extend}((c::s, g), x) = (((x @ c) :: s), g)
  \]

  De même on définit le dépilement (figure~\ref{fig:stackops-pop}):

  \[
    \mathrm{Pop}(c::s, g) = (s, g)
  \]

\end{definition}

\begin{figure}

  \centering

  \subbottom[Empilement]{
  \label{fig:stackops-push}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (8,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;
    \path (12,0)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;
    \draw [->] (9.2, 1) -- node[auto] {$\mathrm{Push}((x, 0))$} ++(1.6, 0);
  \end{tikzpicture}
  }

  \subbottom[Extension de cadre]{
  \label{fig:stackops-extend}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (4,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;
    \path (8,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0, y↦3$}
    ;
    \draw [->] (5.2, -2) -- node[auto] {$\mathrm{Extend}((y, 3))$} ++(1.6, 0);
  \end{tikzpicture}
  }

  \subbottom[Dépilement]{
  \label{fig:stackops-pop}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (0,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$…$}
    ;
    \path (4,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;
    \draw [->] (1.2, 1) -- node[auto] {Pop} ++(1.6, 0);
  \end{tikzpicture}
  }

  \caption{Opérations de pile}
  \label{fig:stackops}
\end{figure}

On définit aussi une opération de nettoyage de pile, qui sera utile pour les
retours de fonction.

En effet, si une référence au dernier cadre est toujours présente après
le retour, elle pourra se résoudre en un objet différent plus tard dans
l'exécution du programme.

La fonction $\mathrm{Cleanup}$ est donnée par :

\def\cleanuplist#1#2{\mathrm{CleanupList}(#1, #2)}
\def\cllive#1#2{\mathrm{Live}(#1, #2)}

\begin{align*}
  \mathrm{Cleanup}(s, g)  = & (s', g') \\
                    où g' = & \cleanuplist{|s|}{g} \\
                       s' = & [\cleanuplist{|s|}{s_1},
                            …, \cleanuplist{|s|}{s_n}] \\
       \cleanuplist{p}{u} = & \{(x, v) ∈ u / v\mbox{ n'est pas une adresse} \} \\
                       \cup & \{(x, φ) ∈ u / \cllive{p}{φ} \} \\
    \cllive{p}{(n, x)} = & n < p \\
    \cllive{p}{(x)}    = & \mathrm{Vrai} \\
    \cllive{p}{*φ}     = & \cllive{p}{φ} \\
    \cllive{p}{φ.l}    = & \cllive{p}{φ} \\
    \cllive{p}{φ[n]}   = & \cllive{p}{φ}
\end{align*}

Sans cette règle, examinons le programme suivant :

\begin{Verbatim}
f ()                g (p)           h ()
  (x=0)               (x=0.0)         (p=f())
{                   {               {
  return (&x);        *p = 1;         g(p);
}                   }               }
\end{Verbatim}

L'exécution de $h()$ donne à $p$ la valeur $(1, x)$. Donc en arrivant dans $g$, le
déréférencement de $p$ va modifier $x$.

\begin{figure}
  \centering


  \begin{tikzpicture}
    [ stack/.style={draw,minimum height=5mm,minimum width=3cm ,shape=rectangle}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    , substack/.style={draw, minimum height=5mm, }
    , oldstack/.style={loosely dashed}
    , fixmatrix/.style={matrix, row sep=-\pgflinewidth, column sep=-\pgflinewidth}
    , >=stealth'
    ]

    \path (0, 0)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p) { }; & \node { }; & \node (q) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x) { }; & \node (y) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, 0) {
          \node (r) { }; & \node { }; \\
      };

      \draw[->] (p.center) -- ++(0, 0.5);
      \draw[->] (q.center) -| ($ (r.center) - (3mm, 0) $);
      \draw[->] ($ (r.center) + (3mm, 0) $) |- (y.center);

      %%%%%

    \path (0, -3)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p2) { }; & \node { }; & \node (q2) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x2) { }; & \node (y2) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, -3) {
          \node (r2) { }; & \node { }; \\
      };

      \draw[->] (q2.center) -| ($ (r2.center) - (3mm, 0) $);

      \def\crossat#1{
        \draw ($ #1 + (2mm, 2mm) $) -- ++ (-4mm, -4mm);
        \draw ($ #1 + (-2mm, 2mm) $) -- ++ (4mm, -4mm);
      }

      \crossat{(r2.center) + (3mm, 0)}
      \crossat{(p2.center)}

  \end{tikzpicture}

  \caption{Nettoyage d'un cadre de pile}
  \label{fig:stackcleanup}
\end{figure}

\section{Accesseurs}
\label{sec:mem-access}

On définit ici quelques lentilles.

\begin{definition}[Accès à une liste d'associations]

  Une liste d'association est une liste de paires (clef, valeur) avec
  l'invariant supplémentaire que les clefs sont uniques. Il est donc possible de
  trouver au plus une valeur associée à une clef donnée. L'écriture est
  également possible, en remplaçant un couple par un couple avec une valeur
  différente.

  L'accesseur $[\cdot]_L$ est défini par :

  \begin{align*}
    l[x]_L     = & v \mbox{ où } \{v\} = \{y / (x, y) ∈ l\} \\
    l[x ← v]_L = & (x, v) :: \{ (y, v) ∈ g(x) / y ≠ x \})
  \end{align*}

\end{definition}

\begin{definition}[Accès par adresse]

  Les états mémoire sont constitués des listes d'association (nom, valeur).

  L'accesseur par adresse $[\cdot]_A$ permet de généraliser l'accès à ces
  valeurs en utilisant comme clef non pas un nom mais une adresse.

  Selon cette adresse, on accède soit à la liste des globales, soit à une des
  listes de la pile des locales.

  Pour $m = (s, g)$,

  \begin{align*}
    m [x]_A          = & g[x]_L           & \textrm{Lecture d'une globale} \\
    m [(n, x)]_A     = & s_{|l|-n+1}[x]_L & \textrm{Lecture d'une locale} \\
    m [x ← v]_A      = & (s, g[x←v]_L)    & \textrm{Écriture d'une globale} \\
    m [(n, x) ← v]_A = & (s', g)          & \textrm{Écriture d'une locale} \\
           \mbox{ où } & s'_{|l|-n+1} = s_{|l|-n+1}[x ← v]_L \\
                       & ∀ i ≠ |l|-n+1, s'_i = s_i
  \end{align*}

% TODO normalement grâce à clean ça fail jamais

\end{definition}

Les numéros de cadre qui permettent d'identifier les globales (le $n$ dans $(n,
x)$) croissent avec la pile. D'autre part, l'empilement se fait en tête de liste
(près de l'indice 1). Donc pour accéder aux plus vieilles locales (numérotées
1), il faut accéder au dernier élément de la liste. Ceci explique pourquoi un
indice $|l|-n+1$ apparaît dans la définition précédente.

\begin{definition}[Accès par champ]

  Les valeurs qui sont des structures possèdent des sous-valeurs, associées à
  des noms de champ.

  L'accesseur $[ \cdot ]_L$ permet de lire et de modifier un champ de ces
  valeurs.

  L'erreur $\serr{field}$ est levée si on accède à un champ non existant.

  \begin{align*}
    \{ l_1 : v_1; … ; l_n : v_n \}[l]_L =
          & v_i \mbox{ si } ∃i∈[1;n], l=l_i\\
    \{ l_1 : v_1; … ; l_n : v_n \}[l ← v]_L = &
        \{ l_1 : v_1 \\
       & ; … \\
       & ; l_{p-1} : v_{p-1} \\
       & ; l_p : v \\
       & ; l_{p+1} : v_{p+1} \\
       & ; … \\
       & ; l_n : v_n \} \mbox{ si } ∃p ∈ [1;n], l = l_p \\
    \{ l_1 : v_1; … ; l_n : v_n \}[l]_L = & \serr{field} \mbox{ sinon} \\
    \{ l_1 : v_1; … ; l_n : v_n \}[l ← v]_L = & \serr{field} \mbox{ sinon}
  \end{align*}

\end{definition}

\begin{definition}[Accès par indice]

  On définit de même un accesseur $[\cdot]_I$ pour les accès par indice à des
  valeurs tableaux. Néanmoins le paramètre indice est toujours un entier et pas
  une expression arbitraire.

  \begin{align*}
    \{ v_1 ; … ; v_n \} [i]_I   = & v_{i+1} \textrm{ si } i ∈ [0;n-1] \\
    \{ v_1 ; … ; v_n \} [i]_I   = & \serr{array} \textrm{ sinon} \\
    \{ v_1 ; … ; v_n \} [i←v]_I = & \{ v'_1 ; … ; v'_n \} \textrm{ si } i ∈ [0;n-1] \\
                      \mbox{ où } & \begin{cases}
                                      v'_i = v \\
                                      ∀j≠i, v'_j = v_j \\
                                    \end{cases} \\
    \{ v_1 ; … ; v_n \} [i←v]_I = & \serr{array} \textrm{ sinon} \\
  \end{align*}

  % TODO off by ones...

\end{definition}

\begin{definition}[Accès par chemin]
  \label{def:acces-phi}

  L'accès par chemin $Φ$ permet de lire et de modifier la mémoire en profondeur.

  On peut accéder directement à une variable:

  \begin{align*}
    Φ(a) = & A(a) \\
  \end{align*}

  Les accès à des sous-valeurs se font en composant les accesseurs
  (définition~\ref{def:lens-comp}) :

  \begin{align*}
    Φ(φ.l)  = & Φ(φ) \ggg L(l) \\
    Φ(φ[i]) = & Φ(φ) \ggg I(i) \\
  \end{align*}

  Le déréférencement est défini comme suit :

  \begin{align*}
    m[*φ]_Φ     = & m[φ']_Φ     \mbox{ où } φ' = m[φ]_Φ \\
    m[*φ ← v]_Φ = & m[φ' ← v]_Φ \mbox{ où } φ' = m[φ]_Φ \\
  \end{align*}

  Enfin, l'accès à la mémoire par le pointeur nul provoque une erreur :

  \begin{align*}
    m[\eNull    ]_Φ = & \serr{ptr} \\
    m[\eNull ← v]_Φ = & \serr{ptr} \\
  \end{align*}

\end{definition}

Cette dernière définition mérite une explication. Dans le cas de la lecture, il
suffit d'appliquer les bons accesseurs : $[\cdot]_L$ pour $φ.l$, etc.

En revanche, la modification est plus complexe. Les deux premiers cas ($φ = a$
et $φ = *φ'$) modifient directement une valeur complète (en modifiant une
association), mais les deux suivants ($φ = φ'.l$ et $φ = φ'[i]$) ne font
qu'altérer une sous-valeur existante. Il est donc nécessaire de procéder en 3
étapes :

\begin{itemize}
\item obtenir la valeur à modifier (soit $m[φ]_φ$)
\item construitre une valeur altérée (en appliquant par exemple $[l←v]_L$)
\item affecter cette valeur au même chemin (le $m[φ ← …]_φ$ externe)
\end{itemize}

Dans la suite, on notera uniquement $[\cdot]$ tous ces accesseurs lorsque ce
n'est pas ambigü.

\section{Contextes d'évaluation}

L'évaluation des expressions repose sur la notion de contextes d'évaluation.
L'idée est que si on peut évaluer une expression, alors on peut évaluer une
expression qui contient celle-ci.

Par exemple, supposons que $\mm{m}{f(3)}{m}{2}$. Alors on peut ajouter la
constante $1$ à gauche de chaque expression sans changer le résultat :
$\mm{m}{1+f(3)}{m}{1+2}$. On a utilisé le même contexte
$C = 1+\ctxEmpty$.

Pour pouvoir raisonner en termes de contextes, 3 points sont nécessaires :

\begin{itemize}
\item comment découper une expression selon un contextes
\item comment appliquer une règle d'évaluation sous un contexte
\item comment regrouper une expression et un contexte
\end{itemize}

\begin{figure}
\figctx{}

\caption{Contextes d'exécution}
\label{fig:eval-ctx}
\end{figure}

Le premier point consiste à définir les contextes eux-mêmes
(figure~\ref{fig:eval-ctx}).

Le deuxième est résolu les règles d'inférence suivantes :

\begin{mathpar}
  \semrule{Ctx}

  \semrule{Ctx-Lv}

  \semrule{Ctx-Instr}
\end{mathpar}

Enfin, le troisième revient à définit l'opérateur de substitution
$\phxx{\ctxSub}$ présent dans la règle précédente. Afin de pouvoir appliquer des
substitution au niveau des left-values et des instructions, on définit aussi
respectivement $\phxx{\ctxSubL}$ et $\phxx{\ctxSubI}$.

Dans la définition de l'ensemble des contextes, chaque cas hormis le cas de base
fait apparaître exactement un "$C$". Chaque contexte est donc constitué
d'exactement un "trou" $\ctxEmpty$ (une dérivation de $C$ est toujours
linéaire). L'opération de substitution consiste à remplacer ce trou, comme
décrit dans la figure~\ref{fig:ctx-sub}.

\begin{figure}
\begin{align*}
  \ctxSub{\ctxEmpty}{e_0} = & e_0 \\
  \ctxSub{(\ctxOp{C}{e}     )}{e_0} = & \ctxOp{\ctxSub{C}{e_0}}{e}      \\
  \ctxSub{(\ctxOp{v}{C}     )}{e_0} = & \ctxOp{v}{\ctxSub{C}{e_0}}      \\
  \ctxSub{(\ctxUnOp{C}      )}{e_0} = & \ctxUnOp{\ctxSub{C}{e_0}}       \\
  \ctxSub{(\ctxLvDeref{C}   )}{e_0} = & \ctxLvDeref{\ctxSub{C}{e_0}}    \\
  \ctxSub{(\ctxLvField{C}{l_S})}{e_0} = & \ctxLvField{\ctxSub{C}{e_0}}{l_S} \\
  \ctxSub{(\ctxLvIndex{φ}{C})}{e_0} = & \ctxLvIndex{φ}{\ctxSub{C}{e_0}} \\
  \ctxSub{(\ctxLvIndex{C}{e})}{e_0} = & \ctxLvIndex{\ctxSub{C}{e_0}}{e} \\
  \ctxSub{(\ctxSet{C}{e})    }{e_0} = & \ctxSet{\ctxSub{C}{e_0}}{e}     \\
  \ctxSub{(\ctxSet{φ}{C})    }{e_0} = & \ctxSet{φ}{\ctxSub{C}{e_0}}     \\
  \ctxSub{\{ l_1:v_1 ; …
     ; l_i:C ; … ; l_n:e_n \}}{e_0} = & \{ l_1:v_1 ; … ; l_i:\ctxSub{C}{e_0} ; … ; l_n:e_n \} \\
  \ctxSub{[ v_1 ; … ; C ; … ; e_n ]}{e_0} = & [ v_1 ; … ; \ctxSub{C}{e_0} ; … ; e_n ]    \\
  \ctxSub{C (e_1, …, e_n)          }{e_0} = & \ctxSub{C}{e_0} (e_1, …, e_n)              \\
  \ctxSub{f (v_1, …, C, …, e_n)    }{e_0} = & f (v_1, …, \ctxSub{C}{e_0}, …, e_n)        \\
  \\
  \ctxSub{(C;i              )}{e_0} = & \ctxSub{C}{e_0};i               \\
  \ctxSub{(\iIf{C}{i_1}{i_2})}{e_0} = & \iIf{\ctxSub{C}{e_0}}{i_1}{i_2} \\
  \ctxSub{(\iReturn{C}      )}{e_0} = & \iReturn{\ctxSub{C}{e_0}}       \\
\end{align*}

\begin{align*}
% C
\ctxSub{C_L}{e_0} = & \ctxSubL{C_L}{e_0} \\
\ctxSub{\ctxOp{C}{e}}{e_0} = & \ctxOp{\ctxSub{C}{e_0}}{e} \\
\ctxSub{\ctxOp{v}{C}}{e_0} = & \ctxOp{v}{\ctxSub{C}{e_0}} \\
\ctxSub{\ctxUnOp{C}}{e_0} = & \ctxUnOp{\ctxSub{C}{e_0}} \\
\ctxSub{\ctxSet{C}{e}}{e_0} = & \ctxSet{\ctxSub{C}{e_0}}{e} \\
\ctxSub{\ctxSet{φ}{C}}{e_0} = & \ctxSet{φ}{\ctxSub{C}{e_0}} \\
\ctxSub{\{ l_1:v_1 ; … ; l_i:C ; … ; l_n:e_n \}}{e_0} = & \{ l_1:v_1 ; … ; l_i:\ctxSub{C}{e_0} ; … ; l_n:e_n \} \\
\ctxSub{[ v_1 ; … ; C ; … ; e_n ]}{e_0} = & [ v_1 ; … ; \ctxSub{C}{e_0} ; … ; e_n ] \\
\ctxSub{C (e_1, …, e_n)}{e_0} = & \ctxSub{C}{e_0} (e_1, …, e_n) \\
\ctxSub{f (v_1, …, C, …, e_n)}{e_0} = & f (v_1, …, \ctxSub{C}{e_0}, …, e_n) \\
\\
% C_L
\ctxSubL{\ctxEmpty}{l_0} = & \ctxEmpty \\
\ctxSubL{\ctxLvDeref{C_L}}{l_0} = & \ctxLvDeref{\ctxSubL{C_L}{l_0}} \\
\ctxSubL{\ctxLvField{C_L}{l_S}}{l_0} = & \ctxLvField{\ctxSubL{C_L}{l_0}}{l_S} \\
\ctxSubL{\ctxLvIndex{C_L}{e}}{l_0} = & \ctxLvIndex{\ctxSubL{C_L}{l_0}}{e} \\
\ctxSub{\ctxLvIndex{φ}{C}}{e_0} = & \ctxLvIndex{φ}{\ctxSub{C}{e_0}} \\
\\
% % C_I
% \ctxSubI{C_I;i}{i_0} = & \ctxSubI{C_I}{i_0};i \\
%
% \iIf{C}{i_1}{i_2}
% \iReturn{C}
% C
\end{align*}

\caption{Substitution dans les contextes d'évaluation}
\label{fig:ctx-sub}
\end{figure}

Par exemple, décomposons l'évaluation de $e_1~\opbin~e_2$ en $v =
v_1~\widehat{\opbin}~v_2$ depuis un état mémoire $m$ :

\begin{enumerate}
\item
  on commence par évaluer, d'une manière ou d'une autre, l'expression
  $e_1$ en une valeur $v_1$. Le nouvel état mémoire est noté $m'$. Soit
  donc $\mm{m}{e_1}{m'}{v_1}$.
\item
  En appliquant la règle \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$ (qui est
  une des formes possibles pour un contexte d'évaluation), on déduit de 1. que
  $\mmstar{m}{e_1~\opbin~e_2}{m'}{v_1~\opbin~e_2}$
\item
  D'autre part, on évalue $e_2$ depuis $m'$. En supposant encore que
  l'évaluation converge, notons $v_2$ la valeur calculée et $m''$ l'état mémoire
  résultant : $\mm{m'}{e_2}{m''}{v_2}$.
\item
  Appliquons la règle~\textsc{Ctx} à 3. avec $C = \ctxOp{v_1}{\ctxEmpty}$. On
  obtient $\mmstar{m}{v_1~\opbin~e_2}{m'}{v_1~\opbin~v_2}$.
\item
  En combinant les résultats de 2. et 4. on en déduit que
  $\mmstar{m}{e_1~\opbin~e_2}{m''}{v_1\opbin~v_2}$.
% TODO comment combiner ?
\item D'après la règle~\textsc{Exp_Binop},
  $ \mmstar{m''}{v_1\opbin~v_2}{m''}{v_1~\widehat{\opbin}~v_2}$
\item D'après 5. et 6., on a par combinaison
  $\mmstar{m}{e_1~\opbin~e_2}{m''}{v}$
  en posant
  $v = v_1~\widehat{\opbin}~v_2$
  .
% TODO comment combiner ?
\end{enumerate}

\section{Expressions}
\label{sec:eval-exp}

\begin{definition}[Évaluation d'une expression]

  L'évaluation d'une expression $e$ se fait sous un état mémoire particulier $m$
  et est susceptible de modifier celui-ci en le transformant en un nouveau $m'$.
  Le résultat est toujours une valeur $v$, c'est à dire que nous présentons pour
  les expressions une sémantique à grands pas. Cette évaluation est notée :

  \[
    \mm{m}{e}{m'}{v}
  \]

\end{definition}

\begin{definition}[Évaluation d'une left-value]

  L'évaluation d'une left-value $lv$ produit un "chemin" $φ$ dans une variable,
  qui est en fait équivalent à une left-value dont toutes les sous-expressions
  (d'indices) ont été évaluées.

  On note :

  \[
    \mmlv{m}{lv}{m'}{φ}
  \]

\end{definition}

Puisque des left-values peuvent apparaitre dans les expressions, et des
expressions dans les left-values (en indice de tableau), leurs règles
d'évaluation sont mutuellement récursives.

\subsection*{Left-values}

\begin{figure}

  \centering

  \begin{tikzpicture}
    \node              (a1) {$x$};
    \node[right of=a1] (a2) {$.l_S$};
    \node[right of=a2] (a3) {$[2*n]$};
    \node[right of=a3] (a4) {$.g$};

    \node[below of=a1] (b1) {$(2, x)$};
    \node[below of=a2] (b2) {$.l$};
    \node[below of=a3] (b3) {$[4]$};
    \node[below of=a4] (b4) {$.g$};

    \draw[->] (a1) -- (b1);
    \draw[->] (a2) -- (b2);
    \draw[->] (a3) -- (b3);
    \draw[->] (a4) -- (b4);
  \end{tikzpicture}

  \caption{Évaluation des left-values.}
  \label{fig:eval-lv}
\end{figure}

Obtenir un chemin à partir d'un nom de variable revient à résoudre le nom de
cette variable : est-elle accessible ? Le nom désigne-t'il une variable locale
ou une variable globale ?

\begin{mathpar}
  \semrule{Phi-Var}
\end{mathpar}

Les règles portant sur le déréférencement et l'accès à un champ de structure
sont similaires : on commence par évaluer la left-value sur laquelle porte ce
modificateur, et on place le même modificateur sur le chemin résultant. Dans le
cas des champs de structure, la définition de la structure $S$ n'est pas prise
en compte.

\begin{mathpar}
  \semrule{Phi-Deref}

  \semrule{Phi-Struct}
\end{mathpar}

Enfin, pour évaluer un chemin dans un tableau, on commence par procéder comme
précédemment, c'est-à-dire en évaluant la left-value sur laquelle porte
l'opération d'indexation. Puis on évalue l'expression d'indice en une valeur qui
permet de construire le chemin résultant.

\begin{mathpar}
  \semrule{Phi-Array}
\end{mathpar}

Notons qu'en procédant ainsi, on évalue les left-values de gauche à droite :
dans l'expression $x[e_1][e_2][e_3]$, $e_1$ est évalué en premier, puis
$e_2$, puis $e_3$.

Un exemple d'évaluation est donné dans la figure~\ref{fig:eval-lv}.

\subsection*{Expressions}

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \semrule{Exp-Cst}
\end{mathpar}

De même, une fonction n'est pas évaluée plus :

\begin{mathpar}
  \semrule{Exp-Fun}
\end{mathpar}

% TODO vraiment?

Pour lire le contenu d'un emplacement mémoire (left-value), il faut tout d'abord
l'évaluer en un chemin.

\begin{mathpar}
  \semrule{Exp-Lv}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, est encore imposé : de gauche à droite). À
chaque opérateur $\opbin$, correspond un opérateur sémantique $\widehat{\opbin}$
qui agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers.
Comme précisé dans la section~\ref{sec:sem-ops}, la division par zéro via $/$,
$\%$ ou $/.$ provoque l'erreur $\serr{div}$.

\begin{mathpar}
  \semrule{Exp-UnOp}

  \semrule{Exp-BinOp}
\end{mathpar}

Il est nécessaire de dire un mot sur les opérations $\widehat{+_p}$
et $\widehat{-_p}$ définissant l'arithmétique des pointeurs. Celles-ci sont
uniquement définies pour les références mémoire à un tableau, c'est à dire
celles qui ont la forme $φ[n]$. On a alors :

\begin{align*}
  φ[n]~+_p~m = & φ[n+m] \\
  φ[n]~-_p~m = & φ[n-m] \\
\end{align*}

% TODO widehats ici et ci-dessous non ?

Cela implique qu'on ne peut pas faire faire d'arithmétique de pointeurs au sein
d'une même structure. Autrement c'est une erreur de manipulation de pointeurs :
\label{page:def-arith-ptr-error}

% TODO quoter le passage pertinent de la norme

\begin{align*}
φ~+_p~m = & \serr{ptr} \textrm{ si }∄ (φ', n), φ = φ'[n] \\
φ~-_p~m = & \serr{ptr} \textrm{ si }∄ (φ', n), φ = φ'[n] \\
\eNull~+_p~m = & \serr{ptr} \\
\eNull~-_p~m = & \serr{ptr} \\
\end{align*}

Pour prendre l'adresse d'une variable, il suffit de résoudre celle-ci dans
l'état mémoire courant.

\begin{mathpar}
  \semrule{Exp-AddrOf}
\end{mathpar}

L'affectation se déroule 3 étapes : d'abord, l'expression est évaluée en une
valeur $v$. Ensuite, la left-value est évaluée en un chemin $φ$. Enfin, un
nouvel état mémoire est construit, où la valeur accessible par $φ$ est remplacée
par $v$. Comme dans le langage C, l'expression d'affectation produit une valeur,
qui est celle qui a été affectée.

\begin{mathpar}
  \semrule{Exp-Set}
\end{mathpar}

\subsection*{Expressions composées}

Les littéraux de structures sont évalués en leurs constructions syntaxiques
respectives. Puisque les contextes d'évaluation sont de la forme $ [ v_1 ; … ; C
; … ; e_n ] $, l'évaluation se fait toujours de gauche à droite.

\begin{mathpar}
  \semrule{Exp-Struct}

  \semrule{Exp-Array}
\end{mathpar}

\shorthandoff{!}
\begin{figure}

  \centering

  \begin{tikzpicture}
    [node distance=2cm]

    \node (m0) {$m_0$};
    \node[right of=m0, node distance=3cm] (m1) {$m_1$};
    \node[below of=m1]                    (m2) {$m_2$};
    \node at ($(m0)!(m2)!(0,1)$)          (m3) {$m_3$};
    \node[below of=m3]                    (m4) {$m_4$};

    \draw [->] (m0) -- node[auto] {$\mathrm{Push}(\vec{a}↦\vec{v})$}    (m1);
    \draw [->] (m1) -- node[auto] {$i → \iReturn{v_r}$}                 (m2);
    \draw [->] (m2) -- node[auto] {$\mathrm{Pop}$}                      (m3);
    \draw [->] (m3) -- node[auto] {$\mathrm{Cleanup}$}                  (m4);

    \draw [dashed, ->] ($ (m0) + (-5mm, -3mm) $)
                    -- node[auto, swap] {$f(\vec{e}) → v$}
                       ($ (m4) + (-5mm, 3mm) $);

  \end{tikzpicture}

  \caption{L'appel d'une fonction. La taille de la pile croît de gauche à
  droite, et les réductions se font de haut en bas.}
  \label{fig:fcall-details}

\end{figure}
\shorthandon{!}

Les contextes utilisés dans l'appel de fonction sont similaires. Tout d'abord,
les arguments sont évalués et placés dans un nouveau cadre de pile. Ensuite, le
corps de la fonction est évalué jusqu'à se réduire en une instruction
$\iReturn{v}$. Enfin, le cadre précédemment utilisé est dépilé.

La dernière étape consiste à nettoyer la mémoire de références à l'ancien cadre
de pile (on utilise la fonction $\mathrm{Cleanup}$ définie dans la
section~\label{sec:memops}).

\begin{mathpar}
  \semrule{Exp-Call}
\end{mathpar}

Cette évaluation est décrite dans la figure~\ref{fig:fcall-details}.

\section{Instructions}
\label{sec:eval-instr}

Contrairement à l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante :
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ "plus simple" en partant d'un état mémoire
$m'$. Un tel pas est noté :

\[
  \mmi{m}{i}{m'}{i'}
\]

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$ :

\begin{align*}
  \msi{m}{(x ← 3 ; y ← x)} → & \msi{m [x ↦ \widehat{3}]}{y ← x} \\
                           → & \msi{m [x ↦ \widehat{3}][y ↦ \widehat{3}]}{\iPass}
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \semrule{Seq}

  \semrule{Pass}

  \semrule{Exp}
\end{mathpar}

L'évaluation de $\iDecl{x}{v}{i}$ sous $m$ se fait en trois parties :

\begin{itemize}
\item on crée un environnement mémoire $m'$ en ajoutant à $m$ l'association
$x↦v$.

\item sous $m'$, on évalue $i$ jusqu'à atteindre une instruction $\iPass$ ou
$\iReturn{v_r}$ sous un état $m''$. C'est cette instruction qui sera retournée.

\item on enlève $x$ de $m''$ et on enlève de cet état mémoire les pointeurs
invalides.

\end{itemize}

\begin{mathpar}
  \semrule{Decl}

  \semrule{Decl-Return}
\end{mathpar}

% TODO que faire si la pile de locale est vide ? (declaration de "locale" dans
% une expression au toplevel)

Pour traiter l'alternative, on a besoin de 2 règles. Elles commencent de la même
manière, en évaluant la condition. Si le résultat est 0 (et seulement dans ce
cas), c'est la règle \textsc{If-False} qui est appliquée et l'instruction
revient à évaluer la branche "else". Dans les autres cas, c'est la règle
\textsc{If-True} qui s'applique et la branche "then" qui est prise.

\begin{mathpar}
  \semrule{If-False}

  \semrule{If-True}
\end{mathpar}

Pour traiter la boucle, on peut être tenté de procéder de la même manière :

\begin{mathpar}
  \irule{While-False-Bad}
    { v ≠ 0 }
    { \mmi{m}{\iWhile{v}{i}}{m}{\iPass} }

  \irule{While-True-Bad}
    { }
    { \mmi{m}{\iWhile{0}{i}}{m'}{i;\iWhile{e}{i}}}
\end{mathpar}

Mais la seconde règle est impossible : puisque $e$ a déjà été évaluée, il est
impossible de la réintroduire non évaluée en partie droite.

À la place, on exprime la sémantique de la boucle comme une simple règle de
réécriture :

\begin{mathpar}
  \semrule{While}
\end{mathpar}

Cette règle revient à dire qu'on peut dérouler une boucle. Pour la comprendre,
on peut remarquer qu'une boucle "while" est en réalité équivalente une infinité
de "if" imbriqués.

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    if(e) {
        i;
        if(e) {
            i;
            if(e) {
                i;
                ...
            }
        }
    }
}
\end{Verbatim}
\end{minipage}

Donc en remplaçant le second "if" par le "while", on obtient :

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    while(e) {
        i
    }
}
\end{Verbatim}
\end{minipage}

Enfin, si un "return" apparaît dans une séquence, on peut supprimer la suite :

\begin{mathpar}
  \semrule{Return}
\end{mathpar}

\section{Erreurs}
\label{sec:eval-errors}

% TODO

Les erreurs se propagent des données vers l'interprète ; c'est à dire que si
une expression ou instruction est réduite en une valeur d'erreur $Ω$, alors une
transition est faite vers cet état d'erreur.

Cela est aussi vrai d'une sous-expression ou sous-instruction : si l'évaluation
de $e_1$ provoque une erreur, l'évaluation de $e_1 + e_2$ également. La notion
de sous-structure est présente grâce aux contexte $C$ dans la règle suivante :

\begin{mathpar}
  \semrule{Exp-Err}

  \semrule{Eval-Err}
\end{mathpar}

% TODO blabla sur les 2 et prouver que \ctxSub{C}{Ω} → Ω

\section{Phrases}

Un programme est constitué d'une suite de phrases : déclarations de fonctions,
de variables et de types, et évaluation d'expressions.

Il est donc logique que l'évaluation d'une phrase fasse passer d'un état mémoire
à un autre :

\[
  \ph{m}{p}{m'}
\]

L'évaluation d'une expression est uniquement faite pour ses effets de bord. Par
exemple, après avoir défini les fonctions du programme, on pourra appeller
$\textrm{main}()$.

\begin{mathpar}
  \semrule{Ph-Exp}
\end{mathpar}

La déclaration d'une variable globale (avec un initialiseur) consiste à évaluer
cet initialiseur et à étendre l'état mémoire avec ce couple (variable, valeur).

\begin{mathpar}
  \semrule{Ph-Var}
\end{mathpar}

\section{Exécution}

L'exécution d'un programme est sans surprise l'exécution de ses phrases, les
unes à la suite des autres.

On commence par étendre l'extension $→^*$ au listes de la relation $→$ :

\begin{mathpar}
  \semrule{Ph*-Nil}

  \semrule{Ph*-Cons}
\end{mathpar}

L'exécution d'un programme est alors :

\[
  \phstar{([], [])}{P}{m}
\]

\section{Exemple : l'algorithme d'Euclide}

Version par divisions successives:

\begin{Verbatim}
function gcd(a, b)
  var t = 0;
  while b != 0
    t = b
    b = a mod b
    a = t
  return a
\end{Verbatim}

Soit :

\def\exinnerif{t←b;b←a\%b;a←t}

\begin{mathpar}
  f(a, b) (t = 0) \{
    \iWhile{b ≠ 0}{
      \exinnerif
    };
    \iReturn{a}
  \}
\end{mathpar}

\[
  \msi{m}{f(1071, 462)} → ?
\]

\[
  \msi{m[a↦1071][b↦462][t↦0]}{\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} → ?
\]

(on notera cet état $s_0 = \msi{m_0}{i_0}$)

\[
  \mm{m_0}{a = 0}{m_0}{0}
\]

donc

\[
  \mm{m_0}{\iThen{a = 0}{\iReturn{b}}}{m[a↦1071][b↦462]}{\iPass}
\]

{ \scriptsize
\begin{align}
  s_0 → & \msi{m_0  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_0  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0  }{ b←a\%b;a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0''}{ a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_1  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_2  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_3  }{ \iPass; \iReturn{a}} \\
      → & \msi{m_3  }{ \iReturn{a}}
\end{align}

\begin{align*}
  m_0'  = & m_0  [t↦462] = m[a↦1071][b↦462][t↦462] \\
  m_0'' = & m_0' [b↦147] = m[a↦1071][b↦147][t↦462] \\
  m_1   = & m_0''[a↦462] = m[a↦462][b↦147][t↦462] \\
  m_2   = & m_1[t↦147][b↦21][a↦147] = m[a↦147][b↦21][t↦147] \\
  m_3   = & m_2[t↦21][b↦0][a↦21] = m[a↦21][b↦0][t↦21]
\end{align*}
}

\begin{center}\rule{3in}{0.4pt}\end{center}

\section*{TODO}

\begin{itemize}
\item substitutions dans les ctx : éditer $C_l$ et $C_i$
  (en fait, séparer selon le truc substitué (2è arg), pas le premier)
\item cas d'erreur si on accède à un index d'une struct ou vice versa?
\item Exp-AddrOf sur toutes les lv
\item C ::= \&C
\item changer les para de présentation des règles
\item widehats sur les constantes ?
\item liste d'assos $→$ fonction
\item définir les opérations d'ajout/remplacement sur les états mémoire
\item interdire d'avoir plusieurs variables qui ont le même nom dans un cadre
\item return implicite en fin de fct
\item clarifier quand il faut un $\mm{\cdot}{\cdot}{\cdot}{\cdot}$
             et quand il faut un $\mmstar{\cdot}{\cdot}{\cdot}{\cdot}$
\item "et" et "ou" lazy
\end{itemize}

Limitations :

\begin{itemize}
\item (ou feature) variables non initialisées
\item tableaux de taille dynamique ?
\item structures récursives et corécursives
\end{itemize}

% vim: spelllang=fr
