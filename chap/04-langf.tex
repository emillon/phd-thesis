\epigraph{
On two occasions I have been asked, ``Pray, Mr.\ Babbage, if you put into the
machine wrong figures, will the right answers come out?''… I am not able rightly
to apprehend the kind of confusion of ideas that could provoke such a question.
}
{--- \textup{Charles Babbage}, Passages from the Life of a Philosopher}

Dans ce chapitre nous présentons \langname, un langage impératif inspiré de C.
Sa syntaxe est tout d'abord décrite; puis une sémantique opérationnelle est
explicitée.

Ce langage servira de support au systèmes de types décrit dans le
chapitre~\ref{cha:typbase} et enrichi dans le chapitre~\ref{cha:qualifs}.

La traduction depuis C sera explicitée dans le chapitre~\ref{cha:implem}.

\section{Notations}

\subsection*{Ensembles inductifs}

Dans ce chapitre (et les chapitres suivants), on définit de nombreux ensembles
inductifs. Plutôt que d'écrire la construction explicite par point fixe, on
emploie une notation en grammaire.

Étudions l'exemple des listes chaînées composées d'élements de $ℕ$.

Notons $L$ cet ensemble; si $[]$ est la liste vide et $n::l$ la liste formée
d'une ``tête'' $n ∈ ℕ$ et d'une ``queue'' $l ∈ L$. Toute liste est donc d'une des
formes suivantes:

\begin{itemize}
\item $[]$
\item $n_1::[]$
\item $n_1::n_2::[]$
\item etc.
\end{itemize}

On peut donc $L$ de la manière inductive suivante:

\def\opfix{\textrm{fix}\xspace}

\begin{align*}
  \textsc{L} & = \opfix (L') \\
  L'(E) & = \{[]\} \cup \{ n::l / n ∈ ℕ, l ∈ E \} \\
\end{align*}

où

\begin{align*}
  \opfix (f) & = \bigcup_{n=0}^{\infty} f^{n}(∅) \\
  f^0(x) & = x \\
  ∀ n > 0, f^n(x) & = f^{n-1}(f (x)) \\
\end{align*}

(L'itération $n$ de l'union correspond aux listes comprenant au plus $n$
éléments)

Plutôt que d'écrire cette définition précise mais chargée, on écrira à la place
une définition en compréhension:

\begin{align*}
\gramdef{Listes}{l}
  {[]}{Liste vide}
  {n::l}{Construction de liste}
  {END}
\end{align*}

Chaque ensemble est identifié de manière unique par les noms de variables
métasyntaxiques: $n$ pour les entiers et $l$ pour les listes ici. Si plusieurs
métavariables du même ensemble doivent apparaître, elles sont indicées. Par
exemple, on peut définir des arbres binaires d'entiers de la manière suivante:

\begin{align*}
\gramdef{Arbres binaires}{a}
              { \textsc{F}              }{Feuille}
              { \textsc{N}(a_1, n, a_2) }{Nœud}
          {END}
\end{align*}

Cette notation a aussi l'avantage de s'étendre facilement aux définitions
mutuellement récursives.

\subsection*{Inférence}

La sémantique opérationnelle consiste en la définition d'une relation de
transition $\cdot\rightarrow\cdot$ entre états de l'interpréteur\footnote{Dans le
chapitre~\ref{cha:typbase}, la relation de typage $\cdot ⊢ \cdot : \cdot$ sera
définie par la même technique.}.

Cette relation est définie inductivement sur la syntaxe du programme. Plutôt que
de présenter l'induction explicitement, elle est représentée par des jugements
logiques et des règles d'inférences, de la forme:

\[
\irule{Nom}{P_1 \\ … \\ P_n}{C}
\]

Les $P_i$ sont les prémisses, et $C$ la conclusion. Cette règle s'interprète de
la manière suivante: si les $P_i$ sont prouvées, alors $C$ est prouvée.

Certaines règles n'ont pas de prémisse, ce sont des axiomes:

\[
\iaxiom{Ax}{A}
\]

Compte-tenu de la structure des règles, la preuve d'un jugement pourra donc être
vue sous la forme d'un arbre:

\[
  \irule{r1}{
    \irule{r2}
          {
            \iaxiom{r3}{A_1}
              \\
            \iaxiom{r4}{A_2}
          }
          {B_1}
    \\
    \irule{r5}
      {
        \iaxiom{r6} {A_3}
      }{B_2}
      }{C}
\]

\subsection*{Listes}

On suppose avoir à notre disposition un ensemble infini dénombrable
d'identificateurs $\sId$ (par exemple des chaînes de caractères).

$X^*$ est l'ensemble des suites finies de $X$, indexées à partir de 1. Si $u ∈
X^*$, on note $|u|$ le nombre d'éléments de $u$ (le cardinal de son ensemble de
définition). Pour $i ∈ [1 ; |u|]$, on note $u_i = u(i)$ le i-ème élément de la
suite.

On peut aussi voir les suites comme des listes: on note $[]$ la suite vide,
telle que $|[]| = 0$. On définit en outre la construction de suite de la manière
suivante: si $x ∈ X$ et $u ∈ X^*$, la liste $x::u ∈ X^*$ est la liste $v$ telle
que:

\begin{align*}
                       v_1 & = x \\
  ∀ i ∈ [1; |u|] , v_{i+1} & = u_i
\end{align*}

\subsection*{Lentilles}

La notion d'accesseur utilisée ici est directement inspirée des \emph{lentilles}
utilisées en programmation fonctionnelle, décrite dans~\cite{PierceLenses}
et~\cite{LaarhovenLenses}.

\begin{definition}[Lentille]

Étant donnés deux ensembles $R$ et $A$, une \emph{lentille} $ℒ ∈ \setLens{R}{A}$
(ou \emph{accesseur}) est un moyen d'accéder en lecture ou en écriture à
sous-valeur de type $A$ au sein d'une valeur de type $R$ (pour \emph{record}).
Elle est consistuée des opérations suivantes:

\begin{itemize}
\item
  une fonction de lecture $\mathrm{get}_ℒ : R → A$
\item
  une fonction de mise à jour $\mathrm{put}_ℒ : (A × R) → R$
\end{itemize}

telles que pour tous $a∈A, a'∈A, r∈R$:

\begin{align*}
\tag{GetPut}
\mathrm{put}_ℒ(\mathrm{get}_ℒ(r), r) &= r \\
\tag{PutGet}
\mathrm{get}_ℒ(\mathrm{put}_ℒ(a, r)) &= a \\
\tag{PutPut}
\mathrm{put}_ℒ(a', \mathrm{put}_ℒ(a, r)) &= \mathrm{put}_ℒ(a', r) \\
\end{align*}

On note $ℒ =
\mkLens{\mathrm{get}_{ℒ}}{\mathrm{put}_{ℒ}}$.

\textsc{GetPut} signifie que si on lit une valeur puis qu'on la réecrit, l'objet
n'est pas modifié; \textsc{PutGet} décrit l'opération inverse: si on écrit
une valeur dans le champ, c'est la valeur qui sera lue; enfin, \textsc{PutPut}
évoque le fait que chaque écriture est totale: quand deux écritures se suivent,
seule la seconde compte.

\end{definition}

Une illustration se trouve dans la figure~\ref{fig:lens-howto}.

\begin{figure}

  \begin{align*}
  \lensGet{ℒ}{\lensNodeBig{green!30}{blue!30}} &= \lensInner{blue!30} \\
  \lensPut{ℒ}{\lensInner{red!30}}{\lensNodeBig{green!30}{blue!30}} &= \lensNodeBig{green!30}{red!30} \\
  \end{align*}

\caption{Fonctionnement d'une lentille}
\label{fig:lens-howto}
\end{figure}

\begin{example}[Lentilles de tête et de queue de liste]

Soit $E$ un ensemble. On considère $L(E)$, l'ensemble des listes d'éléments de
$E$.

On définit les fonctions suivantes. Notons qu'elles ne sont pas définies sur la
liste vide $[]$, qui pourra être traité comme un cas d'erreur.

\begin{align*}
  \mathrm{get}_T     (t::q) &= t \\
  \mathrm{put}_T (t', t::q) &= t'::q \\
  \mathrm{get}_Q     (t::q) &= q \\
  \mathrm{put}_Q (q', t::q) &= t::q' \\
\end{align*}

Alors
$T = \mkLens{\mathrm{get}_T}{\mathrm{put}_T} ∈ \setLens{L(E)}{E}$
et
$Q = \mkLens{\mathrm{get}_Q}{\mathrm{put}_Q} ∈ \setLens{L(E)}{L(E)}$.

On a par exemple:

$\mathrm{get}_T (1::6::1::8::[]) = 1$

et:

$\mathrm{put}_Q (7, 3::6::1::5::[]) = 7::6::1::5::[]$.

\end{example}

\begin{definition}[Lentille indexée]

Les objets de certains ensembles $R$ sont composés de plusieurs sous-objets
accessibles à travers un indice $i ∈ I$. Une lentille indexée est une fonction
$Δ$ qui associe à un indice $i$ une lentille entre $R$ et un de ses champs
$A_i$:

\[
  ∀ i ∈ I, ∃ A_i, Δ(i) ∈ \setLens{R}{A_i}
\]

On note alors:

\begin{align*}
    r {[ i ]}_Δ     & \eqdef \mathrm{get}_{Δ(i)}(r) \\
    r {[ i ← a ]}_Δ & \eqdef \mathrm{put}_{Δ(i)}(a, r) \\
\end{align*}

\end{definition}

Un exemple est illustré dans la figure~\ref{fig:lens-idx-ex}.

\begin{figure}

  \begin{align*}
    \lensGet{Δ(b)}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} &= \lensInnerStar{blue!30} \\
    \lensGet{Δ(c)}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} &= \lensInner{blue!30} \\
    \lensPut{Δ(b)}{\lensInnerStar{red!30}}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} &=
      \lensNodeBigIdx{green!30}{blue!30}{red!30}{blue!30}{blue!30} \\
    \lensPut{Δ(c)}{\lensInner{red!30}}{\lensNodeBigIdx{green!30}{blue!30}{blue!30}{blue!30}{blue!30}} &=
      \lensNodeBigIdx{green!30}{blue!30}{blue!30}{red!30}{blue!30} \\
  \end{align*}

\caption{Fonctionnement d'une lentille indexée}
\label{fig:lens-idx-ex}
\end{figure}

\begin{example}[Lentille ``n\ieme élément d'un tuple'']

Soient $n ∈ ℕ$, et $n$ ensembles $E_1, …, E_n$.

Pour tout $i ∈ [1; n]$, on définit:

\begin{align*}
   g_i((x_1, …, x_n)) &= x_i \\
p_i(y, (x_1, …, x_n)) &= (x_1, …, x_{i-1}, y, x_{i+1}, …, x_n)\\
\end{align*}

Définissons $T(i) = \mkLens{g_i}{p_i}$. Alors $T(i) ∈ \setLens{(E_1×…×E_n)}{E_i}$.

Donc $T$ est une lentille indexée, et on a par exemple:

\begin{align*}
(3,1,4,1,5) {[2]}_T &= \mathrm{get}_{T(2)} ((3, 1, 4, 1, 5)) \\
                    &= 1 \\
\\
(9,2,6,5,3) {[3 ← 1]}_T &= \mathrm{put}_{T(3)} (1, (9,2,6,5,3)) \\
                        &= (9,2,1,5,3)
\end{align*}
\end{example}

\begin{definition}[Composition de lentilles]
\label{def:lens-comp}

  Soient $ℒ_1 ∈ \setLens{A}{B}$ et $ℒ_2 ∈ \setLens{B}{C}$.

  La composition de $ℒ_1$ et $ℒ_2$ est la lentille
  $ℒ ∈ \setLens{A}{C}$ définie de la manière suivante:

  \begin{align*}
    \mathrm{get}_{ℒ} (r) =&
        \mathrm{get}_{ℒ_2}
        (\mathrm{get}_{ℒ_1} r) \\
    \mathrm{put}_{ℒ} (a, r) =&
        \mathrm{put}_{ℒ_1} (\mathrm{put}_{ℒ_2}
        (a, \mathrm{get}_{ℒ_1} r), r) \\
  \end{align*}

  On notera alors $ℒ = ℒ_1 \ggg ℒ_2$.

\end{definition}

\begin{figure}

\centering

\shorthandoff{!}
\begin{tikzpicture}
[node distance=2cm
,bignode/.style={draw,shape=rectangle,minimum size=1cm,fill=green!30}
,smallnode/.style={draw,shape=circle,minimum size=8mm,fill=blue!30}
,trinode/.style={draw,shape=regular polygon,regular polygon sides=3}
]
\node[bignode] (A) {};
\node[right of=A,smallnode] (B) {};
\node[right of=B,trinode,fill=violet] (C) {};
\node[below of=B,smallnode] (D) {};
\node[below of=A,node distance=4cm,bignode] (E) {};

\draw[->] (A) to node[auto] {$\mathrm{get}_{ℒ_1}$} (B);
\draw[->] (B) to (D);
\draw[->] (A) to (E);
\draw (C) |- node[auto,near end,swap] {$\mathrm{put}_{ℒ_2}$} ($(B)!0.5!(D)$);
\draw (D) |- node[auto,near end,swap] {$\mathrm{put}_{ℒ_1}$} ($(A)!0.75!(E)$);

\node[smallnode] at (A) {};
\node[trinode,fill=orange] at (A) {};

\node[trinode,fill=orange] at (B) {};

\node[trinode,fill=violet] at (D) {};

\node[smallnode] at (E) {};
\node[trinode,fill=violet] at (E) {};

\node[left of=A, node distance=4cm,bignode] (GA) {};
\node[below of=GA,smallnode] (GB) {};
\node[below of=GB,trinode,fill=orange] (GC) {};

\node[smallnode] at (GA) {};

\node[trinode, fill=orange] at (GA) {};
\node[trinode, fill=orange] at (GB) {};

\draw [->] (GA) to node[auto] {$\mathrm{get}_{ℒ_1}$} (GB);
\draw [->] (GB) to node[auto] {$\mathrm{get}_{ℒ_2}$} (GC);

\end{tikzpicture}
\shorthandoff{!}

\caption{Composition de lentilles}
\label{fig:compo-lens}
\end{figure}

Cette définition est illustrée dans la figure~\ref{fig:compo-lens}. Une preuve
que la composition est une lentille est donnée en annexe~\ref{proof:compo-lens}.

\section{Fonctionnalités}

\paragraph{Fonctions et procédures:} Un des problèmes classiques dans les
langages impératifs est de distinguer les fonctions (qui retournent une valeur)
et les procédures (qui n'en retournent pas). La solution choisie par C est de
marquer les procédures comme retournant un ``faux'' type \texttt{void}. Mais
c'est uniquement syntaxique: il n'est pas possible de manipuler cette valeur de
retour de type \texttt{void}.

L'autre possibilité, souvent prise dans les langages fonctionnels, est de ne pas
faire de distinction entre ces deux cas et d'interdire les procédures. Les
fonctions ne retournant pas de valeur ``intéressante'' renvoient alors une
valeur d'un type à un seul élément appelé \eUnit\footnote{Cette notation évoque
un $n$-uplet à 0 composante.}, et donc le type sera noté \tUnit.

En C, puisqu'il n'y a pas de valeurs de type \texttt{void}, la notation
\texttt{void *} a un sens particulier: elle désigne les pointeurs de type non
défini, qui sont compatibles avec n'importe quel autre type de pointeur (c'est
la seule forme --- rudimentaire --- de généricité qu'offre le langage). Ici, la
valeur $\eUnit$ est une valeur comme les autres, et on peut constuire un
pointeur de type $\tUnit *$ qui n'aura pas de signification particulière: c'est
seulement un pointeur vers une valeur de type \tUnit.

\paragraph{Tableaux:} ce sont des valeurs composées qui contiennent un certain
nombre de valeurs d'un même type. Par exemple, 100 entiers. On accède à ces
valeurs par un indice entier, qui dans le cas général n'est pas connu à la
compilation. C'est une erreur ($\serr{array}$) d'accéder à un tableau en dehors de
ses bornes, c'est-à-dire en dehors de $[0;n-1]$ pour un tableau à $n$
éléments.

Les tableaux sont notés $\eArray{e_1; …; e_n}$, et le cas dégénéré ($n = 0$) est
interdit.

\paragraph{Structures:} comme les tableaux, ce sont des valeurs composées mais
hétérogènes. Les différents éléments (appelés \emph{champs}) sont désignés par
noms $l$ (pour \emph{label}) et de manière statique (il n'y a pas de mécanisme
pour faire référence à un nom dans le programme).

Les structures sont notées $\eStruct{ l_1 : e_1 ; … ; l_n : e_n }$ et comme dans le
cas des tableaux, le cas dégénéré ($n = 0$) est interdit.

Dans le programme, le nom de champ $l$ est complété de la définition complète de
la structure $S$. Celle-ci n'est pas utilisée dans l'évaluation et sera donc
décrite au chapitre~\ref{cha:typbase}. Bien sûr, écrire la totalité de la
structure dans le code du programme serait fastidieux.

\paragraph{Types de données:} très simples. Entiers machine, flottants,
pointeurs et types composés (structures et tableaux) composés de ceux-ci.

\paragraph{Variables:} elles sont mutables, et on peut passer des données par
valeur ou par pointeur.

\paragraph{Flôt de contrôle:} il repose sur les construction ``if'' et
``while''. Les autres types de boucle (``for'' et ``do/while'') peuvent être
construits avec ces opérateurs.

\paragraph{Fonctions:} le code est organisé en fonctions ``simples'',
c'est-à-dire qui ne sont pas des fermetures. Même si le corps
d'une fonction peut être inclus dans le corps d'une autre, il n'est pas possible
d'accéder aux variables de la portée entourante depuis la fonction intérieure.

\section{Syntaxe}

Les figures~\ref{fig:stx-data},~\ref{fig:stx} et~\ref{fig:stx-ops} présentent
notre langage intermédiaire. Il contient la plupart des fonctionnalités
présentes dans les langages impératifs comme C.

Un programme est organisé en fonctions, qui contiennent des instructions, qui
elles-mêmes manipulent des expressions.

Le flot de contrôle est simplifié par rapport à C:\@ il ne contient que
l'alternative (``if'') et la boucle ``while''. Les autres formes de boucle
(``do/while'' et ``for'') peuvent être émulées par une boucle ``while''.

Les fonctionnalités manquantes, et comment les émuler, seront discutés dans le
chapitre~\ref{cha:conclusion}.

Pour l'alternative, on introduit également la forme courte $\iThen{e}{i} =
\iIf{e}{i}{\iPass}$.

Les opérateurs sont donnés dans la figure~\ref{fig:stx-ops}.

\begin{figure}

  \begin{align*}
  \gramdef{Constantes}{c}
                 { n      }{ Entier }
                 { d      }{ Flottant }
                 { \eNull }{ Pointeur nul }
                 { \eUnit }{ Valeur unité }
                 {END}
  \\
  \\
  \gramdef{Expressions}{e}
                 { c               }{ Constante }
                 { lv              }{ Accès mémoire }
                 { \opun~e         }{ Opération unaire }
                 { e~\opbin~e      }{ Opération binaire }
                 { \& lv           }{ Pointeur }
                 { lv ← e          }{ Affectation }
                 { \eStruct{
                    l_1 : e_1
                    ; …
                    ; l_n : e_n }  }{ Structure }
                 { \eArray{e_1 ;…; e_n} }{ Tableau }
                 { f               }{ Fonction }
                 { e (e_1, …, e_n) }{ Appel de fonction }
                 {END}
  \\
  \\
  \gramdef{Left-values}{lv}
                  { x      }{ Variable }
                  { *lv    }{ Déréférencement }
                  { lv.l_S }{ Accès à un champ }
                  { lv[e]  }{ Accès à un élément }
                  {END}
  \\
  \\
  \gramdef{Fonctions}{f}
                 { \eFun{x_1, …, x_n}{i} }{Arguments, corps}
                 {END}
  \end{align*}

  \caption{Syntaxe des expressions}
\label{fig:stx-data}
\end{figure}

\begin{figure}

  \begin{align*}
  \gramdef{Instructions}{i}
                 { \iPass          }{Instruction vide}
                 { i;i             }{Séquence}
                 { e               }{Expression}
                 { \iDecl{x}{e}{i} }{Déclaration de variable}
                 { \iIf{e}{i}{i}   }{Alternative}
                 { \iWhile{e}{i}   }{Boucle}
                 { \iReturn{e}     }{Retour de fonction}
                 {END}
  \\
  \\
  \gramdef{Phrases}{p}
                 { x = e }{Variable globale}
                 { e     }{Évaluation d'expression}
                 {END}
  \\
  \\
  \gramdef{Programme}{P}
                 { (p_1, …, p_n)}{Phrases}
                 {END}
  \end{align*}

  \caption{Syntaxe des instructions}
\label{fig:stx}
\end{figure}

\begin{figure}

  \begin{align*}
  \gramdef{Opérateurs binaires}{\opbin}
      { +,-,\times,/,\% }{Arithmétique entière}
      { +.,-.,\times.,/.}{Arithmétique flottante}
      { +_p, -_p        }{Arithmétique de pointeurs}
      { =,≠,≤,≥,<,>     }{Comparaisons}
      { \&,|,\opxor     }{Opérateurs bit à bit}
      { \&\&,||         }{Opérateurs logiques}
      { \ll, \gg        }{Décalages}
      {END}
  \\
  \\
  \gramdef{Opérateurs unaires}{\opun}
      { +,-   }{Arithmétique entière}
      { +.,-. }{Arithmétique flottante}
      { \sim  }{Négation bit à bit}
      { !     }{Négation logique}
      {END}
  \end{align*}

  \caption{Syntaxe des opérateurs}
\label{fig:stx-ops}
\end{figure}

\section{Mémoire et valeurs}

L'interprète que nous nous apprêtons à définir manipule des valeurs qui sont
associées aux variables du programme.

La mémoire est constituée de variables, qui contiennent des valeurs. Ces
variables sont organisées, d'une part en un ensemble de variables globales, et
d'autre part en une pile de contextes d'appel (qu'on appellera donc
aussi cadres de pile, ou \emph{stack frames} en anglais). Cette structure
empilée permet de représenter les différents contextes à chaque appel de
fonction: par exemple, si une fonction s'appelle récursivement, plusieurs
instances de ses variables locales sont présentes dans le programme.

La structure de pile des locales permet de les organiser en niveaux
indépendants: à chaque appel de fonction, un nouveau cadre de pile est créé,
comprenant ses paramètres et ses variables locales. Au contraire, pour les
globales il n'y a pas de système d'empilement, puisque ces variables sont
accessibles depuis tout point du programme.

Pour identifier de manière non ambigüe une variable, on note simplement $x$ la
variable globale nommée $x$, et $(n, x)$ la variable locale nommée $x$ dans le
$n$\ieme cadre de pile\footnote{Les paramètres de fonction sont traités comme
des variables locales et se retrouvent dans le cadre correspondant.}.

Les affectations peuvent avoir la forme $x ← e$ où $x$ est une variable et $e$
est une expression, mais pas seulement. En effet, à gauche de $←$ on trouve en
général non pas une variable mais une left-value. Pour représenter quelle partie
de la mémoire doit être accédée par cette left-value, on introduit la notion de
chemin $φ$. Un chemin est en quelque sorte une left-value symbolique évaluée:
les cas sont similaires, sauf que tous les indices sont évalués. Par exemple, $φ
= (5, x).p$ représente le champ ``$p$'' de la variable $x$ dans le 5\ieme cadre
de pile. C'est à ce moment qu'on évalue les déréférencements qui peuvent
apparaître dans une left-value.

Les valeurs, quant à elles, peuvent avoir les formes suivantes (résumé sur la
figure~\ref{fig:interp-val}):

\begin{itemize}
\item

$\widehat{c}$: une constante. La notation circonflexe permet de distinguer
les constructions syntaxique des constructions sémantiques. Par exemple, à la
syntaxe $3$ correspond la valeur $\widehat{3}$.

Les valeurs entières sont les entiers signés sur 32 bits, c'est-à-dire entre
$-2^{31}$ à $2^{31}-1$. Mais ce choix est arbitraire: de la même manière, on
aurait pu choisir des nombres à 64 bits ou même de précision arbitraire.
Les flottants sont les flottants IEEE 754 de 32 bits~\cite{ieee754}.

\item

$φ$: une référence mémoire. Ce chemin correspond à un pointeur sur une
left-value. Par exemple, l'expression $\&x$ s'évalue en $φ = (5, x)$ si $x$
désigne lexicalement une variable dans le 5\ieme cadre de pile.

\item

$\widehat{ \eStruct{ l_1 : v_1 ; … ; l_n : v_n } }$: une structure. Comme
précédemment, on note $\widehat{\eStruct{\cdot}}$ pour dénoter les valeurs.

\item

$\widehat{ \eArray{v_1 ;…; v_n} }$: un tableau. Pareillement, $\widehat{\eArray{\cdot}}$
permet de désigner les valeurs. Par exemple, si $x$ vaut $2$ et $y$ vaut $3$,
l'expression $\eArray{ x, y }$ s'évaluera en valeur $\widehat{\eArray{ 2, 3 }}$

\item

$\widehat{f}$: une fonction. Les valeurs fonctions comportent l'intégralité de
la définition de la fonction (liste de paramètres, de variables locales et
corps). Remarquons que contrairement à certains langages, l'environnement n'est
pas capturé (il n'y a pas de clôture lexicale).

\item $Ω$: une erreur. Par exemple le résultat de $5 / 0$ est $\serr{div}$.

\end{itemize}

\begin{figure}%{{{

  \begin{align*}
  \gramdef{Valeurs}{v}
      { \widehat{c}     }{Constante}
      { \widehat{\&}~φ  }{Référence mémoire}
      { \widehat{
         \eStruct{ l_1 : v_1 ;
       … ; l_n : v_n }
       }                }{Structure}
      { \widehat{
        \eArray{v_1 ;…; v_n}
        }               }{Tableau}
      { \widehat{f}     }{Fonction}
      { Ω               }{Erreur}
      {END}
  \\
  \\
  \gramdef{Chemins}{φ}
     { a    }{Adresse}
     { φ\widehat{.}l  }{Accès à un champ}
     { φ\widehat{[n]} }{Accès à un élément}
     {END}
  \\
  \\
  \gramdef{Adresses}{a}
     { (n, x) }{Variable locale}
     { (x)    }{Variable globale}
     {END}
  \\
  \\
  \gramdef{Erreur}{Ω}
    { \serr{array} }{Débordement de tableau}
    { \serr{ptr}   }{Erreur de pointeur}
    { \serr{div}   }{Division par zéro}
    { \serr{field} }{Erreur de champ}
    { \serr{var}   }{Variable inconnue}
    {END}
  \end{align*}

  \caption{Valeurs}
\label{fig:interp-val}
\end{figure}%}}}

Les erreurs peuvent être de plusieurs types:

\begin{itemize}

\item $\serr{div}$ correspond à une division par zéro. Cela arrive si la seconde
opérande de $/$, $\%$ ou $\floatop{/}$ est nulle.

\item $\serr{array}$ signale un débordement de tableau.

\item $\serr{ptr}$ signale une manipulation ou un déréférencement de pointeur
invalide. Par exemple, déréférencer le pointeur nul ou appliquer l'arithmétique
en dehors d'un tableau provoque cette erreur.

\item $\serr{field}$ arrive lorsqu'on accède à un champ inexistant d'une
structure. Ce cas sera entièrement évité grâce au typage dans le
chapitre~\ref{cha:typbase}.

\item $\serr{var}$ se produit lorsqu'on accède à une variable qui n'est pas
visible dans un état mémoire. Ce cas est également évité dans les programmes
bien typés.

\end{itemize}

La figure~\ref{fig:interp-stack} résume comment ces valeurs sont organisées. Une
pile est une liste de cadre de piles, et un cadre de pile est une liste de
couples (nom, valeur). Un état mémoire $m$ est un couple $(s, g)$ où $s$ est une
pile et $g$ un cadre de pile (qui représente les variables globales).
On note $|m| = |s|$ la hauteur de la pile (en nombre de cadres).

Enfin, l'interprétation est définie comme une relation $\cdot → \cdot$ entre
états $Ξ$; ces états sont d'une des formes suivantes:

\begin{itemize}
\item
  un couple $\msi{m}{e}$ où $e$ est une expression et $m$ un état
  mémoire. $m$ est l'état mémoire sous lequel l'évaluation sera
  réalisée. Par exemple $\mm{([], [x↦3])}{3}{([], [x↦3])}{\widehat{3}}$
  L'évaluation des expressions est détaillée dans la
  section~\ref{sec:eval-exp}.
\item
  un couple $\msi{m}{i}$ où $i$ est une instruction et $m$ un état
  mémoire. La réduction des instructions est traitée dans la
  section~\ref{sec:eval-instr}.
\item
  un couple $\msi{m}{lv}$ où $lv$ est une left-value et $m$ un état mémoire.
  L'évaluation des left-values est décrite en section~\ref{sec:eval-lv}.
\item
  une erreur $Ω$. La propagation des erreurs est détaillée dans la
  section~\ref{sec:eval-errors}.
\end{itemize}

L'évaluation des expressions, left-values et instruction se fait à petits pas.
C'est-à-dire qu'on simplifie d'étape en étape leur forme, jusqu'à arriver à un
cas de base:

\begin{itemize}
\item pour les expressions, une valeur $v$.
\item pour les instructions, l'instruction $\iPass$ ou $\iReturn{v}$ où $v$ est
    une valeur.
\item pour les left-values, un chemin $φ$.
\end{itemize}

On considère en fait la clôture transitive de cette relation. Cela revient à
ajouter une règle :

\begin{mathpar}
    \irule{Trans}
        { Ξ_1 → Ξ_2
       \\ Ξ_2 → Ξ_3
        }
        { Ξ_1 → Ξ_3}
\end{mathpar}

\begin{figure}%{{{

  \begin{align*}
  \gramdef{Pile}{s}
    { [] }{Pile vide}
    { \{ x_1 ↦v_1; … ; x_n ↦v_n\} :: s }{Ajout d'un cadre}
    {END}
  \\
  \\
  \gramdef{État mémoire}{m}
    { (s, \{ x_1 ↦v_1; … ; x_n ↦v_n\})}{Pile, globales}
    {END}
  \\
  \\
  \gramdef{État d'interpréteur}{Ξ}
    { \msi{m}{e} }{Expression, mémoire}
    { \msi{m}{i} }{Instruction, mémoire}
    { Ω          }{Erreur}
    {END}
  \end{align*}

  \caption{Composantes d'un état mémoire}
\label{fig:interp-stack}
\end{figure}%}}}

\section{Opérations sur les valeurs}
\label{sec:sem-ops}

Un certain nombre d'opérations est possibles sur les valeurs
(figure~\ref{fig:stx-ops}):

\begin{itemize}
\item
  les opérations arithmétiques $+$, $-$, $×$, $/$ et $\%$ sur les entiers.
  L'opérateur $\%$ correspond au modulo (reste de la division euclidienne).
  En cas de division par zéro, l'erreur $\serr{div}$ est levée.
\item
  les versions ``pointées''
  $\floatop{+}$,
  $\floatop{-}$,
  $\floatop{×}$
  et
  $\floatop{/}$
  sur les flottants
\item
  les opérations d'arithmétique de pointeur $+_p$ et $-_p$ qui à un chemin
  mémoire et un entier associent un chemin mémoire.
\item
  les opérations d'égalité $=$ et $≠$. L'égalité entre entiers ou entre
  flottants est immédiate. Deux valeurs composées (tableaux ou structures) sont
  égales si elles ont la meme ``forme'' (même taille pour les tableaux, et même
  champs pour les structures) et que toutes leurs sous-valeurs sont égales deux
  à deux. Les références mémoire $φ$ sont égales lorsque les chemins qu'ils
  décrivent sont syntaxiquement égaux\footnote{
    Il est donc possible que deux pointeurs pointent sur la même adresse mais
    soient considérés différents. La raison pour ce choix est que la comparaison
    doit pouvoir se faire sans accéder à la mémoire.
  }.
\item
  les opérations de comparaison $≤,≥,<,>$ sont définies avec leur sémantique
  habituelle sur les entiers et les flottants. Sur les références mémoires,
  elles sont définies dans le cas où les deux opérarandes sont de la forme
  $φ[\cdot]$ par: $φ[n]~\opbin~φ[m] \eqdef n~\opbin~m$. Dans les autres cas,
  l'erreur $\serr{ptr}$ est renvoyée.
\item
  les opérateurs bit à bit sont définis sur les entiers. $\&$, $|$ et $\opxor$
  représentent respectivement la conjonction, la disjonction et la disjonction
  exclusive (XOR).
\item
  des versions logiques de la conjonction ($\&\&$) et de la disjonction ($||$)
  sont également présentes. Leur sémantique est donnée par le tableau suivant:

  \begin{center}
    \begin{tabular}{rr@{\hskip 1cm}cc}
       $n$ &  $m$ & $n~\&\&~m$ & $n~||~m$ \\
      \midrule
       $0$ &  $0$ & $0$        & $0$      \\
       $0$ & $≠0$ & $0$        & $1$      \\
      $≠0$ &  $0$ & $0$        & $1$      \\
      $≠0$ & $≠0$ & $1$        & $1$      \\
    \end{tabular}
  \end{center}

\item
  des opérateurs de décalage à gauche ($\ll$) et à droite ($\gg$) sont présents.
  Eux aussi ne s'appliquent qu'aux entiers.

\item
  les opérateurs arithmétiques unaires $+$, $-$, $\floatop{+}$ et $\floatop{-}$
  sont équivalents à l'opération binaire correspondante avec $0$ ou $0.0$ comme
  première opérande.

\item
  $\sim$ inverse tous les bits de son opérande.
  $!$ est une version logique, % chktex 40
  c'est-à-dire que $!0 = 1$ et si $n ≠ 0$, $!n = 0$.
\end{itemize}

% TODO que se passe-t-il dans les autres cas? introduire un \serr{typ}?

\section{Opérations sur les états mémoire}
\label{sec:memops}

% TODO faire un blabla similaire sur les instructions

\begin{definition}[Recherche de variable]

  La recherche de variable permet d'associer à une variable $x$ une adresse $a$.

  Chaque fonction peut accéder aux variables locales de la fonction en cours,
  ainsi qu'aux variables globales.

\[
  \cLookup{(s, g)}{x} =
        \begin{cases}
            (|s|, x) & \mbox{ si } |s| > 0
                       \mbox{ et } (x ↦ v) ∈ s_1 \\
            x        & \mbox{ si } (x ↦ v) ∈ g \\
            \serr{var} & \mbox{ sinon }
        \end{cases}
\]

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. En retournant à
l'appelant, il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  On définit l'empilement d'un cadre de pile $c = ((x_1↦ v_1), …, (x_n↦ v_n))$
  sur un état mémoire $m = (s, g)$ (figure~\ref{fig:stackops-push}):

  \[
      \cPush{(s, g)}{c} = (c::s, g)
  \]

  On définit aussi l'extension du dernier cadre de pile
  (figure~\ref{fig:stackops-extend}):

  \[
    \cExtend{(c::s, g)}{x}{v} = (((x↦v :: c) :: s), g)
  \]

  De même on définit le dépilement (figure~\ref{fig:stackops-pop}):

  \[
      \cPop{(c::s, g)} = (s, g)
  \]

\end{definition}

\begin{definition}[Hauteur d'une valeur]
La hauteur d'une valeur est l'indice du plus haut cadre qu'elle référence, ou
$-1$ sinon.

\begin{align*}
    \cH{\widehat{c}} &= -1 \\
    \cH{\widehat{f}} &= -1 \\
    \cH{\widehat{\&}~φ} &= \cHphi{φ} \\
    \cH{\widehat{\eStruct{l_1:v_1;…;l_n:v_n}}} &= \max_{i∈[1;n]} \cH{v_i} \\
    \cH{\widehat{\eArray{v_1,…,v_n}}} &= \max_{i∈[1;n]} \cH{v_i}
\end{align*}

où:

\begin{align*}
    \cHphi{(x)} &= -1 \\
    \cHphi{(n,x)} &= n \\
    \cHphi{φ\widehat{.}l} &= \cHphi{φ} \\
    \cHphi{φ\widehat{[n]}} &= \cHphi{φ}
\end{align*}

\end{definition}


Les opérations $\mathrm{Extend}$ et $\mathrm{Pop}$ ne sont définies que pour une
pile non vides. Néanmoins cela ne pose pas de problème, puisque lors de
l'éxecution, la pile n'est vide que lors de l'évaluation d'expressions dans les
phrases de programme. À cet endroit, seules des expressions peuvent apparaître,
et leur évaluation ne manipule jamais la pile avec ces opérations.

\begin{figure}%{{{

  \centering

  \subbottom[Empilement]{
\label{fig:stackops-push}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (8,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;
    \path (12,0)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;
    \draw [->] (9.2, 1) -- node[auto] {$\cPush{\cdot}{(x ↦ 0)}$} ++(1.6, 0);
  \end{tikzpicture}
  }

  \subbottom[Extension de cadre]{
\label{fig:stackops-extend}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (4,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;
    \path (8,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0, y↦3$}
    ;
    \draw [->] (5.2, -2) -- node[auto] {$\cExtend{\cdot}{y}{3}$} ++(1.6, 0);
  \end{tikzpicture}
  }

  \subbottom[Dépilement]{
\label{fig:stackops-pop}
  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]
    \path (0,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$…$}
    ;
    \path (4,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;
    \draw [->] (1.2, 1) -- node[auto] {Pop} ++(1.6, 0);
  \end{tikzpicture}
  }

  \caption{Opérations de pile}
\label{fig:stackops}
\end{figure}%}}}

On définit aussi une opération de nettoyage de pile, qui sera utile pour les
retours de fonction.

En effet, si une référence au dernier cadre est toujours présente après
le retour, elle pourra se résoudre en un objet différent plus tard dans
l'exécution du programme.

La fonction $\mathrm{Cleanup}$ est donnée par:

\begin{align*}
      \mathrm{Cleanup}((s, g)) &= (s', g') \\
                 \mbox{où } s' &= (\cL{|s|}{s_1}, …, \cL{|s|}{s_|s|}) \\
                            g' &= \cL{|s|}{g} \\
\cL{p}{(x_1 ↦ v_1, …, x_n ↦ v_n)} &= (x_1 ↦ \cV{v_1}, …, x_n ↦ \cV{v_n}) \\
\cV{p}{\widehat{\&}~φ} &= \begin{cases}
                              \eNull         & \mbox{ si } \cH{φ} > p \\
                              \widehat{\&}~φ & \mbox{ sinon}
                           \end{cases} \\
\cV{p}{v} &= v \mbox{ sinon}
\end{align*}

Sans cette règle, examinons le programme suivant:

\begin{Verbatim}
f ()                g (p)           h ()
  (x=0)               (x=0.0)         (p=f())
{                   {               {
  return (&x);        *p = 1;         g(p);
}                   }               }
\end{Verbatim}

L'exécution de $h()$ donne à $p$ la valeur $(1, x)$. Donc en arrivant dans $g$, le
déréférencement de $p$ va modifier $x$.

\begin{figure}%{{{
  \centering


  \begin{tikzpicture}
    [ stack/.style={draw,minimum height=5mm,minimum width=3cm ,shape=rectangle}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    , substack/.style={draw, minimum height=5mm, }
    , oldstack/.style={loosely dashed}
    , fixmatrix/.style={matrix, row sep=-\pgflinewidth, column sep=-\pgflinewidth}
    , >=stealth'
    ]

    \path (0, 0)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p) { }; & \node { }; & \node (q) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x) { }; & \node (y) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, 0) {
          \node (r) { }; & \node { }; \\
      };

      \draw[->] (p.center) -- ++(0, 0.5);
      \draw[->] (q.center) -| ($ (r.center) - (3mm, 0) $);
      \draw[->] ($ (r.center) + (3mm, 0) $) |- (y.center);

      %%%%%

    \path (0, -3)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p2) { }; & \node { }; & \node (q2) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x2) { }; & \node (y2) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, -3) {
          \node (r2) { }; & \node { }; \\
      };

      \draw[->] (q2.center) -| ($ (r2.center) - (3mm, 0) $);

      \def\crossat#1{
        \draw ($ #1 + (2mm, 2mm) $) -- ++ (-4mm, -4mm);
        \draw ($ #1 + (-2mm, 2mm) $) -- ++ (4mm, -4mm);
      }

      \crossat{(r2.center) + (3mm, 0)}
      \crossat{(p2.center)}

  \end{tikzpicture}

  \caption{Nettoyage d'un cadre de pile}
\label{fig:stackcleanup}
\end{figure}%}}}

\section{Accesseurs}
\label{sec:mem-access}

On définit ici quelques lentilles. Le but est de définir rigoureusement les
accès à la mémoire. À partir d'un état mémoire $m$ et d'une left-value $φ$, on
veut pouvoir obtenir:

\begin{itemize}
    \item la valeur accessible au chemin $φ$: $m[φ]_Φ$
    \item l'état mémoire obtenu en remplaçant celle-ci par une nouvelle valeur $v'$ :
            $m[φ ← v']_Φ$
\end{itemize}

Pour définir cette lentille indexée $Φ$, on commence par définir des lentilles
élémentaires, et on les compose pour pouvoir définir des lentilles entre
valeurs.

\subsection*{Accès à une liste par indice : $I$}

On définit une lentille indexée $I : ℕ → \setLens{\textrm{List}(α)}{α}$
permettant d'accéder aux éléments d'une liste par leur indice.

\begin{align*}
    l{[n]}_I     &= l_n \mbox{ si } n ∈ [1; |l|] \\
    l{[n ← x]}_I &= l' \\
           \mbox{ où } & l'_n = x \\
                       & ∀ i ≠ n, l'_i = l_i
\end{align*}

I n'est définie que pour $n ∈ [1 ;|l|]$.

\subsection*{Accès à une liste d'associations : $L$}

  Une liste d'association est une liste de paires (clef, valeur) avec
  l'invariant supplémentaire que les clefs sont uniques. Il est donc possible de
  trouver au plus une valeur associée à une clef donnée. L'écriture est
  également possible, en remplaçant un couple par un couple avec une valeur
  différente.

\begin{align*}
l{[x]}_L  &=
    \begin{cases}
        v          & \mbox{ si } ∃! n ∈ [1;|l|]. ∃v. l_n = (x ↦ v) \\
        \serr{var} & \mbox{ sinon }
    \end{cases} \\
l{[x ← v]}_L  &=
    \begin{cases}
        l{[n ← (x ↦ v)]}_I & \mbox{ si } ∃! n ∈ [1;|l|]. ∃v_0. l_n = (x ↦ v_0) \\
        \serr{var} & \mbox{ sinon }
    \end{cases} \\
\end{align*}

\subsection*{Accès par adresse : $A$}

Les états mémoire sont constitués des listes d'association (nom, valeur).

L'accesseur par adresse ${[\cdot]}_A$ permet de généraliser l'accès à ces
valeurs en utilisant comme clef non pas un nom mais une adresse.

Selon cette adresse, on accède soit à la liste des globales, soit à une
des listes de la pile des locales.

On pose $m = (s, g)$.

Les accès aux globales se font de la manière suivante. Si la variable n'existe
pas, notons que $L$ retourne $\serr{var}$.

\begin{align*}
m {[x]}_A     &= g{[x]}_L \\
m {[x ← v]}_A &= (s, g{[x←v]}_L) \\
\end{align*}

Les accès aux locales reviennent à accéder à la bonne variable du bon cadre de
pile. Cela revient naturellement à composer les lentilles $L$ et $I$. On définit
donc une lentille $ℒ_{n,x} = I(|s|-n+1) \ggg L(x)$ qui accède à la variable $x$
du $n$\ieme cadre de pile.

\begin{align*}
m {[(n, x)]}_A     & = \begin{cases}
                           \lensGet{ℒ_{n,x}}{s} & \mbox{ si $n ∈ [1 ; |s|]$} \\
                           \serr{var}          & \mbox{ sinon}
                       \end{cases} \\
m {[(n, x) ← v]}_A & = \begin{cases}
                            (\lensPut{ℒ_{n,x}}{v}{s}, g) & \mbox{ si $n ∈ [1;|s|]$} \\
                            \serr{var}          & \mbox{ sinon}
                       \end{cases} \\
\end{align*}

Les numéros de cadre qui permettent d'identifier les locales (le $n$ dans $(n,
x)$) croissent avec la pile. D'autre part, l'empilement se fait en tête de liste
(près de l'indice 1). Donc pour accéder aux plus vieilles locales (numérotées
1), il faut accéder au dernier élément de la liste. Ceci explique pourquoi un
indice $|s|-n+1$ apparaît dans la définition précédente.

\subsection*{Accès par champ : $F$}

  Les valeurs qui sont des structures possèdent des sous-valeurs, associées à
  des noms de champ.

  L'accesseur ${[ \cdot ]}_F$ permet de lire et de modifier un champ de ces
  valeurs.

  L'erreur $\serr{field}$ est levée si on accède à un champ non existant.

  \begin{align*}
    \eStruct{ l_1 : v_1; … ; l_n : v_n }{[l]}_F &= v_i \mbox{ si } ∃i∈[1;n], l=l_i\\
    \eStruct{ l_1 : v_1; … ; l_n : v_n }{[l ← v]}_F &=
        \eStruct{ l_1 : v_1 \\
           &\quad ; … \\
           &\quad ; l_{p-1} : v_{p-1} \\
           &\quad ; l_p : v \\
           &\quad ; l_{p+1} : v_{p+1} \\
           &\quad ; … \\
           &\quad ; l_n : v_n } \mbox{ si } ∃p ∈ [1;n], l = l_p \\
    \eStruct{ l_1 : v_1; … ; l_n : v_n }{[l]}_F     &= \serr{field} \mbox{ sinon} \\
    \eStruct{ l_1 : v_1; … ; l_n : v_n }{[l ← v]}_F &= \serr{field} \mbox{ sinon}
  \end{align*}

\subsection*{Accès par indice de tableau : $T$}

  On définit de même un accesseur ${[\cdot]}_T$ pour les accès par indice à des
  valeurs tableaux. Néanmoins le paramètre indice est toujours un entier et pas
  une expression arbitraire.

  \begin{align*}
    \eArray{ v_1 ; … ; v_n } {[i]}_T   &= v_{i+1} \textrm{ si } i ∈ [0;n-1] \\
    \eArray{ v_1 ; … ; v_n } {[i]}_T   &= \serr{array} \textrm{ sinon} \\
    \eArray{ v_1 ; … ; v_n } {[i←v]}_T &= \eArray{ v'_1 ; … ; v'_n } \textrm{ si } i ∈ [0;n-1] \\
                      \mbox{ où } & \begin{cases}
                                      v'_i = v \\
                                      ∀j≠i, v'_j = v_j \\
                                    \end{cases} \\
    \eArray{ v_1 ; … ; v_n } {[i←v]}_T &= \serr{array} \textrm{ sinon} \\
  \end{align*}

  % TODO off by ones...

\subsection*{Accès par chemin : $Φ$}
\label{subsec:acces-phi}

  L'accès par chemin $Φ$ permet de lire et de modifier la mémoire en profondeur.

  On peut accéder directement à une variable:

  \begin{align*}
    Φ(a) &= A(a) \\
  \end{align*}

  Les accès à des sous-valeurs se font en composant les accesseurs
  (définition~\ref{def:lens-comp}):

  \begin{align*}
    Φ(φ.l)  &= Φ(φ) \ggg F(l) \\
    Φ(φ[i]) &= Φ(φ) \ggg T(i) \\
  \end{align*}

  Enfin, l'accès à la mémoire par le pointeur nul provoque une erreur:

  \begin{align*}
    m{[\eNull    ]}_Φ &= \serr{ptr} \\
    m{[\eNull ← v]}_Φ &= \serr{ptr} \\
  \end{align*}

Cette dernière définition mérite une explication. Dans le cas de la lecture, il
suffit d'appliquer les bons accesseurs: ${[\cdot]}_F$ pour $φ.l_S$, etc.

En revanche, la modification est plus complexe. Le premier cas ($φ = a$) modifie
directement une valeur complète (en modifiant une association), mais les deux
suivants ($φ = φ'.l$ et $φ = φ'[i]$) ne font qu'altérer une sous-valeur
existante. Il est donc nécessaire de procéder en 3 étapes:

\begin{itemize}
\item obtenir la valeur à modifier (soit $m{[φ]}_Φ$)
\item construitre une valeur altérée (en appliquant par exemple ${[l←v]}_F$)
\item affecter cette valeur au même chemin (le $m{[φ ← …]}_Φ$ externe)
\end{itemize}

\section{Contextes d'évaluation}

L'évaluation des expressions repose sur la notion de contextes d'évaluation.
L'idée est que si on peut évaluer une expression, alors on peut évaluer une
expression qui contient celle-ci.

Par exemple, supposons que $\mm{m}{f(3)}{m}{2}$. Alors on peut ajouter la
constante $1$ à gauche de chaque expression sans changer le résultat:
$\mm{m}{1+f(3)}{m}{1+2}$. On a utilisé le même contexte
$C = 1+\ctxEmpty$.

Pour pouvoir raisonner en termes de contextes, 3 points sont nécessaires:

\begin{itemize}
\item comment découper une expression selon un contexte
\item comment appliquer une règle d'évaluation sous un contexte
\item comment regrouper une expression et un contexte
\end{itemize}

\begin{figure}
\figctx{}

\caption{Contextes d'évaluation}
\label{fig:eval-ctx}
\end{figure}

Le premier point consiste à définir les contextes eux-mêmes
(figure~\ref{fig:eval-ctx}).

Le deuxième est résolu par la règle d'inférence suivante.

\begin{mathpar}
  \semrule{Ctx}
\end{mathpar}

Enfin, le troisième revient à définit l'opérateur de substitution
$\phxx{\ctxSub}$ présent dans la règle précédente. Afin de pouvoir appliquer des
substitution au niveau des left-values et des instructions, on définit aussi
respectivement $\phxx{\ctxSubL}$ et $\phxx{\ctxSubI}$.

Notons que puisque $i \gramisa e$ et $e \gramisa lv$, on peut aussi l'appliquer
aux expressions et aux left-values: l'opération $\phxx\ctxSub$ est purement
syntaxique.

Dans la définition de l'ensemble des contextes, chaque cas hormis le cas de base
fait apparaître exactement un ``$C$''. Chaque contexte est donc constitué
d'exactement un ``trou'' $\ctxEmpty$ (une dérivation de $C$ est toujours
linéaire). L'opération de substitution consiste à remplacer ce trou:
$\ctxSub{C}{X}$ est l'objet syntaxique (instruction, expression ou left-value)
obtenu en remplaçant l'unique $\ctxEmpty$ dans $C$ par $X$. Par exemple,
$\ctxSub{\iDecl{x}{2+\ctxEmpty}}{5} = \iDecl{x}{2+5}$

À titre d'illustration, décomposons l'évaluation de $e_1~\opbin~e_2$ en $v =
v_1~\widehat{\opbin}~v_2$ depuis un état mémoire $m$:

\begin{enumerate}
\item
  on commence par évaluer, d'une manière ou d'une autre, l'expression
  $e_1$ en une valeur $v_1$. Le nouvel état mémoire est noté $m'$. Soit
  donc $\mm{m}{e_1}{m'}{v_1}$.
\item
  En appliquant la règle \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$ (qui est
  une des formes possibles pour un contexte d'évaluation), on déduit de 1.\ que
  $\mm{m}{e_1~\opbin~e_2}{m'}{v_1~\opbin~e_2}$
\item
  D'autre part, on évalue $e_2$ depuis $m'$. En supposant encore que
  l'évaluation converge, notons $v_2$ la valeur calculée et $m''$ l'état mémoire
  résultant: $\mm{m'}{e_2}{m''}{v_2}$.
\item
  Appliquons la règle~\textsc{Ctx} à 3.\ avec $C = \ctxOp{v_1}{\ctxEmpty}$. On
  obtient $\mm{m}{v_1~\opbin~e_2}{m'}{v_1~\opbin~v_2}$.
\item
  En combinant les résultats de 2.\ et 4.\ on en déduit que
  $\mm{m}{e_1~\opbin~e_2}{m''}{v_1\opbin~v_2}$.
\item D'après la règle~\textsc{Exp-Binop},
  $ \mm{m''}{v_1\opbin~v_2}{m''}{v_1~\widehat{\opbin}~v_2}$
\item D'après 5.\ et 6., on a par combinaison
  $\mm{m}{e_1~\opbin~e_2}{m''}{v}$
  en posant
  $v = v_1~\widehat{\opbin}~v_2$.
\end{enumerate}

\section{Left-values}
\label{sec:eval-lv}

\begin{figure}

  \centering

  \begin{tikzpicture}
    \node              (a1) {$x$};
    \node[right of=a1] (a2) {$.l_S$};
    \node[right of=a2] (a3) {$[2*n]$};
    \node[right of=a3] (a4) {$.g$};

    \node[below of=a1] (b1) {$(2, x)$};
    \node[below of=a2] (b2) {$.l$};
    \node[below of=a3] (b3) {$[4]$};
    \node[below of=a4] (b4) {$.g$};

    \draw[->] (a1) -- (b1);
    \draw[->] (a2) -- (b2);
    \draw[->] (a3) -- (b3);
    \draw[->] (a4) -- (b4);
  \end{tikzpicture}

  \caption{Évaluation des left-values.}
\label{fig:eval-lv}
\end{figure}

Obtenir un chemin à partir d'un nom de variable revient à résoudre le nom de
cette variable: est-elle accessible? Le nom désigne-t-il une variable locale
ou une variable globale?

\begin{mathpar}
  \semrule{Phi-Var}
\end{mathpar}

Les règles portant sur le déréférencement et l'accès à un champ de structure
sont similaires: on commence par évaluer la left-value sur laquelle porte ce
modificateur, et on place le même modificateur sur le chemin résultant. Dans le
cas des champs de structure, la définition de la structure $S$ n'est pas prise
en compte.

\begin{mathpar}
  \semrule{Phi-Struct}
\end{mathpar}

Enfin, pour évaluer un chemin dans un tableau, on commence par procéder comme
précédemment, c'est-à-dire en évaluant la left-value sur laquelle porte
l'opération d'indexation. Puis on évalue l'expression d'indice en une valeur qui
permet de construire le chemin résultant.

\begin{mathpar}
  \semrule{Phi-Array}
\end{mathpar}

Notons qu'en procédant ainsi, on évalue les left-values de gauche à droite:
dans l'expression $x[e_1][e_2][e_3]$, $e_1$ est évalué en premier, puis
$e_2$, puis $e_3$.

La règle portant sur le déréférencement est particulière. On peut penser que la
bonne définition de $φ$ consiste à se calquer sur la définition de $lv$, en
remplaçant les noms de variable par leur adresse résolue et en évaluant les
indices de tableau, et à ajouter une règle qui transforme $*φ$ en
$\widehat{*}φ$.

Cela ne fonctionne pas, car alors les déréférencements sont évalués trop tard:
au moment de l'affectation dans la left-value plutôt qu'à sa définition. La
figure~\ref{fig:lazy-deref} illustre ce problème. On s'intéresse à l'évaluation
de l'expression \texttt{*p} aux points \texttt{(a)} et \texttt{(b)}. Avec une
sémantique paresseuse (en ajoutant un $\widehat{*}φ$), la valeur de
\texttt{p}
est $\widehat{\&}~((*(0,x)).f)$, donc
\texttt{*p} est évalué à $0$ en
\texttt{(a)}
et $1$ en
\texttt{(b)}.
Au contraire, avec une sémantique stricte (correcte),
\texttt{p} vaut
$\widehat{\&}~(((0,s0).f)$ et donc
\texttt{*p} est évalué à $0$ en
\texttt{(a)}
et en
\texttt{(b)}.
Les règles d'évaluation sont donc les suivantes. Dans le cas où la valeur
référencée n'a pas la forme $m[φ']_Φ$, aucune règle ne peut s'appliquer (comme
lorsqu'on cherche à réduire l'addition d'une fonction et d'un entier, par
exemple). Cela est préférable à renvoyer $\serr{ptr}$ car on montrera que la
première est toujours évitée dans les programmes typés
(théorème~\ref{thm:progres}).

% TODO vérifier qu'il faut pas un widehat &

\begin{figure}
\begin{Verbatim}
Decl s0 = { .f = 0 } in
Decl s1 = { .f = 1 } in
Decl x  = & s0 in
Decl p = & ((*x).f) in
/* (a) */
x <- & s1
/* (a) */
\end{Verbatim}

\caption{Évaluation stricte ou paresseuse des left-values}
\label{fig:lazy-deref}
\end{figure}

\begin{mathpar}
  \semrule{Phi-Deref}
\end{mathpar}

Un exemple d'évaluation est donné dans la figure~\ref{fig:eval-lv}.

\section{Expressions}
\label{sec:eval-exp}

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \semrule{Exp-Cst}
\end{mathpar}

De même, une fonction est déjà évaluée:

\begin{mathpar}
  \semrule{Exp-Fun}
\end{mathpar}

Pour lire le contenu d'un emplacement mémoire (left-value), il faut tout d'abord
l'évaluer en un chemin.

\begin{mathpar}
  \semrule{Exp-Lv}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, est encore imposé: de gauche à droite). À
chaque opérateur $\opbin$, correspond un opérateur sémantique $\widehat{\opbin}$
qui agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers.
Comme précisé dans la section~\ref{sec:sem-ops}, la division par zéro via $/$,
$\%$ ou $\floatop{/}$ provoque l'erreur $\serr{div}$.

\begin{mathpar}
  \semrule{Exp-UnOp}

  \semrule{Exp-BinOp}
\end{mathpar}

Il est nécessaire de dire un mot sur les opérations $\widehat{+_p}$ et
$\widehat{-_p}$ définissant l'arithmétique des pointeurs. Celles-ci sont
uniquement définies pour les références mémoire à un tableau, c'est-à-dire
celles qui ont la forme $\widehat{\&}~φ[n]$ (par souci de clarté on note pas
tous les $\widehat{\cdot}$ ci-dessous). On a alors:

\begin{align*}
  \widehat{\&}~φ[n]~+_p~i & = \widehat{\&}~φ[n+i] \\
  \widehat{\&}~φ[n]~-_p~i & = \widehat{\&}~φ[n-i] \\
\end{align*}

Cela implique qu'on ne peut pas faire faire d'arithmétique de pointeurs au sein
d'une même structure. Autrement c'est une erreur de manipulation de pointeurs
\label{page:def-arith-ptr-error}
\footnote{
Cela est cohérent avec la norme C99:
    ``If the pointer operand points to an element of an array object, and the
    array is large enough, […] ; otherwise, the behavior is undefined.
    ''~\cite[6.5.6~§8]{AnsiC}}:

\begin{align*}
\widehat{\&}~φ~+_p~i & = \serr{ptr} \textrm{ si }∄~(φ', i), φ = φ'[i] \\
\widehat{\&}~φ~-_p~i & = \serr{ptr} \textrm{ si }∄~(φ', i), φ = φ'[i] \\
        \eNull~+_p~i & = \serr{ptr} \\
        \eNull~-_p~i & = \serr{ptr} \\
\end{align*}

Pour prendre l'adresse d'une variable, il suffit de résoudre celle-ci dans
l'état mémoire courant.

\begin{mathpar}
  \semrule{Exp-AddrOf}
\end{mathpar}

L'affectation se déroule 3 étapes: d'abord, l'expression est évaluée en une
valeur $v$. Ensuite, la left-value est évaluée en un chemin $φ$. Enfin, un
nouvel état mémoire est construit, où la valeur accessible par $φ$ est remplacée
par $v$. Comme dans le langage C, l'expression d'affectation produit une valeur,
qui est celle qui a été affectée.

\begin{mathpar}
  \semrule{Exp-Set}
\end{mathpar}

\subsection*{Expressions composées}

Les littéraux de structures sont évalués en leurs constructions syntaxiques
respectives. Puisque les contextes d'évaluation sont de la forme $ [ v_1 ; … ; C
; … ; e_n ] $, l'évaluation se fait toujours de gauche à droite.

\begin{mathpar}
  \semrule{Exp-Struct}

  \semrule{Exp-Array}
\end{mathpar}

\shorthandoff{!}
\begin{figure}%{{{

  \centering

  \begin{tikzpicture}
    [node distance=2cm]

    \node (m0) {$m_0$};
    \node[right of=m0, node distance=3cm] (m1) {$m_1$};
    \node[below of=m1]                    (m2) {$m_2$};
    \node at ($(m0)!(m2)!(0,1)$)          (m3) {$m_3$};
    \node[below of=m3]                    (m4) {$m_4$};

    \draw [->] (m0) -- node[auto] {$\mathrm{Push}(\vec{a}↦\vec{v})$}    (m1);
    \draw [->] (m1) -- node[auto] {$i → \iReturn{v_r}$}                 (m2);
    \draw [->] (m2) -- node[auto] {$\mathrm{Pop}$}                      (m3);
    \draw [->] (m3) -- node[auto] {$\mathrm{Cleanup}$}                  (m4);

    \draw [dashed, ->] ($ (m0) + (-5mm, -3mm) $)
                    -- node[auto, swap] {$f(\vec{e}) → v$}
                       ($ (m4) + (-5mm, 3mm) $);

  \end{tikzpicture}

  \caption[Appel d'une fonction]
  { Appel d'une fonction.
    La taille de la pile croît de gauche à droite,
    et les réductions se font de haut en bas.
  }
\label{fig:fcall-details}

\end{figure}%}}}
\shorthandon{!}

L'appel de fonction est traité de manière similaire à la déclaration de
fonction: on ne peut pas facilement relier un pas d'évaluation de $i$ à un pas
d'évaluation de $\eFun{a_1,…,a_n}{i} (v_1,…,v_n)$, donc un contexte
$C \gramisa \eFun{a_1,…,a_n}{\ctxEmpty} (v_1,…,v_n)$ n'est pas à considérer. Il
faut donc transmettre le pas à la main. C'est le but des deux règles
\textsc{Exp-Call-Ctx} et \textsc{Exp-Call-Err}. D'autre part, les cas terminaux
sont \textsc{Exp-Call-Return-Unit} et \textsc{Exp-Call-Return}:

\begin{mathpar}
    \semrule{Exp-Call-Ctx}

    \semrule{Exp-Call-Err}

    \semrule{Exp-Call-Return-Unit}

    \semrule{Exp-Call-Return}
\end{mathpar}

% TODO blabla sur cleanup

Cette évaluation est décrite dans la figure~\ref{fig:fcall-details}.

\section{Instructions}
\label{sec:eval-instr}

\begin{definition}{Évaluation d'une instruction}

Comme pour l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante:
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ ``plus simple'' en partant d'un état mémoire
$m'$. Un tel pas est noté:

\[
  \mmi{m}{i}{m'}{i'}
\]

\end{definition}

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$:

\begin{align*}
  \msi{m}{(x ← 3 ; y ← x)} → & \msi{m [x ↦ \widehat{3}]}{y ← x} \\
                           → & \msi{m [x ↦ \widehat{3}][y ↦ \widehat{3}]}{\iPass}
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \semrule{Seq}

  \semrule{Exp}
\end{mathpar}

L'évaluation de $\iDecl{x}{v}{i}$ sous $m$ peut se faire de plusieurs manières.
La règle principale est \textsc{Decl-Ctx} qui relie un pas d'évaluation sous une
déclaration à un pas d'évaluation externe : pour ce faire, on étend l'état
mémoire en ajoutant $x$, on effectue le pas, puis on enlève $x$. L'instruction
résultante est la déclaration de $x$ avec la nouvelle valeur $v'$ de $x$ après
le pas d'exécution\footnote{
    On peut remarquer qu'il est impossible de définir un contexte d'évaluation
    $C \gramisa \iDecl{x}{v}{C}$. En effet, puisque celui-ci nécessiterait
    d'ajouter une variable, il ne préserve pas la mémoire.
}.

Si $i$ est terminale ($\iPass$ ou $\iReturn{v}$), alors on peut s'évaluer en $i$
en nettoyant l'espace mémoire des références à $x$ qui peuvent subsister.

Enfin, si une erreur se produit elle est propagée.

\begin{mathpar}
 \semrule{Decl-Pass}

 \semrule{Decl-Return}

 \semrule{Decl-Ctx}

 \semrule{Decl-Err}
\end{mathpar}

Pour traiter l'alternative, on a besoin de 2 règles. Elles commencent de la même
manière, en évaluant la condition. Si le résultat est 0 (et seulement dans ce
cas), c'est la règle \textsc{If-False} qui est appliquée et l'instruction
revient à évaluer la branche ``\emph{else}''. Dans les autres cas, c'est la règle
\textsc{If-True} qui s'applique et la branche ``\emph{then}'' qui est prise.

\begin{mathpar}
  \semrule{If-False}

  \semrule{If-True}
\end{mathpar}

Pour traiter la boucle, on peut être tenté de procéder de la même manière:

\begin{mathpar}
  \irule{While-False-Bad}
    { v ≠ 0 }
    { \mmi{m}{\iWhile{v}{i}}{m}{\iPass} }

  \irule{While-True-Bad}
    { }
    { \mmi{m}{\iWhile{0}{i}}{m'}{i;\iWhile{e}{i}}}
\end{mathpar}

Mais la seconde règle est impossible: puisque $e$ a déjà été évaluée, il est
impossible de la réintroduire non évaluée en partie droite.

À la place, on exprime la sémantique de la boucle comme une simple règle de
réécriture:

\begin{mathpar}
  \semrule{While}
\end{mathpar}

Cette règle revient à dire qu'on peut dérouler une boucle. Pour la comprendre,
on peut remarquer qu'une boucle ``\emph{while}'' est en réalité équivalente une
infinité de ``\emph{if}'' imbriqués.

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    if(e) {
        i;
        if(e) {
            i;
            if(e) {
                i;
                ...
            }
        }
    }
}
\end{Verbatim}
\end{minipage}

Donc en remplaçant le second ``\emph{if}'' par le ``\emph{while}'', on obtient:

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    while(e) {
        i
    }
}
\end{Verbatim}
\end{minipage}

Enfin, si un $\phx\iReturn$ apparaît dans une séquence, on peut supprimer la suite:

\begin{mathpar}
  \semrule{Return}
\end{mathpar}

\section{Erreurs}
\label{sec:eval-errors}

Les erreurs se propagent des données vers l'interprète; c'est-à-dire que si
une expression ou instruction est réduite en une valeur d'erreur $Ω$, alors une
transition est faite vers cet état d'erreur.

Cela est aussi vrai d'une sous-expression ou sous-instruction: si l'évaluation
de $e_1$ provoque une erreur, l'évaluation de $e_1 + e_2$ également. La notion
de sous-expression ou sous instruction est définie en fonction des contextes $C$
(figure~\ref{fig:eval-err}).

\begin{figure}
\begin{mathpar}
  \ruleheader{$Ξ → Ω$}

  \semrule{Exp-Err}

  \semrule{Eval-Err}
\end{mathpar}

\caption{Cas d'erreur lors d'une évaluation}
\label{fig:eval-err}
\end{figure}

\section{Phrases}

Un programme est constitué d'une suite de phrases: déclarations de fonctions,
de variables et de types, et évaluation d'expressions.

Donc l'évaluation d'une phrase $p$ fait passer d'un état mémoire $m$
à un autre $m'$, ce que l'on note $\ph{m}{p}{m'}$.

L'évaluation d'une expression est uniquement faite pour ses effets de bord. Par
exemple, après avoir défini les fonctions du programme, on pourra appeller
$\textrm{main}()$. La déclaration d'une variable globale (avec un initialiseur),
quant à elle consiste à évaluer cet initialiseur et à étendre l'état mémoire
avec ce couple (variable, valeur) (figure~\ref{fig:eval-toplevel}).

Notons que ces évaluations se font à grands pas.

\begin{figure}
\begin{mathpar}
  \ruleheader{$\ph{m}{p}{m'}$}

  \semrule{T-Exp}

  \semrule{T-Var}

\end{mathpar}

\caption{Évaluation des phrases d'un programme}
\label{fig:eval-toplevel}
\end{figure}

\section{Exécution}

L'exécution d'un programme est sans surprise l'exécution de ses phrases, les
unes à la suite des autres.

On commence par étendre l'extension $→^*$ au listes de la relation $→$:

\begin{mathpar}
  \semrule{T*-Nil}

  \semrule{T*-Cons}
\end{mathpar}

L'exécution d'un programme est définie par:

\begin{mathpar}
  \semrule{Prog}
\end{mathpar}

% TODO exemple?
%\section{Exemple: l'algorithme d'Euclide}

%\wip{}

%Version par divisions successives:

%\begin{Verbatim}
%function gcd(a, b)
  %var t = 0;
  %while b != 0
    %t = b
    %b = a mod b
    %a = t
  %return a
%\end{Verbatim}

%Soit:

%\def\exinnerif{t←b;b←a\%b;a←t}

%\begin{mathpar}
  %f (a, b) (t = 0) \{
    %\iWhile{b ≠ 0}{
      %\exinnerif{}
    %};
    %\iReturn{a}
  %\}
%\end{mathpar}

%\[
  %\msi{m}{f(1071, 462)} → ?
%\]

%\[
  %\msi{m[a↦1071][b↦462][t↦0]}{\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} → ?
%\]

%(on notera cet état $s_0 = \msi{m_0}{i_0}$)

%\[
  %\mm{m_0}{a = 0}{m_0}{0}
%\]

%donc

%\[
  %\mm{m_0}{\iThen{a = 0}{\iReturn{b}}}{m[a↦1071][b↦462]}{\iPass}
%\]

%{ \scriptsize
%\begin{align}
  %s_0 → & \msi{m_0  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      %→ & \msi{m_0  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_0  }{ b←a\%b;a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_0''}{ a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_1  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_1  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      %→ & \msi{m_1  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_2  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_2  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      %→ & \msi{m_2  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_3  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      %→ & \msi{m_3  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      %→ & \msi{m_3  }{ \iPass; \iReturn{a}} \\
      %→ & \msi{m_3  }{ \iReturn{a}}
%\end{align}

%\begin{align*}
  %m_0'  &= m_0  [t↦462] = m[a↦1071][b↦462][t↦462] \\
  %m_0'' &= m_0' [b↦147] = m[a↦1071][b↦147][t↦462] \\
  %m_1   &= m_0''[a↦462] = m[a↦462][b↦147][t↦462] \\
  %m_2   &= m_1[t↦147][b↦21][a↦147] = m[a↦147][b↦21][t↦147] \\
  %m_3   &= m_2[t↦21][b↦0][a↦21] = m[a↦21][b↦0][t↦21]
%\end{align*}
%}

% vim: spelllang=fr
