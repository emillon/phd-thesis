Dans ce chapitre, nous enrichissons le langage défini dans le
chapitre~\ref{cha:lang} d'un système de types. Celui-ci permet de séparer les
programmes bien formés, comme celui de la figure~\ref{fig:progwf:good} des
programmes mal formés comme celui de la figure~\ref{fig:progwf:bad}.

\begin{SaveVerbatim}[]{VerbProgGood}
f()
(x=0)
{
  x = 1
  return x
}
\end{SaveVerbatim}

\begin{SaveVerbatim}[]{VerbProgBad}
f()
(x=0)
{
  x = 1
  return (*x)
}
\end{SaveVerbatim}

\begin{figure}

  \centering

  \subfloat[][Programme bien formé]{
    \label{fig:progwf:good}
    \BUseVerbatim{VerbProgGood}
  }
  \hspace{2cm}
  \subfloat[][Programme mal formé]{
    \label{fig:progwf:bad}
    \BUseVerbatim{VerbProgBad}
  }

  \caption{Programmes bien et mal formés}
  \label{fig:progwf}

\end{figure}

Le but d'un tel système de types est de rejeter les programmes qui sont
"évidemment faux", c'est à dire dont on peut prouver qu'il provoqueraient des
erreurs à l'exécution dues à une incompatibilité entre valeurs. En ajoutant
cette étape, on restreint la classe d'erreurs qui pourraient bloquer la
sémantique.

\section{Principe}

Le principe est d'associer à chaque construction syntaxique une étiquette
représentant le genre de valeurs qu'elle produira. Dans le programme de la
figure~\ref{fig:progwf:good}, la variable $x$ est initialisée avec la valeur
$0$, c'est donc un entier. Cela signifie que dans tout le programme, toutes les
instances de cette variable
\footnote{Deux variables peuvent avoir le même nom dans deux fonctions
  différentes, par exemple. Dans ce cas il n'y a aucune contrainte particulière
  entre ces deux variables. L'analyse de typage se fait toujours dans un
  contexte précis.
}
porteront ce type. La première instruction est l'affectation de la constante $1$
(entière) à $x$ dont on sait qu'elle porte des valeurs entières, ce qui est donc
correct. Le fait de rencontrer $\iReturn{x}$ permet de conclure que le type de
la fonction est $() → \tInt$.

Dans la seconde fonction, au contraire, l'opérateur $*$ est appliqué à $x$ (le
début de l'analyse est identique et permet de conclure que $x$ porte des valeurs
entières). Or cet opérateur prend un argument d'un type pointeur de la forme
$t*$ et renvoie alors une valeur de type $t$. Ceci est valable pour tout $t$
(\tInt, \tFloat où même $t'*$ : le déréférencement d'un pointeur sur pointeur
donne un pointeur), mais le type de $x$, \tInt, n'est pas de cette forme. Ce
programme est donc mal typé.

\section{Définitions}

\begin{figure}

  \gramlr{Type}{
    \begin{align*}
      t \gramisa & \tInt                         & \textrm{Entier}
      \\ \gramor & \tFloat                       & \textrm{Flottant}
      \\ \gramor & t[]                           & \textrm{Tableau}
      \\ \gramor & t*                            & \textrm{Pointeur}
      \\ \gramor & \tstruct{s}                   & \textrm{Structure}
      \\ \gramor & (t_1, …, t_n) \rightarrow t_r & \textrm{Fonction}
    \end{align*}
  }

  \gramlr{Environnement de typage}{
    \begin{align*}
      Γ \gramisa & []         & \textrm{Environnement vide}
      \\ \gramor & (a, t)::Γ' & \textrm{Extension}
    \end{align*}
  }

  \gramlr{Environnement de typage de structures}{
    \begin{align*}
      S \gramisa & []                & \textrm {Environnement vide}
      \\ \gramor & (s, x, t_f)::Γ'   & \textrm{Extension}
    \end{align*}
  }

  \caption{Types et environnements de typage}

  \label{fig:les-types}

\end{figure}

Les types associés aux expressions sont décrits dans la
figure~\ref{fig:les-types}.

Pour maintenir les contextes de typage, deux environnements sont nécessaires :
d'une part, un environnement $Γ$ qui associe un type à un ensemble de variables ;
et d'autre part, un environnement de structures $S$ qui associe les noms de
champs et leur type à un nom de structure.

Plus précisément, un environnement $Γ$ est une liste de couples (variable, type)
et un environnement de structures $S$ est une liste de triplets (nom de la
structure, nom du champ, type du champ).

Par exemple, $(p, \tInt*) ∈ Γ$ permet de typer (sous $Γ$) l'expression $p$ en
$\tInt*$, $*p$ en $\tInt$ et $p +_p 4$ en $\tInt*$.

Si $(s, y, \tFloat) ∈ S$, $y$ désigne le nom d'un champ de type $\tInt$ dans une
structure de type $\tstruct{s}$. Donc sous $Γ = (x, \tstruct{s})$, on peut alors
typer $x.y$ en $\tFloat$.

Le type des fonctions semble faire apparaître un n-uplet $(t_1, …, t_n)$ mais ce
n'est qu'une notation : il n'y a pas de n-uplets de première classe, ils sont
toujours présents dans un type fonctionnel.

\begin{definition}[Typage d'une expression]

  On note de la manière suivante le fait qu'une expression $e$ (telle que
  définie dans la figure~\ref{fig:stx-data}) ait pour type $t$ dans le contexte
  $Γ, S$.

  \[
    \ty{Γ, S}{e}{t}
  \]

\end{definition}

\begin{definition}[Typage d'une instruction]

  Les instructions n'ont en revanche pas de type. Mais il est tout de même
  nécessaire de vérifier que troutes les sous-expressions apparaissant dans une
  instruction sont cohérentes ensemble.

  On note de la manière suivante le fait que sous l'environnement $Γ$
  l'instruction $i$ est bien typée :

  \[
    \tyi{Γ, S}{i}
  \]

\end{definition}

\begin{definition}[Typage d'une phrase]

  De par leur nature séquentielle, les phrases qui composent un programme
  altèrent l'environnement de typage. Par exemple, la déclaration d'une variable
  globale ajoute une valeur dans l'environnement.

  On note

  \[
    \typh{Γ}{S}{p}{Γ'}{S'}
  \]

  si le typage de la phrase $p$ transforme l'environnement $Γ, S$ en $Γ', S'$.

  On étend cette notation aux suites de phrases :

  \[
    \begin{cases}
      \typhstar{Γ}{S}{[]}{Γ}{S}  \\
      \typhstar{Γ}{S}{p::ps}{Γ'}{S'} \mbox{ si }
        ∃ Γ'', S'' ,
            \begin{cases}
              \typh{Γ}{S}{p}{Γ''}{S''}  \\
              \typhstar{Γ''}{S''}{ps}{Γ'}{S'}
            \end{cases}
    \end{cases}
  \]

\end{definition}

\begin{definition}[Typage d'un programme]

  Un programme est bien typé si on peut typer sa suite de phrases en partant
  d'un environnement vide. C'est à dire s'il existe un environnement final $Γ_f,
  S_f$ tel que

  \[
    \typhstar{[]}{[]}{P}{Γ_f}{S_f}
  \]

  Cela est indépendant de tout environnement ; on note alors :

  \[
    ⊢ P
  \]

\end{definition}

\section{Expressions}

\subsection*{Littéraux}

Le typage des littéraux numériques ne dépend pas de l'environnement de typage :
ce sont toujours des entiers ou des flottants.

\begin{mathpar}

  \irule{Cst-Int}
    { }
    { Γ, S ⊢ i : \tInt}

  \irule{Cst-Float}
    { }
    { Γ, S ⊢ f : \tFloat}

\end{mathpar}

Le pointeur nul, quant à lui, est compatible avec tous les types pointeur.

\begin{mathpar}
  \irule{Cst-Null}
    { }
    { Γ, S ⊢ \eNull : t*}
\end{mathpar}

\subsection*{Left-values}

Rappelons que l'environnement de typage $Γ$ contient le type des variables
accessibles du programme. Le cas où la left-value à typer est une variable est
donc direct : il suffit de retrouver son type dans l'environnement.

\begin{mathpar}
  \irule{Lv-Var}
    { (x, t) ∈ Γ }
    { Γ, S ⊢ x : t }
\end{mathpar}

Dans le cas d'un déréférencement, on commence par typer la left-value
déréférencée. Si elle a un type pointeur, la valeur déréférencée est du type
pointé.

\begin{mathpar}
  \irule{Lv-Deref}
    { Γ, S ⊢ lv : t* }
    { Γ, S ⊢ *lv : t }
\end{mathpar}

Pour une left-value indexée (l'accès à tableau), on s'assure que l'indice soit
entier, et que la left-value a un type tableau : le type de l'élement est encore
une fois le type de base du type tableau ($t$ pour $t[]$).

\begin{mathpar}
  \irule{Lv-Index}
    { Γ, S ⊢ e : \tInt \\
      Γ, S ⊢ lv : t[]
    }
    { Γ, S ⊢ lv[e] : t }
\end{mathpar}

Enfin, le typage de l'accès à un champ nécessite d'accéder à l'environnement de
structures $S$. L'existence d'un triplet $(s, f, t_f)$ tel que $lv$ est
typable en $t_s$ permet de typer $lv.f$ en $\tstruct{s}$.

\begin{mathpar}
  \irule{Lv-Field}
    { (s, f, t_f) ∈ S \\
      Γ, S ⊢ lv : \tstruct{s}
    }
    { Γ, S ⊢ lv.f : t_f }
\end{mathpar}

\subsection*{Opérateurs}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
\irule{Op-Int}{
  \opbin ∈ \{+,-,\times,/,\&,|,\opxor,\&\&,||,\ll,\gg \} \\
  Γ, S ⊢ e_1 : \tInt \\
  Γ, S ⊢ e_2 : \tInt
}{
  Γ, S ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
\irule{Op-Float}{
  \opbin ∈ \{+.,-.,\times.,/.\} \\
  Γ, S ⊢ e_1 : \tFloat \\
  Γ, S ⊢ e_2 : \tFloat
}{
  Γ, S ⊢ e_1~\opbin~e_2 : \tFloat
}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes qui sont d'un
type qui supporte l'égalité. Ceci est représenté par un jugement
$\textsc{Eq}(t)$ qui est vrai pour les types \tInt, \tFloat et pointeurs. Les
opérateurs $=$ et $≠$ renvoient alors un \tInt.

\begin{mathpar}
\irule{Eq-Num}
  {t ∈ \{ \tInt, \tFloat \}}
  {\textsc{Eq}(t)}

\irule{Eq-Ptr}
  {\textsc{Eq}(t)}
  {\textsc{Eq}(t*)}

\irule{Eq-Array}
  {\textsc{Eq}(t)}
  {\textsc{Eq}(t[])}

\irule{Op-Eq}{
  \opbin ∈ \{=,≠\} \\
  Γ, S ⊢ e_1 : t \\
  Γ, S ⊢ e_2 : t \\
  \textsc{Eq}(t)
}{
  Γ, S ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

%TODO Eq-Struct

Les comparaisons sont plus restrictives, et ne s'appliquent qu'aux types
primitifs (on ne peut pas comparer deux pointeurs, ou deux tableaux).

\begin{mathpar}
\irule{Op-Comparable}{
  \opbin ∈ \{=,≠,≤,≥,<,>\} \\
  Γ, S ⊢ e_1 : t \\
  Γ, S ⊢ e_2 : t \\
  t ∈ \{ \tInt, \tFloat \}
}{
  Γ, S ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

% TODO extensions aux structs et tableaux

Les opérateurs unaires "$+$" et "$-$" appliquent aux \tInt, et leurs équivalents
"$+.$" et "$-.$" aux \tFloat.

\begin{mathpar}
\irule{Unop-Plus-Int}{ Γ, S ⊢ e : \tInt }{ Γ, S ⊢ + e : \tInt }
\and
\irule{Unop-Plus-Float}{ Γ, S ⊢ e : \tFloat }{ Γ, S ⊢ +. e : \tFloat }

\irule{Unop-Minus-Int}{ Γ, S ⊢ e : \tInt }{ Γ, S ⊢ - e : \tInt }
\and
\irule{Unop-Minus-Float}{ Γ, S ⊢ e : \tFloat }{ Γ, S ⊢ -. e : \tFloat }
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
\irule{Unop-Not}{
  \opun ∈ \{ \sim, ! \} \\
  Γ, S ⊢ e : \tInt
}{
  Γ, S ⊢ \opun~e : \tInt
}
\end{mathpar}

L'arithmétique de pointeurs préserve le type des pointeurs.

\begin{mathpar}
\irule{Ptr-Arith}
  { \opbin ∈ \{ +_p, -_p \} \\
    Γ, S ⊢ e_1 : t* \\
    Γ, S ⊢ e_2 : \tInt \\
  }
  { Γ, S ⊢ e_1~\opbin~e_2 : t* }
\end{mathpar}

\subsection*{Autres expressions}

Prendre l'adresse d'une left-value rend un type pointeur sur le type de
celle-ci.

\begin{mathpar}
  \irule{Addr}
    { Γ, S ⊢ lv : t }
    { Γ, S ⊢ \&lv : t* }
\end{mathpar}

Pour typer une affectation, on vérifie que la left-value (à gauche) et
l'expression (à droite) ont le même type. C'est alors le type résultat de
l'expression d'affectation.

\begin{mathpar}
  \irule{Set}
    { Γ, S ⊢ lv : t \\
      Γ, S ⊢ e : t
    }
    { Γ, S ⊢ lv ← e : t }
\end{mathpar}

Un littéral tableau a pour type $t[]$ où $t$ est le type de chacun de ses
éléments.

\begin{mathpar}
  \irule{Array}
    { ∀ i ∈ [1;n] , Γ, S ⊢ e_i : t }
    { Γ, S ⊢ \{ e_1 ;
            … ; e_n \}
            : t[]
    }
\end{mathpar}

Pour qu'un littéral de structure soit bien typé, il faut que chacun de ses noms
de champs corresponde à un même nom de type structure, avec le bon type pour
chaque champ.

\begin{mathpar}
  \irule{Struct}
    { ∀ i ∈ [1;n], Γ, S ⊢ e_i : t_i \\
      ∀ i ∈ [1;n], (s, f_i, t_i) ∈ S
    }
    { Γ, S ⊢ \{ f_1 : e_1 ;
            … ; f_n : e_n \}
            : \tstruct{s}
    }
\end{mathpar}

Pour typer un appel de fonction, on s'assure que la fonction a bien un type
fonctionnel. On type alors chacun des arguments avec le type attendu. Le
résultat est du type de retour de la fonction.

\begin{mathpar}
  \irule{Call}
    { Γ, S ⊢ f : ( t_1 ,
               … , t_n ) → t \\
      ∀ i ∈ [1;n], Γ, S ⊢ e_i : t_i
    }
    { Γ, S ⊢ f( e_1 ,
            … , e_n )
            : t
    }
\end{mathpar}

\section{Instructions}

La séquence est simple à traiter : l'instruction vide est toujours bien typée,
et la suite de deux instructions est bien typée si celles-ci le sont également.

\begin{mathpar}
  \irule{Pass}
    { }
    {Γ, S ⊢ \iPass}

  \irule{Seq}{
    Γ, S ⊢ i_1 \\
    Γ, S ⊢ i_2
  }{
    Γ, S ⊢ i_1;i_2
  }
\end{mathpar}

Une instruction constituée d'une expression est bien typée si celle-ci peut être
typée dans ce même contexte.

\begin{mathpar}
  \irule{Exp}
    { Γ, S ⊢ e : t }
    { Γ, S ⊢ e }
\end{mathpar}

Les constructions de contrôle sont bien typées si leurs sous-instructions sont
bien typées, et si la condition est d'un type entier.

\begin{mathpar}
  \irule{If}
    { Γ, S ⊢ e : \tInt \\
      Γ, S ⊢ i_1 \\
      Γ, S ⊢ i_2
    }
    { Γ, S ⊢ \iIf{e}{i_1}{i_2} }

  \irule{While}
    { Γ, S ⊢ e : \tInt \\
      Γ, S ⊢ i
    }
    { Γ, S ⊢ \iWhile{e}{i} }
\end{mathpar}

\begin{mathpar}
\end{mathpar}

\section{Fonctions}

Le typage des fonctions fait intervenir une variable virtuelle $\vRet$. Cela
revient à typer l'instruction $\iReturn{e}$ comme $\vRet ← e$.


\begin{mathpar}

  \irule{Return}
    { Γ, S ⊢ \vRet ← e }
    { Γ, S ⊢ \iReturn{e} }

  \irule{Fun}
    {
      Γ - \vRet, a_1 : t_1, …, a_n : t_n,
         l_1 : t'_1, …, l_n : t'_p,
         \vRet : t
         ⊢ i
      \\
      ∀ i ∈ [1;p], Γ ⊢ e_i : t'_i
    }
    { Γ ⊢ \mathrm{fun} (a_1, …, a_n)
          ((l_1, e_1), …, (l_p, e_p)) \{i\}
           : (t_1, …, t_n) → t }

\end{mathpar}

\section{Phrases}

L'évaluation d'une expression est le cas le plus simple. En effet, il y a juste
à vérifier que celle-ci est bien typable (avec ce type) dans l'environnement de
départ. L'environnement n'est pas modifié.

\begin{mathpar}
  \irule{Ph-Exp}
    { Γ, S ⊢ e : t }
    { \typh{Γ}{S}{e}{Γ}{S} }
\end{mathpar}

La déclaration d'une variable globale commence de la même manière, mais on
enrichit l'environnement de cette nouvelle valeur.

\begin{mathpar}
  \irule{Ph-Var}
    { Γ, S ⊢ e : t \\
      Γ' = (x, t), Γ
    }
    { \typh{Γ}{S}{p}{Γ'}{S} }
\end{mathpar}

La déclaration d'une structure ne modifie pas $Γ$, mais ajoute $n$ triplets
$(x_i, t_i, s)$ à l'environnement de typage de structures $S$.

\begin{mathpar}

  \irule{Ph-Struct}
    { S' =
      (x_1, t_1, s),
      …
      (x_n, t_n, s), S
    }
    { \typh{Γ}{S}{ \tstruct{s}
                      \{ x_1 : t_1
                       ; …
                       ;  x_n : t_n
                      \}
                  }{Γ}{S'}
    }

\end{mathpar}

\section{Sûreté du typage}

Comme le dit Robin Milner, "Well-typed programs don't go wrong". C'est à dire
qu'un programme bien typé possède des propriétés de sûreté.

\paragraph{Progrès :} l'évaluation d'un terme bien typé ne reste pas bloquée;
il y a toujours une règle qui s'applique.

\paragraph{Préservation :} l'évaluation d'un terme bien typé produit un terme
bien typé.

\begin{theorem}[Progrès]

  Si $Γ, S ⊢ e : t$, alors soit :

\begin{itemize}
\item $e$ est une valeur : $∃ v, e = v$
\item il existe $e'$ tel que $e → e'$ % TODO
\item une erreur d'accès tableau ou pointeur se produit
\end{itemize}

\end{theorem}

Les règles précédentes ont la particularité suivante : pour chaque forme
syntaxique, il n'y a souvent qu'une règle qui peut s'appliquer. Cela permet de
déduire quelle règle il faut appliquer pour vérifier (ou inférer) le type d'une
expression.

\begin{lemma}[Inversion]

  À partir d'un jugement de typage, on peut en déduire des inforamtions sur les
  types de ses sous-expressions.

\begin{itemize}
\item Références mémoire :
  \begin{itemize}
    \item
      si $Γ ⊢ x : t$, $x : t ∈ Γ$
    \item
      si $Γ ⊢ *φ : t$, alors $Γ ⊢ φ : t$
    \item
      si $Γ ⊢ φ[] : t$, alors $Γ ⊢ φ : t[]$
    \item
      si $Γ ⊢ φ.f : t$, alors $Γ ⊢ φ : \{ f: t ; … \}$
    % TODO structure
  \end{itemize}
\item
  Appel de fonction : si $Γ ⊢ e (e_1, …, e_n) : t$, il existe $(t_1, …, t_n)$
  tels que

  \[
    \begin{cases}
      Γ ⊢ e : (t_1, …, t_n) → t \\
      ∀ i ∈ [1;n], Γ ⊢ e_i : t_i
    \end{cases}
  \]

\item Fonction : si $Γ ⊢ \mathrm{fun} (a_1, …, a_n) ((l_1, e_1), …, (l_p, e_p))
  \{i\} : t$, alors il existe $(t_1, …, t_n)$ et $t'$ tels que $t' = (t_1, …,
  t_n) → t$.

\item
  Constantes
  \begin{itemize}
    \item si $Γ ⊢ n : t$, alors $t = \tInt$
    \item si $Γ ⊢ f : t$, alors $t = \tFloat$
    \item si $Γ ⊢ \eNull : t$, alors $∃ t', t = t'*$
  \end{itemize}
  % TODO ...
\end{itemize}

\end{lemma}

Il est aussi possible de réaliser l'opération inverse : à partir du type d'une
valeur, on peut déterminer sa forme syntaxique. C'est bien sûr uniquement
possible pour les valeurs, pas pour n'importe quelle expression (par exemple
l'expression $x$ (variable) peut avoir n'importe quel type $t$ dans le contexte
$Γ = x:t$).

\begin{lemma}[Formes canoniques]

  Il est possible de déterminer la forme syntaxique d'une valeur étant donné son
  type.

  \begin{itemize}
  \item si $Γ ⊢ v : \tInt$, $v = n$.
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = f$.
  \item si $Γ ⊢ v : t*$, $v = φ$.
  \item si $Γ ⊢ v : t[]$, $v = [v_1, …, v_n]$.
    %TODO structures
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = \mathrm{fun}
    (a_1, …, a_n) ((l_1, e_1), …, (l_p, e_p))$.
  \end{itemize}

\end{lemma}

\begin{lemma}[Permutation]
  L'ordre dans lequel les variables apparaissent dans un environnement
  n'influe pas sur la relation de typage.

  Pour toute permutation $σ$ de $[1;n]$, on note $σ(x_1 : t_1, …, x_n : t_n) =
  x_{σ(1)} : t_{σ(1)}, … x_{σ(n)} : t_{σ(n)}$.

  Alors : si $Γ ⊢ e : t$ et $Γ' = σ(Γ)$, alors $Γ' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Affaiblissement]
  De même que l'ordre n'influe pas le typage, on peut aussi ajouter des
  associations supplémentaires dans l'environnement sans modifier les typages
  dans cet environnement.

  Si $Γ ⊢ e : t$ et $x ∉ \mathrm{dom}(Γ)$, alors $Γ, x : t' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Substitution]
  Si dans une expression $e$ il apparait une variable $x$ de type $t'$, le
  typage est préservé lorsqu'on remplace ses occurrences par une expression $e'$
  de même type.

  Si $Γ, x : t' ⊢ e : t$ et $Γ ⊢ e' : t'$, alors $Γ ⊢ e [x/e'] : t$.
\end{lemma}

Ces lemmes permettent de prouver le théorème suivant :

\begin{theorem}[Préservation]

  Si une expression est typable et que son évaluation produit une valeur, alors
  cette valeur est du même type que l'expression.

  Si $Γ, S ⊢ e : t$ et $e → v$ % TODO

  alors $Γ, S ⊢ v : t$.

\end{theorem}

% TODO versions Γ ⊢ i

\section*{TODO}

\begin{itemize}
\item enlever S
\item ordre des sections
\item noter les flottants, fonctions et champs différemment
\end{itemize}
