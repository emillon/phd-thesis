Dans ce chapitre, nous enrichissons le langage défini dans le
chapitre~\ref{cha:lang} d'un système de types. Celui-ci permet de séparer les
programmes bien formés, comme

\begin{Verbatim}
f()
(x=0)
{
  x = 1
  return x
}
\end{Verbatim}

des programmes mal formés comme

\begin{Verbatim}
f()
(x=0)
{
  x = 1
  return (*x)
}
\end{Verbatim}

Le but d'un tel système de types est de rejeter les programmes qui sont
"évidemment faux", c'est à dire dont on peut prouver qu'il provoqueraient des
erreurs de typage à l'exécution (c'est-à-dire dont la sémantique d'exécution
reste bloquée à cause d'incompatibilité entre valeurs).

\section{Principe}

Le principe est d'associer à chaque construction syntaxique une étiquette
représentant le genre de valeurs qu'elle produira. Prenons le premier programme
ci-dessus. La variable $x$ est initialisée avec la valeur $0$, c'est donc un
entier. Cela signifie que dans tous le programme, toutes les instances de cette
variable
\footnote{Deux variables peuvent avoir le même nom dans deux fonction
  différentes, par exemple. Dans ce cas il n'y a aucune contrainte particulière
  entre ces deux variables. L'analyse de typage se fait toujours dans un
  contexte précis.
}
porteront ce type. La première instruction est l'affectation de la constante $1$
(entière) à $x$ dont on sait qu'elle porte des valeurs entières, ce qui est donc
correct. Le fait de rencontrer $\iReturn{x}$ permet de conclure que le type de
la fonction est $() → \tInt$.

Dans la seconde fonction, au contraire, l'opérateur $*$ est appliqué à $x$ (le
début de l'analyse est identique et permet de conclure que $x$ porte des valeurs
entières). Or cet opérateur prend un argument d'un type pointeur de la forme
$t*$ et renvoie alors une valeur de type $t$. Ceci est valable pour tout $t$
(\tInt, \tFloat où même $t'*$ : le déréférencement d'un pointeur sur pointeur
donne un pointeur), mais le type de $x$, \tInt, n'est pas de cette forme. Ce
programme est donc mal typé.

\section{Définitions}

Les types associés aux expressions sont les suivants :

\gramlr{Type}{
  \begin{align*}
    t \gramisa & \tInt                         & \textrm{Entier}
    \\ \gramor & \tFloat                       & \textrm{Flottant}
    \\ \gramor & t[]                           & \textrm{Tableau}
    \\ \gramor & t*                            & \textrm{Pointeur}
    \\ \gramor & \{ f_1:t_1
               ,    …
               , f_n:t_n \}                    & \textrm{Structure}
    \\ \gramor & (t_1, …, t_n) \rightarrow t_r & \textrm{Fonction}
  \end{align*}
}

Le typage se fait toujours dans un contexte particulier, qui est un
environnement de typage. Celui-ci associe des types aux variables.

\gramlr{Environnement de typage}{
  \begin{align*}
    Γ \gramisa & ε          & \textrm{Environnement vide}
    \\ \gramor & (a, t), Γ' & \textrm{Extension}
  \end{align*}
}

\begin{definition}[Typage d'une expression]

  Sous l'environnement $Γ$ , l'expression $e$ a pour type $t$.

  \[
    \ty{Γ}{e}{t}
  \]

\end{definition}

\begin{definition}[Typage d'une instruction]
  Sous l'environnement $Γ$ , l'instruction $i$ est bien typée.

  \[
    \tyi{Γ}{i}
  \]

\end{definition}

\begin{definition}[Typage d'une phrase]

  \[
    \typh{Γ}{S}{p}{Γ'}{S'}
  \]

% TODO définir S

\end{definition}

\section{Expressions}

\begin{mathpar}

  \irule{Cst-Int}
    { }
    { Γ ⊢ i : \tInt}

  \irule{Cst-Float}
    { }
    { Γ ⊢ i : \tInt}

  % TODO
  \irule{Cst-Null}
    { }
    { Γ ⊢ \eNull : ?}

  \irule{Lv-Var}
    { (x, t) ∈ Γ }
    { Γ ⊢ x : t }

  \irule{Lv-Deref}
    { Γ ⊢ x : t* }
    { Γ ⊢ *x : t }

  % TODO
  \irule{Lv-Field}
    { }
    { Γ ⊢ x.f : t }

  \irule{Lv-Index}
    { Γ ⊢ e : \tInt \\
      Γ ⊢ x : t[]
    }
    { Γ ⊢ x[e] : t }

  % TODO opérateurs

  \irule{Addr}
    { Γ ⊢ lv : t }
    { Γ ⊢ \&lv : t* }

  \irule{Set}
    { Γ ⊢ lv : t \\
      Γ ⊢ e : t
    }
    { Γ ⊢ lv ← e : t }

  \irule{Struct}
    { ∀ i, 1 ≤ i ≤ n ⇒ Γ ⊢ e_i : t_i }
    { Γ ⊢ \{ f_1 : e_1 ;
         … ; f_n : e_n \}
        : \{ f_1 : t_1 ;
         … ; f_n : t_n \}
    }

  \irule{Array}
    { ∀ i, 1 ≤ i ≤ n ⇒ Γ ⊢ e_i : t }
    { Γ ⊢ \{ e_1 ;
         … ; e_n \}
        : t[]
    }

  \irule{Call}
    { ∀ i, 1 ≤ i ≤ n ⇒ Γ ⊢ e_i : t_i \\
      Γ ⊢ f : ( t_1 ,
            … , t_n ) → t
    }
    { Γ ⊢ f( e_1 ,
         … , e_n )
        : t
    }

\end{mathpar}

\subsection*{Opérateurs}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
\irule{Op-Int}{
  \opbin ∈ \{+,-,\times,/,\&,|,\opxor,\&\&,||,\ll,\gg \} \\
  Γ ⊢ e_1 : \tInt \\
  Γ ⊢ e_2 : \tInt
}{
  Γ ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
\irule{Op-Float}{
  \opbin ∈ \{+.,-.,\times.,/.\} \\
  Γ ⊢ e_1 : \tFloat \\
  Γ ⊢ e_2 : \tFloat
}{
  Γ ⊢ e_1~\opbin~e_2 : \tFloat
}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes de types
"comparables". On introduit donc un jugement $\textsc{Comparable}(τ)$ qui est
vrai pour les types \tInt, \tFloat et pointeurs. Les comparaisons renvoient
alors un \tInt.

\begin{mathpar}
\irule{Cmp-Num}
  {τ ∈ \{ \tInt, \tFloat \}}
  {\textsc{Comparable}(τ)}
\and
\irule{Cmp-Ptr}
  { }
  {\textsc{Comparable}(τ*)}
\and
\irule{Op-Cmp}{
  \opbin ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : τ \\
  Γ ⊢ e_2 : τ \\
  \textsc{Comparable}(τ)
}{
  Γ ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

Les opérateurs unaires "$+$" et "$-$" appliquent aux \tInt, et leurs équivalents
"$+.$" et "$-.$" aux \tFloat.

\begin{mathpar}
\irule{Unop-Plus-Int}{ Γ ⊢ e : \tInt }{ Γ ⊢ + e : \tInt }
\and
\irule{Unop-Plus-Float}{ Γ ⊢ e : \tFloat }{ Γ ⊢ +. e : \tFloat }

\irule{Unop-Minus-Int}{ Γ ⊢ e : \tInt }{ Γ ⊢ - e : \tInt }
\and
\irule{Unop-Minus-Float}{ Γ ⊢ e : \tFloat }{ Γ ⊢ -. e : \tFloat }
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
\irule{Unop-Not}{
  \opun ∈ \{ \sim, ! \} \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ \opun~e : \tInt
}
\end{mathpar}

L'arithmétique de pointeurs préserve le type.

\begin{mathpar}
\irule{Ptr-Arith}
  { \opbin ∈ \{ +_p, -_p \} \\
    Γ ⊢ e_1 : t* \\
    Γ ⊢ e_2 : \tInt \\
  }
  { Γ ⊢ e_1~\opbin~e_2 : t* }
\end{mathpar}

\section{Instructions}

\begin{mathpar}

  \irule{Pass}
    { }
    {Γ ⊢ \iPass}

  \irule{Seq}{
    Γ ⊢ i_1 \\
    Γ ⊢ i_2
  }{
    Γ ⊢ i_1;i_2
  }

  \irule{Exp}
    { Γ ⊢ e : t }
    { Γ ⊢ e }

  \irule{If}
    { Γ ⊢ e : \tInt \\
      Γ ⊢ i_1 \\
      Γ ⊢ i_2
    }
    { Γ ⊢ \iIf{e}{i_1}{i_2} }

  \irule{While}
    { Γ ⊢ e : \tInt \\
      Γ ⊢ i
    }
    { Γ ⊢ \iWhile{e}{i} }

  % TODO comment le détecter pour typer la fonction ? faire une fausse lvalue ?
  \irule{Return}
    { Γ ⊢ e : t }
    { Γ ⊢ \iReturn{e} }

\end{mathpar}

\section{Fonctions}

\begin{mathpar}

  \irule{Fun}
    { ?? }
    { Γ ⊢ f : (t_1, …, t_n) → t }

\end{mathpar}

\section{Programme}

\begin{mathpar}
  \irule{Prog}
    { ∀ i, 1 ≤ i ≤ p ⇒ Γ ⊢ e_i : t_i
    }
    {
      Γ ⊢ ((f_1, …, f_n), ((x_1, e_1), …, (x_p, e_p)))
    }
\end{mathpar}

\begin{center}\rule{3in}{0.4pt}\end{center}

\section*{TODO}

\begin{itemize}
\item
  utiliser des phrases toplevel
\item
  résoudre le problème du return
\end{itemize}
