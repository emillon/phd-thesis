Dans ce chapitre, nous enrichissons le langage défini dans le
chapitre~\ref{cha:lang} d'un système de types. Celui-ci permet de séparer les
programmes bien formés, comme

\begin{Verbatim}
f()
(x=0)
{
  x = 1
  return x
}
\end{Verbatim}

des programmes mal formés comme

\begin{Verbatim}
f()
(x=0)
{
  x = 1
  return (*x)
}
\end{Verbatim}

Le but d'un tel système de types est de rejeter les programmes qui sont
"évidemment faux", c'est à dire dont on peut prouver qu'il provoqueraient des
erreurs de typage à l'exécution (c'est-à-dire dont la sémantique d'exécution
reste bloquée à cause d'incompatibilité entre valeurs).

\section{Principe}

Le principe est d'associer à chaque construction syntaxique une étiquette
représentant le genre de valeurs qu'elle produira. Prenons le premier programme
ci-dessus. La variable $x$ est initialisée avec la valeur $0$, c'est donc un
entier. Cela signifie que dans tous le programme, toutes les instances de cette
variable
\footnote{Deux variables peuvent avoir le même nom dans deux fonctions
  différentes, par exemple. Dans ce cas il n'y a aucune contrainte particulière
  entre ces deux variables. L'analyse de typage se fait toujours dans un
  contexte précis.
}
porteront ce type. La première instruction est l'affectation de la constante $1$
(entière) à $x$ dont on sait qu'elle porte des valeurs entières, ce qui est donc
correct. Le fait de rencontrer $\iReturn{x}$ permet de conclure que le type de
la fonction est $() → \tInt$.

Dans la seconde fonction, au contraire, l'opérateur $*$ est appliqué à $x$ (le
début de l'analyse est identique et permet de conclure que $x$ porte des valeurs
entières). Or cet opérateur prend un argument d'un type pointeur de la forme
$t*$ et renvoie alors une valeur de type $t$. Ceci est valable pour tout $t$
(\tInt, \tFloat où même $t'*$ : le déréférencement d'un pointeur sur pointeur
donne un pointeur), mais le type de $x$, \tInt, n'est pas de cette forme. Ce
programme est donc mal typé.

\section{Définitions}

\begin{figure}

  \gramlr{Type}{
    \begin{align*}
      t \gramisa & \tInt                         & \textrm{Entier}
      \\ \gramor & \tFloat                       & \textrm{Flottant}
      \\ \gramor & t[]                           & \textrm{Tableau}
      \\ \gramor & t*                            & \textrm{Pointeur}
      \\ \gramor & \tstruct{s}                   & \textrm{Structure}
      \\ \gramor & (t_1, …, t_n) \rightarrow t_r & \textrm{Fonction}
    \end{align*}
  }

  \gramlr{Environnement de typage}{
    \begin{align*}
      Γ \gramisa & ε          & \textrm{Environnement vide}
      \\ \gramor & (a, t), Γ' & \textrm{Extension}
    \end{align*}
  }

  \gramlr{Environnement de typage de structures}{
    \begin{align*}
      S \gramisa & ε                 & \textrm {Environnement vide}
      \\ \gramor & (s, x, t_f), Γ'   & \textrm{Extension}
    \end{align*}
  }

  \caption{Types et environnements de typage}

  \label{fig:les-types}

\end{figure}

Les types associés aux expressions sont décrits dans la
figure~\ref{fig:les-types}.

Les type de structures comprennent uniquement un nom. Celui-ci permet de
retrouver la liste des champs dans l'environnement de typage de structures
décrit plus bas.

Le type des fonctions semble faire apparaître un n-uplet $(t_1, …, t_n)$ mais ce
n'est qu'une notation : il n'y a pas de n-uplets de première classe, ils sont
toujours présents dans un type fonctionnel.

Le typage se fait toujours dans un contexte particulier, qui est un
environnement de typage. Celui-ci associe des types aux variables.

Les types structures ont un ensemble de champs associés à un type.
Les environnements de typage permettent de regrouper cette information. Ce sont
des ensembles de triplets $(s, x, t_f)$ où $x$ est le nom d'un champ de type
$t_f$ dans une structure de type $\tstruct{s}$.

\begin{definition}[Typage d'une expression]

  Sous l'environnement $Γ$ , l'expression $e$ a pour type $t$.

  \[
    \ty{Γ}{e}{t}
  \]

\end{definition}

\begin{definition}[Typage d'une instruction]

  Les instructions n'ont en revanche pas de type. Mais il est tout de même
  nécessaire de vérifier que troutes les sous-expressions apparaissant dans une
  instruction sont cohérentes ensemble.

  On note de la manière suivante le fait que sous l'environnement $Γ$
  l'instruction $i$ est bien typée :

  \[
    \tyi{Γ}{i}
  \]

\end{definition}

\begin{definition}[Typage d'une phrase]

  De par leur nature séquentielle, les phrases qui composent un programme
  altèrent l'environnement de typage. Par exemple, la déclaration d'une variable
  globale ajoute une valeur dans l'environnement.

  On note

  \[
    \typh{Γ}{S}{p}{Γ'}{S'}
  \]

  si le typage de la phrase $p$ transforme l'environnement $Γ, S$ en $Γ', S'$.

  On étend cette notation aux suites de phrases :

  \[
    \begin{cases}
      \typhstar{Γ}{S}{[]}{Γ}{S}  \\
      \typhstar{Γ}{S}{p::ps}{Γ'}{S'} \mbox{ si }
        ∃ Γ'', S'' ,
            \begin{cases}
              \typh{Γ}{S}{p}{Γ''}{S''}  \\
              \typhstar{Γ''}{S''}{ps}{Γ'}{S'}
            \end{cases}
    \end{cases}
  \]

\end{definition}

\begin{definition}[Typage d'un programme]

  Un programme est bien typé si on peut typer sa suite de phrases dans l'ordre
  en partant d'un environnement vide. C'est à dire s'il existe un environnement
  final $Γ_f, S_f$ tel que

  \[
    \typhstar{[]}{[]}{P}{Γ_f}{S_f}
  \]

  Cela est indépendant de tout environnement ; on note alors :

  \[
    ⊢ P
  \]

\end{definition}

\section{Expressions}

\subsection*{Littéraux}

Le typage des littéraux numériques ne dépend pas de l'environnement de typage :
ce sont toujours des entiers ou des flottants.

\begin{mathpar}

  \irule{Cst-Int}
    { }
    { Γ, S ⊢ i : \tInt}

  \irule{Cst-Float}
    { }
    { Γ, S ⊢ i : \tInt}

\end{mathpar}

Le pointeur nul, quant à lui, est compatible avec tous les types pointeur.

\begin{mathpar}
  \irule{Cst-Null}
    { }
    { Γ, S ⊢ \eNull : t*}
\end{mathpar}

\subsection*{Left-values}

Rappelons que l'environnement de typage $Γ$ contient le type des variables
accessibles du programme. Le cas où la left-value à typer est une variable est
donc direct : il suffit de retrouver son type dans l'environnement.

\begin{mathpar}
  \irule{Lv-Var}
    { (x, t) ∈ Γ }
    { Γ, S ⊢ x : t }
\end{mathpar}

Dans le cas d'un déréférencement, on commence par typer la left-value
déréférencée. Si elle a un type pointeur, la valeur déréférencée est le type
pointé.

\begin{mathpar}
  \irule{Lv-Deref}
    { Γ, S ⊢ lv : t* }
    { Γ, S ⊢ *lv : t }
\end{mathpar}

Pour une left-value indexée (l'accès à tableau), on s'assure que l'indice soit
entier, et que la left-value a un type tableau : le type de l'élement est encore
une fois le type de base du type tableau ($t$ pour $t[]$).

\begin{mathpar}
  \irule{Lv-Index}
    { Γ, S ⊢ e : \tInt \\
      Γ, S ⊢ lv : t[]
    }
    { Γ, S ⊢ lv[e] : t }
\end{mathpar}

Enfin, le typage de l'accès à un champ nécessite d'accéder à l'environnement de
structures $S$. L'existence d'un triplet $(s, f, t_f)$ tel que $lv$ est
typable en $t_s$ permet de typer $lv.f$ en $\tstruct{s}$.

\begin{mathpar}
  \irule{Lv-Field}
    { (s, f, t_f) ∈ S \\
      Γ, S ⊢ lv : \tstruct{s}
    }
    { Γ, S ⊢ lv.f : t_f }
\end{mathpar}

\subsection*{Opérateurs}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
\irule{Op-Int}{
  \opbin ∈ \{+,-,\times,/,\&,|,\opxor,\&\&,||,\ll,\gg \} \\
  Γ ⊢ e_1 : \tInt \\
  Γ ⊢ e_2 : \tInt
}{
  Γ ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
\irule{Op-Float}{
  \opbin ∈ \{+.,-.,\times.,/.\} \\
  Γ ⊢ e_1 : \tFloat \\
  Γ ⊢ e_2 : \tFloat
}{
  Γ ⊢ e_1~\opbin~e_2 : \tFloat
}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes de types
"comparables". On introduit donc un jugement $\textsc{Comparable}(τ)$ qui est
vrai pour les types \tInt, \tFloat et pointeurs. Les comparaisons renvoient
alors un \tInt.

\begin{mathpar}
\irule{Cmp-Num}
  {τ ∈ \{ \tInt, \tFloat \}}
  {\textsc{Comparable}(τ)}
\and
\irule{Cmp-Ptr}
  { }
  {\textsc{Comparable}(τ*)}
\and
\irule{Op-Cmp}{
  \opbin ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : τ \\
  Γ ⊢ e_2 : τ \\
  \textsc{Comparable}(τ)
}{
  Γ ⊢ e_1~\opbin~e_2 : \tInt
}
\end{mathpar}

Les opérateurs unaires "$+$" et "$-$" appliquent aux \tInt, et leurs équivalents
"$+.$" et "$-.$" aux \tFloat.

\begin{mathpar}
\irule{Unop-Plus-Int}{ Γ ⊢ e : \tInt }{ Γ ⊢ + e : \tInt }
\and
\irule{Unop-Plus-Float}{ Γ ⊢ e : \tFloat }{ Γ ⊢ +. e : \tFloat }

\irule{Unop-Minus-Int}{ Γ ⊢ e : \tInt }{ Γ ⊢ - e : \tInt }
\and
\irule{Unop-Minus-Float}{ Γ ⊢ e : \tFloat }{ Γ ⊢ -. e : \tFloat }
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
\irule{Unop-Not}{
  \opun ∈ \{ \sim, ! \} \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ \opun~e : \tInt
}
\end{mathpar}

L'arithmétique de pointeurs préserve le type.

\begin{mathpar}
\irule{Ptr-Arith}
  { \opbin ∈ \{ +_p, -_p \} \\
    Γ ⊢ e_1 : t* \\
    Γ ⊢ e_2 : \tInt \\
  }
  { Γ ⊢ e_1~\opbin~e_2 : t* }
\end{mathpar}

\subsection*{Autres expressions}

Prendre l'adresse d'une left-value rend un type pointeur sur le type de
celle-ci.

\begin{mathpar}
  \irule{Addr}
    { Γ, S ⊢ lv : t }
    { Γ, S ⊢ \&lv : t* }
\end{mathpar}

Pour typer une affectation, on vérifie que la left-value (à gauche) et
l'expression (à droite) ont le même type. C'est alors le type résultat de
l'expression d'affectation.

\begin{mathpar}
  \irule{Set}
    { Γ, S ⊢ lv : t \\
      Γ, S ⊢ e : t
    }
    { Γ, S ⊢ lv ← e : t }
\end{mathpar}

Un littéral tableau a pour type $t[]$ où $t$ est le type de chacun de ses
éléments.

\begin{mathpar}
  \irule{Array}
    { ∀ i, 1 ≤ i ≤ n ⇒ Γ, S ⊢ e_i : t }
    { Γ, S ⊢ \{ e_1 ;
            … ; e_n \}
            : t[]
    }
\end{mathpar}

Pour qu'un littéral de structure soit bien typé, il faut que chacun de ses noms
de champs corresponde à un même nom de type structure, avec le bon type pour
chaque champ.

\begin{mathpar}
  \irule{Struct}
    { ∀ i ∈ [1;n], Γ, S ⊢ e_i : t_i \\
      ∀ i ∈ [1;n], (s, f_i, t_i) ∈ S
    }
    { Γ, S ⊢ \{ f_1 : e_1 ;
            … ; f_n : e_n \}
            : \tstruct{s}
    }
\end{mathpar}

Pour typer un appel de fonction, on s'assure que la fonction a bien un type
fonctionnel. On type alors chacun des arguments avec le type attendu. Le
résultat est du type de retour de la fonction.

\begin{mathpar}
  \irule{Call}
    { Γ, S ⊢ f : ( t_1 ,
               … , t_n ) → t \\
      ∀ i ∈ [1;n], Γ, S ⊢ e_i : t_i
    }
    { Γ, S ⊢ f( e_1 ,
            … , e_n )
            : t
    }
\end{mathpar}

\section{Instructions}

La séquence est simple à traiter : l'instruction vide est toujours bien typée,
et la suite de deux instructions est bien typée si celles-ci le sont également.

\begin{mathpar}
  \irule{Pass}
    { }
    {Γ, S ⊢ \iPass}

  \irule{Seq}{
    Γ, S ⊢ i_1 \\
    Γ, S ⊢ i_2
  }{
    Γ, S ⊢ i_1;i_2
  }
\end{mathpar}

Une instruction constituée d'une expression est bien typée si celle-ci peut être
typée dans ce même contexte.

\begin{mathpar}
  \irule{Exp}
    { Γ ⊢ e : t }
    { Γ ⊢ e }
\end{mathpar}

Les constructions de contrôle sont bien typées si leurs sous-instructions sont
bien typées, et si la condition est d'un type entier.

\begin{mathpar}
  \irule{If}
    { Γ ⊢ e : \tInt \\
      Γ ⊢ i_1 \\
      Γ ⊢ i_2
    }
    { Γ ⊢ \iIf{e}{i_1}{i_2} }

  \irule{While}
    { Γ ⊢ e : \tInt \\
      Γ ⊢ i
    }
    { Γ ⊢ \iWhile{e}{i} }
\end{mathpar}

Enfin, un $\iReturn{\cdot}$ est bien typé si la valeur de retour est typable.

\begin{mathpar}
  \irule{Return}
    { Γ ⊢ e : t }
    { Γ ⊢ \iReturn{e} }
\end{mathpar}

\section{Fonctions}

% TODO comment le détecter pour typer la fonction ? faire une fausse lvalue ?

\begin{mathpar}

  \irule{Fun}
    { ?? }
    { Γ ⊢ f : (t_1, …, t_n) → t }

\end{mathpar}

\section{Phrases}

L'évaluation d'une expression est le cas le plus simple. En effet, il y a juste
à vérifier que celle-ci est bien typable (avec ce type) dans l'environnement de
départ. L'environnement n'est pas modifié.

\begin{mathpar}
  \irule{Ph-Exp}
    { Γ, S ⊢ e : t }
    { \typh{Γ}{S}{e}{Γ}{S} }
\end{mathpar}

La déclaration d'une variable globale commence de la même manière, mais on
enrichit l'environnement de cette nouvelle valeur.

\begin{mathpar}
  \irule{Ph-Var}
    { Γ, S ⊢ e : t \\
      Γ' = (x, t), Γ
    }
    { \typh{Γ}{S}{p}{Γ'}{S} }
\end{mathpar}

La déclaration d'une structure ne modifie pas $Γ$, mais ajoute $n$ triplets
$(x_i, t_i, s)$ à l'environnement de typage de structures $S$.

\begin{mathpar}
  \irule{Ph-Struct}
    { S' =
      (x_1, t_1, s),
      …
      (x_n, t_n, s), S
    }
    { \typh{Γ}{S}{ \tstruct{s}
                      \{ x_1 : t_1
                       ; …
                       ;  x_n : t_n
                      \}
                  }{Γ}{S'}
    }

\end{mathpar}

\begin{center}\rule{3in}{0.4pt}\end{center}

\section*{TODO}

\begin{itemize}
\item
  résoudre le problème du return
\end{itemize}
