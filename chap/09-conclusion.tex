On fait ici un bilan des travaux présentés, en commençant par un bilan des
contributions réalisées. On fait ensuite un tour des aspects posant problème, ou
traités de manière incomplète, en évoquant les travaux possibles pour enrichir
l'expressivité de ce système.

%On commence par décrire les
%limitations de \langname, au niveau de sa sémantique, de son système de types ou
%des étapes de traduction automatique depuis C.

\section{Contributions}

% TODO

\section{Limitations et travaux futurs}

\paragraph{Arithmétique}

En C, on dispose de plusieurs types entiers, pouvant avoir plusieurs tailles et
être signés ou non signés, ainsi que des types flottants qui diffèrent par leur
taille. Au contraire, en \langname on ne conserve qu'un seul type d'entier. La
raison pour cela est que nous ne nous intéressons pas du tout aux problématiques
de sémantique entière : les débordements, dénormalisations, etc, sont supposés
ne pas arriver.

Comme en C il n'est pas possible de définir de nouveaux types de base (des
entiers de 24 bits par exemple), il est facile d'étendre le système de types de
\langname pour ajouter tous ces nouveaux types. La traduction depuis Newspeak
insère déjà des opérateurs de transtypage pour lesquels il est facile de donner
une sémantique (pouvant lever une erreur en cas de débordement, comme en Ada) et
un typage. Les littéraux numériques peuvent poser problème, puisqu'ils
deviennent alors polymorphes. Une solution peut être de leur donner le plus
grand type entier et d'insérer un opérateur de transtypage à chaque littéral.
Haskell utilise une solution similaire : les littéraux entier ont le type de
précision arbitraire \texttt{Integer} et est converti dans le bon type en
appelant la fonction \texttt{fromInteger} du type synthétisé à partir de
l'environnement.

\paragraph{Transtypage}

Puisque l'approche retenue est basée sur le typage statique, il est impossible
de capturer de nombreuses constructions qui sont possibles, ou même idiomatiques
en C : les unions, les conversions de types (explicites ou implicites) et le
\emph{type punning} (défini ci-desosus). Les deux premières sont équivalentes.
Bien qu'on puisse remplacer chaque conversion explicite d'un type $t_1$ vers un
type $t_2$ par l'appel à une fonction $\mathrm{cast}_{t_1,t_2}$, on ajoute alors
un ``trou'' dans le système de types. Cette fonction devrait en effet être typée
$(t_1) → t_2$, autrement dit le type ``maudit'' $α → β$ de \texttt{Obj.magic} en
OCaml ou \texttt{unsafeCoerce} en Haskell.

Le \emph{type punning} consiste à modifier directement la suite de bits de
certaines données pour la manipuler d'une manière efficace. Par exemple, il est
commun de définir un ensemble de macros pour accéder à la mantisse et à
l'exposant de flottants IEEE754. Ceci peut être fait avec des unions ou des
masques de bits.

Dans de tels cas, le typage statique est bien sûr impossible. Pour traiter ces
cas, il faudrait encapsuler la manipulation dans une fonction et y ajouter une
information de type explicite, comme $\texttt{float\_exponent} : (\tFloat) →
\tInt$.

En fait, les casts entre types entiers ne posent pas de problèmes. Ceux entre
types pointeurs ne posent pas de problème non plus puisqu'au moment de la
traduction en \langname on efface les étiquettes de types sur les pointeurs.

Mais les casts entre entiers et pointeurs posent problème. Si on autorise les
casts, on peut néanmoins trouver le solution suivante.

\begin{mathpar}
\irule{PtrInt-Bad}
  { Γ ⊢ e : t~q~*}
  { Γ ⊢ (\tInt)~e : \tInt }

\irule{IntPtr-Bad}
  { Γ ⊢ e : \tInt }
  { Γ ⊢ (\textsc{Ptr})~e : t~q~*}
\end{mathpar}

Cela pose problème car il est alors possible de créer une fonction qui convertit
n'importe quel type pointeur en n'importe quel autre type pointeur :

\[
  ⊢ \eFun{p}{ \iReturn{(\textsc{Ptr})~(\tInt)~p} }
  : (t_a~q_a~*) → t_b~q_b~*
\]

% TODO et à l'exec?
% TODO on peut faire un dynamic check ou un type UInt ou un qualif sur tous les
% types

% TODO le modèle mémoire de Newspeak est bcp plus bas niveau que celui de
% Safespeak, ex types de deref, tailles dans Lv etc

L'opération problématique est en fait l'opérateur $(\tInt)$ de conversion d'un
pointeur vers un entier, car l'entier résultant ne pose pas de problème de
sûreté ni de sécurité. Pour lui donner une sémantique, on peut supposer que
l'environnement d'exécution est paramétré par une fonction de placement en
mémoire $\addrInt : Φ → \tInt$ qui à un chemin associe un entier.
On étend alors la sémantique par la règle suivante.

% TODO [E] ??

\[
  \irule{CastInt}
    { }
    { \mms{(\tInt)~\widehat{\&}φ}{\addrInt(φ)} }
\]

% TODO nommer les ensembles
% TODO mettre la syntaxe en annexe

Quant au transtypage dans le sens inverse, il est plus compliqué à traiter.
À l'exécution il est en effet nécessaire d'avoir à disposition une fonction
$\interpPtr{t~q~*} : \tInt → t~q~*$ qui permette d'interpréter un entier comme
pointeur qualifié $q$ vers un objet de type $t$ de manière qu'on ajoute la règle
suivante.

\[
  \irule{CastPtr}
    { }
    { \mms{(\textsc{Ptr})~\widehat{n}}{\interpPtr{t~q~*}(\widehat{n})} }
\]

% TODO les widehat...
% TODO [E] ??

L'exécution de l'analogue de $\addrInt$ demanderait de créer un pointeur
depuis un entier.

% TODO il n'y a pas de t q en mémoire, doncil faut juste un interp : Int -> Φ
% TODO problème car ça peut correspondre à plusieurs pointeurs
% TODO problème de layout mémoire : ça marche qd tout est boxé mais pas si c'est
% unboxé

La solution la plus sûre est donc d'interdire totalement ces conversions.

\paragraph{Environnement d'exécution}

La sémantique opérationnelle utilise un environnement d'exécution pour certains
cas. Contrairement à C, les débordements de tampon et les déréférencements de
pointeurs sont vérifiés dynamiquement. Mais ce n'est pas une caractéristique
cruciale de cette approche : en effet, si on suppose que les programmes que l'on
analyse sont corrects de ce point de vue, on peut désactiver ces vérifications
et le reste des propriétés est toujours valable.

Un autre endroit, plus problématique, où des tests dynamiques sont faits est
lorsqu'on recherche en mémoire des pointeurs référençant un cadre d'appel qui
n'est plus valide (à l'aide de l'opérateur $\mathrm{Cleanup}(\cdot)$). Supprimer
ce test rend l'analyse incorrecte, car il est alors possible de faire référence
à une variable avec un type différent.

De même, si on peut avoir une garantie statique que les adresses des variables
locales ne seront plus accessibles au retour d'une fonction, alors on peut
supprimer le nettoyage en posant $\mathrm{Cleanup}(m) = m$. Cette garantie peut
être obtenue avec une analyse statique préalable~\cite{ifm10}.

\paragraph{Allocation dynamique}

La plupart des programmes, et le noyau Linux en particulier, utilisent la notion
d'allocation dynamique de mémoire. C'est une manière de créer dynamiquement une
zone de mémoire qui restera accessible après l'exécution de la fonction
courante. Cette mémoire pourra être libérée à l'aide d'une fonction dédiée. Dans
l'espace utilisateur, les programmes peuvent utiliser les fonctions
\texttt{malloc()}, \texttt{calloc()}, et \texttt{realloc()} pour allouer des
zones de mémoire et \texttt{free()} pour les libérer. Dans le noyau Linux, ces
fonctions existent sous la forme de \texttt{kmalloc()}, \texttt{kfree()}, etc.
Une explication détaillée de ces mécanismes peut être trouvée
dans~\cite{LinuxVMM}.

Ces fonctions manipulent les données en tant que zones mémoires opaques, à
en renvoyant un pointeur vers une zone mémoire d'un nombre d'octets donnés.
Cela présuppose un modèle mémoire plus bas niveau. Pour se rapprocher de la
sémantique de \langname, une manière de faire est de définir un opérateur de
plus haut niveau prenant une expression et retournant l'adresse d'une cellule
mémoire contenant cette valeur. Le typage est alors direct :

% TODO [E] sous entendu il y a un sizeof(t)

\begin{mathpar}
  \irule{Malloc}
    { Γ ⊢ e : t }
    { Γ ⊢ \textsc{Alloc}(e) : t~\qKernel~* }

  \irule{Free}
    { Γ ⊢ e : t~\qKernel~* }
    { Γ ⊢ \textsc{Free}(e) }
\end{mathpar}

En ce qui concerne l'exécution, on peut ajouter une troisième composante aux
états mémoire : $m = (s, g, h)$ où $h$ associe à une étiquette numérique une
valeur (comme les globales mais indexées par des entiers plutôt que par leur
nom). La libération de mémoire est problématique parce qu'il faut faire
confiance au programmeur pour ne pas accéder aux zones mémoires libérées. Encore
une fois, on peut utiliser une analyse préalable comme~ \cite{ifm10}. Il est sûr
(mais pas possible en pratique) d'ignorer les commandes de libérations de
mémoire. 

% TODO [E] pointeurs fantômes

\paragraph{Structures récursives}

Une autre limitation est que seules les structures simples sont supportées. Les
structures récursives, contenant un pointeur vers un objet du même type
structure, ne sont pas typables. La raison est syntaxique : l'accès à un champ
est noté $lv.l_S$ afin d'avoir à disposition le type complet de la structure.

% TODO [E] bigre!!!

Par exemple, une liste chaînée d'entiers peut être décrite de la manière
suivante en C :

\begin{verbatim}
struct int_list {
    int value;
    struct int_list *next;
};
\end{verbatim}

% TODO et les listes chainées de Linux ? safety + typage

La compilation est possible car la définition complète de \texttt{struct
int\_list} n'est pas nécessaire pour connaître la taille d'un pointeur vers un
objet de ce type.

Pour compiler \texttt{l.next} en \langname, il faudrait écrire le type en
extension :

\[
  l.next_{ value:\tInt ; next : \{ value : \tInt ; next : … \}~*}
\]

On peut fermer cette récursion infinie en ajoutant directement un opérateur de
point fixe qui rend accessible le type d'un pointeur vers le type structure en
train d'être défini.

\begin{align*}
    S \gramisa & … \gramorx \mathrm{fix}(p → S)
\end{align*}

On écrit alors :

\[
  l.next_{ \mathrm{fix}(p → \{ value : \tInt ; next : p \}) }
\]

Les structures mutuellement récursives peuvent être également exprimées de cette
manière.

\begin{verbatim}
struct a {
    int value;
    struct b *next;
};

struct b {
    float value;
    struct a *next;
};
\end{verbatim}

Ces structures sont respectivement traduites en :

\begin{align*}
  A &= \mathrm{fix} (p → \{ value : \tInt   ; next : \{ value : \tFloat ; next : p \}~* \}) \\
  B &= \mathrm{fix} (p → \{ value : \tFloat ; next : \{ value : \tInt   ; next : p \}~* \})
\end{align*}

Ce schéma suffit à compiler toutes les types de structures possibles en C. En
effet, les seuls cas posant problème arrivent lorsqu'on fait référence à la
structure en cours de définition ; et il n'est alors possible que d'y accéder
par pointeur.

\paragraph{Assembleur}

Comme la plupart des outils d'analyse de code C, il est impossible de traiter
l'assembleur en ligne qui peut se trouver entre deux instructions. Dans le cas
de Linux, le code est fait pour être portable, et les parties dépendantes d'une
certaine architecture (et donc le code assembleur) sont isolées explicitement.
On peut alors si nécessaire ajouter une annotation de type sur une fonction dont
l'implantation est faite en assembleur, mais au sein de cette implantation on ne
peut bien sûr rien dire.

\paragraph{Analyse du noyau Linux}

Ici nous avons présenté l'analyse expérimentale d'une fonction problématique
d'une interface programmation particulière. Mais le principe de l'analyse est
applicable à toutes les fonctions de traitement d'\texttt{ioctl}s des pilotes
KMS, et même à toutes les fonctions faisant partie des différentes interfaces
recevant un pointeur de l'espace utilisateur.

\paragraph{Autres types abstraits}

Notre approche est basée sur le fait de rendre abstrait un type de C et
d'y interdire certaines opérations : ici, on marque un certain type de pointeur
comme ``utilisateur'' et on interdit l'opérateur \texttt{*} dessus.

Le langage C n'ayant pas de types abstraits
\footnote{
  La seule abstraction possible est lorsqu'on manipule une structure par
  pointeur. Il n'est alors pas nécessaire de connaître sa définition totale.
  L'idiome est alors de placer uniquement une déclaration en avance
  (\texttt{struct s;}) dans l'en-tête (\texttt{.h}) et de renseigner
  la définition complète dans l'implantation (\texttt{.c}).
}
, on ne peut pas séparer la réprésentation d'un type (par exemple : entier signé
de 32 bits) des opérations qui y sont attachées.

Dans de nombreuses interfaces, on emploie des types entiers qui servent
d'étiquettes. Par exemple, les descripteurs de fichiers renvoyés par la fonction
\texttt{open()} et passés au fonctions \texttt{read()} et \texttt{write()} ont
le type \texttt{int}. Le langage autorise donc par exemple de multiplier entre
eux deux descripteurs de fichiers, ce qui ne correspond pas à une opération
concrète.

On peut aussi distinguer plusieurs types abstraits entre eux. Par exemple, si un
encodeur vidéo manipule des numéros de \emph{frame} et des identifiants de codec
tous les deux entiers, on peut interdire d'utiliser avec un identifiant de codec
une fonction prenant en paramètre un numéro de \emph{frame}.
