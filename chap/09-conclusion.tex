On fait ici un bilan des travaux présentés, en commençant par un bilan des
contributions réalisées. On fait ensuite un tour des aspects posant problème, ou
traités de manière incomplète, en évoquant les travaux possibles pour enrichir
l'expressivité de ce système.

% TODO liens EADS


\section{Contributions}

\paragraph{Un langage impératif bien typé}

Le système de types de C est trop rudimentaire pour permettre d'obtenir des
garanties sur l'exécution des programmes bien typés. En interdisant certaines
constructions dangereuses et en en annotant certaines, nous avons isolé un
langage impératif bien typable, pour lequel on peut définir un système de types
sûr.

\paragraph{Une sémantique basée sur les lentilles}

Une des particularités de ce langage impératif est qu'il utilise un état mémoire
structuré, modélisant les cadres de piles présents dans le langage. Pour décrire
la sémantique des accès mémoire, nous utilisons le concept de lentilles issues
de la programmation fonctionnelle et des systèmes de base de données. Cela
permet de définir de manière déclarative la modification en profondeur de
valeurs dans la mémoire, sans avoir à distinguer le cas de la lecture et celui
de l'écriture.

\paragraph{Un système de types abstraits}

En partant de ce système de types, on a décrit une extension permettant de créer
des pointeurs pour lesquels l'opération de déréférencement est restreinte à
certaines fonctions. Dans le contexte d'un noyau de système d'exploitation,
cette restriction permet de vérifier statiquement qu'à aucun moment le noyau ne
déréférence un pointeur dont la valeur est contrôlée par l'espace utilisateur,
évitant ainsi un problème de sécurité. Cette approche peut s'étendre à d'autres
classes de problèmes comme par exemple éviter l'utilisation de certaines
opérations sur les types entiers lorsqu'ils sont utilisés comme identificateurs
ou masque de bits.

\paragraph{Un prototype d'analyseur statique}

Les analyses de typage ici décrites ont été implantées sous forme d'un prototype
d'analyseur statique distribué avec le langage Newspeak.
D'une part, cela permet de vérifier la propriété d'isolation des appels système
sur du code C existant, et d'autre part cela fournit une base saine pour
implanter d'autres analyses de typage sur le langage Newspeak.
D'autre part, ce prototype a été utilisé pour confirmer l'existence d'un bug
dans le noyau Linux, ce qui permet de valider l'approche: il est possible de
vérifier du code de production à l'aide de techniques de typage.

\section{Différences avec C}

\langname a été construit pour pouvoir ajouter un système de types à un langage
proche de C. Ces deux langages diffèrent donc sur certains points. On détaille
ici ces différences et selon les cas, comment les combler ou pourquoi cela est
impossible de manière inhérente.

\paragraph{Arithmétique}

En C, on dispose de plusieurs types entiers, pouvant avoir plusieurs tailles et
être signés ou non signés, ainsi que des types flottants qui diffèrent par leur
taille. Au contraire, en \langname{} on ne conserve qu'un seul type d'entier et
un seul type de flottant. La raison pour cela est que nous ne nous intéressons
pas du tout aux problématiques de sémantique entière: les débordements,
dénormalisations, etc, sont supposés ne pas arriver.

Il est possible d'étendre le système de types de \langname{} pour ajouter tous
ces nouveaux types. La traduction depuis Newspeak insère déjà des opérateurs de
transtypage pour lesquels il est facile de donner une sémantique (pouvant lever
une erreur en cas de débordement, comme en Ada) et un typage. Les littéraux
numériques peuvent poser problème, puisqu'ils deviennent alors polymorphes. Une
solution peut être de leur donner le plus grand type entier et d'insérer un
opérateur de transtypage à chaque littéral. Haskell utilise une solution
similaire: les littéraux entier ont le type de précision arbitraire
\texttt{Integer} et est converti dans le bon type en appelant la fonction
\texttt{fromInteger} du type synthétisé à partir de l'environnement.

\paragraph{Transtypage et unions}

Puisque l'approche retenue est basée sur le typage statique, il est impossible
de capturer de nombreuses constructions qui sont possibles, ou même idiomatiques
en C:\@ les unions, les conversions de types (explicites ou implicites) et le
\emph{type punning} (défini ci-dessous). Les deux premières sont équivalentes.
Bien qu'on puisse remplacer chaque conversion explicite d'un type $t_1$ vers un
type $t_2$ par l'appel à une fonction $\mathrm{cast}_{t_1,t_2}$, on ajoute alors
un «trou» dans le système de types. Cette fonction devrait en effet être typée
$(t_1) → t_2$, autrement dit le type «maudit» $α → β$ de \texttt{Obj.magic} en
OCaml ou \texttt{unsafeCoerce} en Haskell.

Le \emph{type punning} consiste à modifier directement la suite de bits de
certaines données pour la manipuler d'une manière efficace. Par exemple, il est
commun de définir un ensemble de macros pour accéder à la mantisse et à
l'exposant de flottants IEEE754. Ceci peut être fait avec des unions ou des
masques de bits.

Dans de tels cas, le typage statique est bien sûr impossible. Pour traiter ces
cas, il faudrait encapsuler la manipulation dans une fonction et y ajouter une
information de type explicite, comme $\texttt{float\_exponent} : (\tFloat) →
\tInt$.

Pour ces conversions de types, on distingue en fait plusieurs cas: les
conversions entre types numériques, entre types pointeurs, ou entre un type
entier et un type pointeur.

Le premier ne pose pas de problème: il est toujours possible de donner une
sémantique à une conversion entre deux types numériques. Dans le cas éventuel ou
une conversion n'est pas possible, on peut signaler une erreur à l'exécution (de
la même nature qu'une divition par zéro).

Le deuxième non plus n'est pas un problème en soi: une conversion entre deux
types pointeurs revient à convertir entre les types pointés.

Le vrai problème provient des conversions entre entiers et pointeurs, qui sont
des données fondamentalement différentes. Le même problème se pose d'ailleurs si
on cherche à convertir une fonction en entier ou en pointeur, même si les
raisons valables pour faire cela sont moins nombreuses.
Si on s'en tient aux conversions entre entiers et pointeurs, une manière naïve
de typer ces opération est:

\begin{mathpar}
\irule{PtrInt-Bad}
  { Γ ⊢ e : \ptrK{t}}
  { Γ ⊢ (\tInt)~e : \tInt }

\irule{IntPtr-Bad}
  { Γ ⊢ e : \tInt }
  { Γ ⊢ (\textsc{Ptr})~e : \ptrK{t}}
\end{mathpar}

Tout d'abord, cela pose problème car il est alors possible de créer une fonction
qui convertit n'importe quel type pointeur en n'importe quel autre type
pointeur:

\begin{align*}
  ⊢ &~ \eFun{p}{ \iReturn{(\textsc{Ptr})~(\tInt)~p} } \\
  : &~ (\ptrK{t_a}) → \ptrK{t_b}
\end{align*}

Si on crée une variable du type $t_a$, prend son adresse, la convertit à l'aide
de cette fonction, puis déréférence le résultat, on obtient une valeur du type
$t_b$ (remarquons que ce genre d'opération est tout à fait possible en C).

Outre ce problème de typage, il faudrait pouvoir donner une sémantique à ces
opérations. Convertir un pointeur en entier revient à spécifier l'environnement
d'exécution, c'est-à-dire qu'il faut une fonction de placement en mémoire
beaucoup plus précise que notre modèle mémoire actuel. Celle-ci dépend de
beaucoup de paramètres: dans quel sens croit la pile, quelle est la taille des
types, etc.

La conversion dans le sens inverse, d'entier vers pointeur, est encore plus
complexe. Entre autres, cela suppose qu'on puisse retrouver la taille des
valeurs à partir de leur adresse. Dans de nombreux langages, on résout ce
problème en ajoutant la taille de chaque valeur avec elle.

Mais cela fait s'éloigner du modèle mémoire de C, où le déréférencement porte
sur une adresse mais également sur une taille (portée implicitement par le type
du pointeur). D'ailleurs le langage \newspeak{} conserve cette distinction, que
nous avons éliminée dans \langname. Il y a une incompatibilité entre ces deux
approches : dans le cas de C (et de \newspeak), on laisse le programmeur gérer
l'organisation de la mémoire alors qu'avec \langname ces choix sont faits par le
langage. En contrepartie, cela permet d'avoir d'assurer la sûreté du typage.

\paragraph{Environnement d'exécution}

La sémantique opérationnelle utilise un environnement d'exécution pour certains
cas. Contrairement à C, les débordements de tampon et les déréférencements de
pointeurs sont vérifiés dynamiquement. Mais ce n'est pas une caractéristique
cruciale de cette approche: en effet, si on suppose que les programmes que l'on
analyse sont corrects de ce point de vue, on peut désactiver ces vérifications
et le reste des propriétés est toujours valable.

Un autre endroit, plus problématique, où des tests dynamiques sont faits est
lorsqu'on recherche en mémoire des pointeurs référençant un cadre d'appel qui
n'est plus valide (à l'aide de l'opérateur $\mathrm{Cleanup}(\cdot)$). Supprimer
ce test rend l'analyse incorrecte, car il est alors possible de faire référence
à une variable avec un type différent.

De même, si on peut avoir une garantie statique que les adresses des variables
locales ne seront plus accessibles au retour d'une fonction, alors on peut
supprimer le nettoyage en posant $\mathrm{Cleanup}(m) = m$. Cette garantie peut
être obtenue avec une analyse statique préalable~\cite{ifm10}.

\paragraph{Allocation dynamique}

La plupart des programmes, et le noyau Linux en particulier, utilisent la notion
d'allocation dynamique de mémoire. C'est une manière de créer dynamiquement une
zone de mémoire qui restera accessible après l'exécution de la fonction
courante. Cette mémoire pourra être libérée à l'aide d'une fonction dédiée. Dans
l'espace utilisateur, les programmes peuvent utiliser les fonctions
\verb!malloc()!, \verb!calloc()!, et \verb!realloc()! pour allouer des zones de
mémoire et \verb!free()! pour les libérer. Dans le noyau Linux, ces fonctions
existent sous la forme de \verb!kmalloc()!, \verb!kfree()!, etc. Une explication
détaillée de ces mécanismes peut être trouvée dans~\cite{LinuxVMM}.

Ces fonctions manipulent les données en tant que zones mémoires opaques, en
renvoyant un pointeur vers une zone mémoire d'un nombre d'octets donnés. Cela
présuppose un modèle mémoire plus bas niveau. Pour se rapprocher de la
sémantique de \langname, une manière de faire est de définir un opérateur de
plus haut niveau prenant une expression et retournant l'adresse d'une cellule
mémoire contenant cette valeur (la taille de chaque valeur fait partie de
celle-ci). Le typage est alors direct:

\begin{mathpar}
  \irule{New}
    { Γ ⊢ e : t }
    { Γ ⊢ \textsc{New}(e) : \ptrK{t} }

  \irule{Free}
    { Γ ⊢ e : \ptrK{t} }
    { Γ ⊢ \textsc{Free}(e) }
\end{mathpar}

En ce qui concerne l'exécution, on peut ajouter une troisième composante aux
états mémoire: $m = (s, g, h)$ où $h$ est une liste d'association entre des
entiers et des valeurs. Chaque allocation dynamique crée une nouvelle clef
entière et met à jour $h$. La libération de mémoire est en revanche
problématique parce qu'il faut faire confiance au programmeur pour ne pas
accéder aux zones mémoires libérées. Encore une fois, on peut utiliser une
analyse préalable comme~\cite{ifm10}. Il est sûr (mais pas possible en pratique)
d'ignorer les commandes de libération de mémoire.

% TODO régions

\paragraph{Structures récursives}

% TODO est-ce que cela empêche l'imbrication? types rec/ vals rec

% TODO[S] Si tu l'as résolu alors pourquoi le mettre ici?

Une autre limitation est que seules les structures simples sont supportées. Les
structures récursives, contenant un pointeur vers un objet du même type
structure, ne sont pas typables. La raison est syntaxique: l'accès à un champ
est noté $lv.l_S$ afin d'avoir à disposition le type complet de la structure.

Par exemple, une liste chaînée d'entiers peut être décrite de la manière
suivante en C:\@

\begin{verbatim}
struct int_list {
    int value;
    struct int_list *next;
};
\end{verbatim}

% TODO et les listes chainées de Linux ? safety + typage

La compilation est possible car la définition complète de \texttt{struct
int\_list} n'est pas nécessaire pour connaître la taille d'un pointeur vers un
objet de ce type.

Pour compiler \texttt{l.next} en \langname, il faudrait écrire le type en
extension:

\[
  l.next_{ value:\tInt ; next : \{ value : \tInt ; next : … \}~*}
\]

On peut fermer cette récursion infinie en ajoutant directement un opérateur de
point fixe qui rend accessible le type d'un pointeur vers le type structure en
train d'être défini.

\begin{align*}
    S \gramisa & … \gramorx \mathrm{fix}(p → S)
\end{align*}

On écrit alors:

\[
  l.next_{ \mathrm{fix}(p → \{ value : \tInt ; next : p \}) }
\]

Les structures mutuellement récursives peuvent être également exprimées de cette
manière.

\begin{verbatim}
struct a {
    int value;
    struct b *next;
};

struct b {
    float value;
    struct a *next;
};
\end{verbatim}

Ces structures sont respectivement traduites en:

\begin{align*}
  A &= \mathrm{fix} (p → \{ value : \tInt   ; next : \{ value : \tFloat ; next : p \}~* \}) \\
  B &= \mathrm{fix} (p → \{ value : \tFloat ; next : \{ value : \tInt   ; next : p \}~* \})
\end{align*}

Ce schéma suffit à compiler tous les types de structures possibles en C. En
effet, les seuls cas posant problème arrivent lorsqu'on fait référence à la
structure en cours de définition; et il n'est alors possible que d'y accéder par
pointeur.

\paragraph{Assembleur}

Comme la plupart des outils d'analyse de code C, il est impossible de traiter
l'assembleur en ligne qui peut se trouver entre deux instructions. Dans le cas
de Linux, le code est fait pour être portable, et les parties dépendantes d'une
certaine architecture (et donc le code assembleur) sont isolées explicitement.
On peut alors si nécessaire ajouter une annotation de type sur une fonction dont
l'implantation est faite en assembleur, mais au sein de cette implantation on ne
peut bien sûr rien dire. De plus, le corps de cette fonction n'est pas
couverte par la sûreté du typage: après son exécution on ne peut plus rien
garantir sur le programme.

\paragraph{Analyse du noyau Linux}

Ici nous avons présenté l'analyse expérimentale d'une fonction problématique
d'une interface programmation particulière. Mais le principe de l'analyse est
applicable à toutes les fonctions de traitement d'\texttt{ioctl}s des pilotes
KMS, et même à toutes les fonctions faisant partie des différentes interfaces
recevant un pointeur de l'espace utilisateur.

\paragraph{Autres types abstraits}
%TODO[S] ??

Notre approche est basée sur le fait de rendre abstrait un type de C et
d'y interdire certaines opérations: ici, on marque un certain type de pointeur
comme «utilisateur» et on interdit l'opérateur \texttt{*} dessus.

Le langage C n'ayant pas de types abstraits, on ne peut pas séparer la
représentation d'un type (par exemple: entier signé de 32 bits) des opérations
qui y sont attachées. La seule abstraction possible est lorsqu'on manipule une
structure par pointeur. Il n'est alors pas nécessaire de connaître sa définition
totale. L'idiome est alors de placer uniquement une déclaration en avance
(\texttt{struct s;}) dans l'en-tête (\texttt{.h}) et de renseigner la définition
complète dans l'implantation (\texttt{.c}). Cette technique de \emph{pointeurs
opaques} n'est pas applicable aux autres types.

Dans de nombreuses interfaces, on emploie des types entiers qui servent
d'étiquettes. Par exemple, les descripteurs de fichiers renvoyés par la fonction
\verb!open()! et passés au fonctions \verb!read()! et \verb!write()! ont
le type \texttt{int}. Le langage autorise donc par exemple de multiplier entre
eux deux descripteurs de fichiers, ce qui ne correspond pas à une opération
concrète.

On peut aussi distinguer plusieurs types abstraits entre eux. Par exemple, si un
encodeur vidéo manipule des numéros de \emph{frame} et des identifiants de codec
tous les deux entiers, on peut interdire d'utiliser avec un identifiant de codec
une fonction prenant en paramètre un numéro de \emph{frame}.

% TODO il serait pas mal de citer les membres du jury dans ta biblio

% TODO[S] et d'autres classes de propriété de sécurité ? Plus fonctionnelles par
% ex?

\section{Conclusion}

% TODO

% vim: spelllang=fr
