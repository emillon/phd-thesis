\section{Limitations}

Our system has several limitations.

First, as we used static typing, it is impossible to capture a lot of constructs
that are possible or even idiomatic in C: unions, type casts, type punning. The
first two ones are equivalent constructs. We can replace each cast from a type
$t_1$ to a type $t_2$ by the call of a function $\mathrm{cast}_{t_1,t_2}$ but
this means adding a flaw in the type system: it would be typed $(t_1) → t_2$,
in other words the dreaded type $α → β$ of \texttt{Obj.magic} in OCaml
or \texttt{unsafeCoerce} in Haskell.

Type punning consists in modifying the bit pattern of some data to manipulate it
in an efficient way. For example, it is common to define a set of macros to
access low-level parts of IEEE754 floats, for exemple their exponent. Usually, a
combination of unions and bit masks is used. In such cases, strong typing is of
course impossible. To handle this, we could wrap the manipulation in a macro and
add an explicit type information such as $\texttt{float\_exponent} : (\tFloat) →
\tInt$.

The operational semantics uses runtime support for several cases. Contrary to C,
we dynamically check for buffer overflows and \eNull dereference, but this is
not critical to our approach: if we suppose that the programs we analyze are
correct with respect to these properties, we could provide a lower-level
implementation without those checks.

A more concerning place where we add a runtime behaviour is when the memory is
searched for dangling pointers at every function return (with the
$\mathrm{Cleanup(\cdot)}$ operator). Removing this check makes the analysis
unsound, because it is then possible to make reference to the current stack
frame with a former one. However, contrary to type punning, there are few cases
where such a behaviour is desired. If we can have a static guarantee that the
address of a local variable will not be accessible after the function has
returned, we can remove the $\mathrm{Cleanup(\cdot)}$ step. This can be done
with a dedicated static analysis\cite{ifm10}.

Dynamic memory allocation, embodied in userspace by the \texttt{malloc()} and
\texttt{free()} functions, has not been implemented. Similarly to
\texttt{get\_\{from,to\}\_user()}, it manipulates data as memory zones, with a
pointer and a size in bytes. We would have to define a higher level operator
taking an expression and returning the address of a freshly allocated cell in a
heap. Then typing is straightforward:

{ \small
\begin{mathpar}
  \inferrule*
    { Γ ⊢ e : t }
    { Γ ⊢ \textsc{Alloc}(e) : t~\qKernel~* }

  \inferrule*
    { Γ ⊢ e : t~\qKernel~* }
    { Γ ⊢ \textsc{Free}(e) }
\end{mathpar}}%

To define evaluation, we can expand the memory states to include an explicit
heap of values, mapping unique labels to values. Deallocation is problematic
because we rely on the programmer not to access deallocated memory zones. Once
again, it is possible to dedicate an analysis like~\cite{ifm10} to enforce this.
It is also sound, albeit impractical, to ignore deallocation constructs.

Another limitation is that our system does not allow recursive structures,
containing a pointer to a field of the same type. For simple (not mutually)
recursive structures, it is possible to extend the grammar of type annotation to
allow the following, where $p$ binds a pointer type to the structure.

{\small \[
    S \gramisa … \gramorx \mathrm{fix}(p → S)
\]}%

\section{Future work}

We showed that type theory can be a useful tool for verifying the absence of
certain run-time properties. While adding static labels to variables seems to be
a crude approximation of reality, in some cases it has enough power to capture
real-world problems.

In this particular example, we work around C's lack of abstract types in order
to disallow dereference for a certain class of pointers, distinguished by
syntactic rules.

We defined an imperative language with an explicit stack, and described
operational semantics for it modelling that of the C programming language. It
includes a memory model that expresses the separation between user and kernel
spaces present in most operating systems. We added a type system that is sound
with respect to a property of isolation between this two memory spaces.

Finally, we demonstrate an implementation on this analysis on a bug that
affected the Linux kernel.

A first step towards making this analysis more practical is to demonstrate its
scalability by running it on larger fragments of the kernel.

There are also several places where we can improve significantly the
expressivity of our type system. For example, our current type system is only
monomorphic; but it would make sense to generalize free qualifier variables in
the type of global functions.
