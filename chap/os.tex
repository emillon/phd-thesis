\section{Rôle d'un système d'exploitation}

% Fig Archi {{{
\begin{figure}
\centering
\input{fig/archi-simplifiee.tex}
\caption{Architecture simplifiée d'un ordinateur}
\label{fig:archi-simplifiee}
\end{figure}
% }}}

Au plus bas, un ordinateur est constitué de nombreux composants matériels :
micro-processeur, mémoire, et divers périphériques
(figure~\ref{fig:archi-simplifiee}). Et au niveau de l'utilisateur, de dizaines
de logiciels permettant d'effectuer toutes sortes de calculs et de
communication. Le système d'exploitation permet de faire l'interface entre ces
niveaux d'abstraction. Dans ce chapitre nous allons voir son rôle et une
implantation possible. Pour une description plus détaillée, on pourra se référer
à l'ouvrage \cite{tanenbaum}.

Au cours de l'histoire des systèmes informatiques, la manière de les programmer
a beaucoup évolué. Au départ, les programmeurs avaient accès au matériel dans
son intégralité : toute la mémoire pouvait être accédé, toutes les instructions
pouvaient être utilisées.

Néanmoins c'est un peu restrictif : si on est seul à utiliser un système, on est
par définition... seul à pouvoir l'utiliser. Dans la seconde moitié des années
60, sont apparus les premiers systèmes "à temps partagé", permettant à plusieurs
utilisateurs de travailler en même temps.

Permettre l'exécution de plusieurs programmes en même temps est une idée
révolutionnaire, mais elle n'est pas sans difficultés techniques : en effet les
ressources de la machine doivent être aussi partagées entre les utilisateurs et
les programmes. Par exemple, plusieurs programmes vont par exemple utiliser le
CPU les uns à la suite des autres (partage \emph{temporel}) ; et chaque
programme aura à sa disposition une partie de la mémoire principale, ou du
disque dur (partage \emph{spatial}).

Si deux programmes (ou plus) s'exécutent de manière concurrente sur le même
matériel, il faut s'assurer par exemple que les deux s'exécutent à peu près
aussi souvent, ou que l'un ne puisse pas écrire dans la mémoire de l'autre. Ce
sont des rôles du système d'exploitation.

Cela passe donc par un certain bridage des possibilités du programme : plutôt
que de le faire exécuter n'importe quel type d'instruction, il communique avec
le système d'exploitation. Bien que cela ait l'air d'une limitation, c'est aussi
bénéfique pour le programmeur puisque cela permet de définir des abstractions au
niveau du noyau.

Par exemple, si un programmeur veut copier des données depuis un CD-ROM vers la
mémoire principale, il devra interroger le bus SATA, interroger le lecteur sur
la présence d'un disque dans le lecteur, activer le moteur, calculer le numéro
de \emph{frame} des données sur le disque, demander la lecture, puis déclencher
une copie de la mémoire.

Si dans un autre cas il voulait récupérer des données depuis une mémorette USB,
il devrait interroger le bus USB, rechercher le bon numéro de périphérique, le
bon \emph{endpoint} dans celui-ci, lui appliquer une commande de lecture au bon
numéro de bloc, puis copier la mémoire.

Ces deux opérations, bien qu'elles aient le même but (copier de la mémoire
depuis un périphérique amovible), ne sont pas effectuées en pratique de la même
manière. C'est pourquoi le système d'exploitation fournit les notions de
fichier, lecteur, etc : le programmeur n'a plus qu'à utiliser des commandes de
haut niveau (``monter un lecteur'', ``ouvrir un fichier'', ``lire dans un
fichier'') et selon le type de lecteur, le système d'exploitation effectuera les
actions appropriées.

En résumé, un système d'exploitation est l'intermédiaire entre le logiciel et
le matériel, et en particulier assure les rôles suivants :

\paragraph{Gestion des processus} : un système d'exploitation peut permettre
d'exécuter plusieurs programmes à la fois. Il faut alors orchestrer ces
différents processus et les séparer en terme de temps et de ressources
partagées.

\paragraph{Gestion de la mémoire} : chaque processus, en plus du noyau, doit
disposer d'un espace mémoire différent. C'est-à-dire qu'un processus ne doit pas
pouvoir interférer avec un autre.

\paragraph{Gestion des périphériques} : le noyau étant le seul code à s'exécuter
en mode privilégié, c'est lui qui doit communiquer avec les périphériques
matériels.

\paragraph{Abstractions} : le noyau fournit aux programmes une interface
unifiée, permettant de stocker des informations de la même manière sur un disque
dur ou une clef USB (alors que l'accès se déroulera de manière très différente
en pratique). C'est ici que la notion arbitraire de fichier sera définie, par
exemple.

\section{Architecture Intel}

Dans cette section nous décrivons le fonctionnement d'un processeur utilisant
une architecture Intel 32 bits. Les morceaux de code seront écrit en syntaxe
AT\&T, celle que comprend l'assembleur GNU.

\subsection{Assembleur}

Pour faire des calculs, le processeur est composé de registres, qui sont des
petites zones de mémoire interne, et peut accéder à la mémoire principale.

Les registres principaux sont nommés \eax, \ebx, \ecx, \edx, \esi et \edi. Ils
peuvent être utilisés pour n'importe quel type d'opération, mais certains sont
spécialisés : par exemple il est plus efficace d'utiliser \eax en accumulateur,
ou \ecx en compteur. \esp est le pointeur de pile (\emph{stack pointer}), qui a
un rôle particulier dans les instructions \asminstr{push} et \asminstr{pop}.
\ebp sert de point de repère dans les appels de fonction. \eip contient
l'adresse de l'instruction courante.

Les calculs sont décrits sous forme d'une suite d'instructions. Chaque
instruction est composée d'une mnémonique et d'une liste d'opérandes. Les
mnénoniques (\asminstr{mov}, \asminstr{call}, \asminstr{sub}, etc) définissent
un type d'opération à appliquer sur les opérandes.

Ces opérandes peuvent être de plusieurs types :

\begin{itemize}
\item
  un nombre, noté \$4
\item
  le nom d'un registre, noté \texttt{\%eax}
\item
  une opérande mémoire, c'est à dire le contenu de la mémoire à une
  adresse effective. Cette adresse effective peut être exprimée de
  plusieurs manières :
  \begin{itemize}
  \item
    directement : \texttt{addr}
  \item
    indirectement : \texttt{(\%ecx)}. L'adresse effective est le contenu
    du registre.
  \item
    ``base + déplacement'' : \texttt{4(\%ecx)}. L'adresse effective est
    le contenu du registre plus le déplacement (4 ici).
  \end{itemize}
\end{itemize}

En pratique il y a des modes d'adressage plus complexes, et toutes les
combinaisons ne sont pas possibles, mais ceux-ci suffiront à décrire les
exemples suivants :

\begin{itemize}

\item \texttt{mov src, dst} copie le contenu de \texttt{src} dans \texttt{dst}.

\item \texttt{add src, dst} calcule la somme des contenus de \texttt{src} et
  \texttt{dst} et place ce résultat dans \texttt{dst}.

\item \texttt{push src} place \texttt{src} sur la pile, c'est à dire que cette
  instruction décrémente le pointeur de pile \esp de la taille de \texttt{src},
  puis place \texttt{src} à l'adresse mémoire de la nouvelle valeur \esp.

\item \texttt{pop src} réalise l'opération inverse : elle charge le contenu de
  la mémoire à l'adresse \esp dans \texttt{src} puis incrémente \esp de la
  taille correspondante.

\item \texttt{jmp addr} saute à l'adresse \texttt{addr} : c'est l'équivalent de
  \texttt{mov addr, \%eip}.

\item \texttt{call addr} sert aux appels de fonction : cela revient à
  \texttt{push \%eip} puis \texttt{jmp addr}.

\item \texttt{rest} sert à revenir d'une fonction : c'est l'équivalent de
  \texttt{pop \%eip}.

\end{itemize}

\subsection{Appel de fonction et conventions d'appel}

\begin{figure} % {{{ fig:stackframe
\input{fig/stackframe.tex}
\caption[Cadres de pile]{ Cadres de pile. }
\label{fig:stackframe}
\end{figure} % }}}

Dans le langage d'assemblage, il n'y a pas de notion de fonction ; mais
\asminstr{call} et \asminstr{ret} permettent de sauvegarder et de restaurer une
adresse de retour, ce qui permet de faire un saut et revenir à l'adresse initiale.
Ce système permet déjà de créer des procédures, c'est-à-dire des fonctions sans
arguments ni valeur de retour.

Pour gérer ceux-ci, il faut que les deux morceaux (appelant et appelé) se
mettent d'accord sur une convention d'appel commune. La convention utilisée sous
GNU/Linux est appelée \emph{cdecl} et possède les caractéristiques suivantes :

\begin{itemize}
\item la valeur de retour d'une fonction est stockée dans \eax
\item \eax, \ecx et \edx peuvent être écrasés sans avoir à les sauvegarder
\item les arguments sont placés sur la pile (et enlevés) par l'appelant. Les
  paramètres sont empilés de droite à gauche.
\end{itemize}

Pour accéder à ses paramètres, une fonction peut donc utiliser un adressage
relatif à \esp. Cela peut fonctionner, mais cela complique les choses si elle
contient aussi des variables locales. En effet, les variables locales sont
placées sur la pile, au dessus des (c'est à dire, empilées après) paramètres,
augmentant le décalage.

Pour simplifier, la pile est organisée en cadres logiques : chaque cadre
correspond à un niveau dans la pile d'appels de fonctions. Si f appelle g, qui
appelle h, il y aura dans l'ordre sur la pile le cadre de f, celui de g puis
celui de h.

Ces cadres sont chainés à l'aide du registre \ebp : à tout moment, \ebp contient
l'adresse du cadre de l'appelant.

Prenons exemple sur la figure~\ref{fig:stackframe} : pour appeler
\texttt{g(4,2)}, \texttt{f} empile les arguments de droite à gauche.
L'instruction \asminstr{call g} empile l'adresse de l'instruction suivante sur
la pile puis saute au début de \texttt{g}.

Au début de la fonction, les trois instructions permettent de sauvegarder
l'ancienne valeur de \ebp, faire pointer \ebp à une endroit fixe dans le cadre
de pile, puis allouer 8 octets de mémoire pour les variables locales.

Dans le corps de la fonction \texttt{g}, on peut donc se référer aux variables
locales par \texttt{-4(\%ebp)}, \texttt{-8(\%ebp)}, etc, et aux arguments par
  \texttt{8(\%ebp)}, \texttt{12(\%ebp)}, etc.

À la fin de la fonction, l'instruction \asminstr{leave} est équivalente à
\texttt{mov \%ebp, \%esp} puis \texttt{pop \%ebp} et permet de défaire le cadre
de pile, laissant l'adresse de retour en haut de pile. Le \asminstr{ret} final
la dépile et y saute.

\subsection{Tâches, niveaux de privilèges}

Sans mécanisme particulier, le processeur exécuterait uniquement une suite
d'instruction à la fois. Pour lui permettre d'exécuter plusieurs tâches, un
système de partage du temps existe.

À des intervalles de temps réguliers, le système est programmé pour recevoir une
interruption. C'est une condition exceptionnelle (au même titre qu'une division
par zéro) qui fait sauter automatiquement le processeur dans une routine de
traitement d'interruption. Si à cet endroit le code sauvegarde les registres et
restaure un autre ensemble de registres, on peut exécuter plusieurs tâches de
manière entrelacée. Si l'alternance est assez rapide, cela peut donner
l'illusion que les programmes s'exécutent en parallèle. Comme l'interruption
peut survenir à tout moment, on parle de multitâche préemptif.

En plus de cet ordonnancement de processus, l'architecture Intel permet
d'affecter des niveaux de privilège à ces tâches, en restreignant le type
d'instructions exécutables, ou en donnant un accès limité à la mémoire aux
tâches de niveaux moins elevés.

Il y a 4 niveaux de privilèges (nommés aussi \emph{rings}) : le \ring{0} est le
plus privilégié, le \ring{3} le moins privilégié. Dans l'exemple précédent, on
pourrait isoler l'ordonnanceur de processus en le faisant s'exécuter en \ring{0}
alors que les autres tâches seraient en \ring{3}.

\begin{center}\rule{3in}{0.4pt}\end{center}

\begin{figure}
\input{fig/rings.tex}
\caption[Les différents \emph{rings}]{
  Les différents \emph{rings}. Seul le \ring{0} a accès au hardware
  via des instructions privilégiées. Pour accéder aux fonctionnalités du noyau,
  les programmes utilisateur doivent passer par des appels système.}
\label{fig:rings}
\end{figure}

La première protection nécessaire est d'isoler le système d'exploitation
lui-même des programmes qu'il va permettre d'exécuter. Pour ce faire, Le
processeur permet d'exécuter des tâches selon plusieurs niveaux de privilège,
aussi appelés \emph{rings} (figure~\ref{fig:rings}) : du \ring{3}, le
moins privilégié, jusqu'au \ring{0}, le plus privilégié. On peut configurer
le processeur de manière à ce que les instructions privilégiées (accès aux ports
d'entrée/sortie...) ne soient possibles qu'en \ring{0}. Bien que 4 niveaux
soient disponibles, Linux n'utilise que les \emph{rings} 0 et 3 : le noyau
lui-même en \ring{0} et les processus utilisateur en \ring{3}.

\begin{figure} % fig:memoire-virtuelle {{{
\centering
\begin{tikzpicture}
  [every node/.style={node distance=2cm}]

  \node (u1) {};

  \node[right of=u1] (phy) {};

  \node[right of=phy] (u2) {};

  \draw (u1) rectangle ++(1,-6);
  \draw (phy) rectangle ++(1,-6);
  \draw (u2) rectangle ++(1,-6);
\end{tikzpicture}
\caption{Mécanisme de mémoire virtuelle.}
\label{fig:memoire-virtuelle}
\end{figure} % }}}

En ce qui concerne la mémoire, les différentes tâches ont une vision différente
de la mémoire physique : c'est-à-dire que deux tâches lisant à une même adresse
peuvent avoir un résultat différent. C'est le concept de mémoire virtuelle
(fig~\ref{fig:memoire-virtuelle}).

\begin{figure} % fig:memmap {{{
\centering
\fbox{
  \input{fig/memmap.tex}
}

\caption[Espace d'adressage d'un processus]{L'espace d'adressage d'un processus.
En gris clair, les zones accessibles à tous les niveaux de privilèges : code du
programme, bibliothèques, tas, pile. En gris foncé, la mémoire du noyau,
réservée au mode privilégié.}

\label{fig:memmap}
\end{figure}
% }}}

\section{Cas de Linux}

Dans cette section, nous allons voir comment ses mécanismes sont implantés dans
le noyau Linux. Une description plus détaillée pourra être trouvée dans
\cite{UnderstandingTheLinuxKernel} par exemple.


\subsection{Appels système}

Les programmes utilisateur s'exécutant en \ring{3}, ils ne peuvent pas
contenir d'instructions privilégiées, et donc ne peuvent pas accéder directement
au matériel (c'était le but !). Pour qu'ils puissent interagir avec le système
(afficher une sortie, écrire sur le disque...), le mécanisme des appels système
est nécessaire. Il s'agit d'une interface de haut niveau entre les \emph{rings}
3 et 0. Du point de vue du programmeur, il s'agit d'un ensemble de fonctions C
``magiques'' qui font appel au système d'exploitation pour effectuer des
opérations.

Prenons le cas de l'appel \texttt{getpid}, qui retourne le numéro de processus
courant. La bibliothèque C fournit une fonction du même nom :

\begin{Verbatim}
pid_t getpid(void);
\end{Verbatim}

A priori, rien de différent d'une fonction implantée directement en C. Par un
processus détaillé ci-après, cette fonction va invoquer la fonction, suivante,
définie dans le noyau (\texttt{kernel/timer.c}) :

\begin{Verbatim}
SYSCALL_DEFINE0(getpid)
{
        return task_tgid_vnr(current);
}
\end{Verbatim}



Le mécanisme de couplage entre ces deux fonctions est le suivant. Une
explication plus détaillé est disponible dans la documentation d'Intel
\cite{intelsys}.

Il y a bien une fonction \texttt{getpid} présente dans la bibliothèque C du
système. C'est la fonction qui est directement appelée par le programme. Cette
fonction commence par placer le numéro de l'appel système (noté
\texttt{\_\_NR\_getpid}, valant 20 ici) dans \eax, puis les arguments éventuels
dans les registres (\ebx, \ecx, \edx, \esi puis \edi). Une interruption
logicielle est ensuite déclenchée (\texttt{int 0x80}) : étant donné la
configuration du processeur, elle sera traitée en \ring{0}, à un point
d'entrée prédéfini (\texttt{arch/x86/kernel/entry\_32.S},
\texttt{ENTRY(system\_call)}).

L'exécution reprend donc en \ring{0}, avec une pile propre au processus.
Les valeurs des registres ont été préservées : elles sont mises sur la pile du
noyau. Le noyau examine le numéro d'appel système (toujours dans \eax) et
appelle la fonction correspondante dans le tableau \texttt{sys\_call\_table} :
les arguments sont en place sur la pile, comme dans le cas d'un appel de
fonction ``classique''. La fonction, nommée \texttt{sys\_getpid}, peut donc être
écrite en C.

Au retour de la fonction, la valeur de retour est placée à la place de \eax là
où les registres ont été sauvegardés sur la pile noyau. L'instruction
\texttt{iret} permet de restaurer les registres et de repasser en mode
utilisateur, juste après l'interruption. La fonction de la bibliothèque C peut
alors retourner au programme appelant.

% vim: spelllang=fr
