
Nous avons montré que l'écriture de noyaux de systèmes d'exploitation nécessite
de manipuler des données provenant d'une zone non sûre, l'espace utilisateur.
Parmi ces données, il arrive de récupérer des pointeurs qui servent à passer des
données par référence à l'appellant, dans certains appels systèmes. Si on
déréférence ces pointeurs sans vérifier qu'ils pointent bien vers une zone
mémoire également contrôlée par l'appellant, on risque de lire ou d'écrire dans
des zones mémoires réservées au noyau seul.

Nous proposons une technique de typage pour détecter ces cas dangereux. Pour ce
faire, il faudra tout d'abord définir un langage impératif bien typé que nous
appellerons \langname. Ensuite, nous distinguons dans le système de types les
pointeurs dont la valeur est contrôlée par l'utilisateur.

Cela revient à introduire une séparation entre le type des données et sa
représentation : c'est-à-dire définir un type abstrait. Les pointeurs
utilisateur sont en fait des pointeurs classiques déguisés, pour lesquels ont
interdit l'opérateur de déréférencement.

Cette technique est en fait générique : on peut également l'appliquer à certains
types d'entiers. En C, il est commun d'utiliser des \texttt{int} pour tout et
n'importe quoi : pour des entiers bien sûr (au sens de $ℤ$), mais aussi comme
identificateurs pour lesquels les opérations usuelles comme l'addition n'ont pas
de sens. Par exemple, sous Linux, l'opération d'ouverture de fichier renvoie un
entier, dit \emph{descripteur de fichier}, qui identifie ce fichier pour ce
processus. Il est passé à toutes les fonctions de lecture et d'écriture. Un
autre idiome est d'utiliser des entiers comme des ensembles de bits (on parle de
\emph{bitmask}). Un prototype d'analyse statique sur ces \emph{bitmasks} est
présenté en annexe~\ref{anx:bitmasks}.

% TODO à merger

En n'offrant pas cette distinction, le langage C permet d'écrire du code qui
peut s'exécuter mais dont la sémantique n'est, quelque part, pas bien fondée.
Par exemple, en additionnant deux descripteurs de fichiers, ou en déréférençant
un pointeur contrôlé par l'utilisateur. En effet, le système de types de C est
trop primitif pour pouvoir garantir une véritable isolation entre deux types de
même représentation : il n'y a pas de types abstraits. Certes, \texttt{typedef}
permet d'introduire un nouveau nom pour un type, mais ce n'est qu'un raccourci
syntaxique. Le compilateur ne peut en effet pas considérer un programme sans
avoir la définition quasi-complète des types qui y apparaissent. La seule
exception concerne les pointeurs sur structures : si on ne fait que les passer,
il n'est pas nécessaire de connaître la taille ni la disposition de la
structure, donc il est possible de ne pas connaître ces informations. Cette
technique, connue sous le nom de \emph{pointeurs opaques}, n'est pas applicable
aux autres types.

En ajoutant une couche de typage, on interdit ces opérations à la compilation.
Cela permet deux choses : pour le code déjà écrit, de détecter et corriger les
manipulations dangereuses ; et pour le nouveau code, de s'assurer qu'il est
correct.

Le but de cette thèse est donc de définir un langage intermédiaire proche de C,
mais bien typable, et de l'adjoindre d'un système de types tel que les
programmes bien typés manipulent les pointeurs utilisateur sans causer de
problèmes de sécurité.

% TODO unduqyer qye ty saus traduire C -> langname ou du moins newspeak

% TODO dire qu'il est issu de newspeak(EADS)

% vim: spelllang=fr
