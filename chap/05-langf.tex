On définit ici un langage impératif.

\begin{Verbatim}
cst ::= int
        float

exp ::= cst
        var
        op exp
        exp op exp
        addrOf var
        fun (exp1, ..., expn)
\end{Verbatim}

\begin{Verbatim}
instr ::= pass
          instr;instr
          var <- exp
          if (exp) then instr else instr
          while(exp) { instr }
\end{Verbatim}

états de l'interpréteur d'exp :

(m, e)

m supporte :

\[
  (x, v) ∈ m
\]

\[
  m[x ↦ v]
\]

Stack frames :

\begin{Verbatim}
s :: { x_1 |-> v_1 ; ... ; x_n |-> v_n } :: s
     []
\end{Verbatim}

et réduction de l'exp (fin en int ou float).

\begin{Verbatim}
m ::= empty
      var -> cst ; m
\end{Verbatim}

Réduction :

(m, e) -> (m', e')

Cas cst terminal.

Cas var :

\[
  \irule{Exp-Var}
  {(x, v) ∈ m}
  {(m, x) → (m, v)}
\]

Cas op :

\[
  \irule{Exp-UnOp}
  {(m, e) → (m', v) \\ v' = \widehat{\opsymb}~v}
  {(m, \opsymb~e) → (m', v') }
\]

À chaque opérateur $\opsymb$, correspond un opérateur sémantique
$\widehat{\opsymb}$ qui agit sur les valeurs. Par exemple, l'opérateur
$\widehat{+}$ est l'addition classique entre entiers.

\[
  \irule{Exp-BinOp}
  {(m, e_1) → (m', v_1) \\
   (m', e_2) → (m'', v_2) \\
   v' = v_1~\widehat{\opsymb}~v_2
  }
  {
    (m, e_1~\opsymb~e_2) → (m'', v')
  }
\]

On définit l'extension des stackframes

\[
  \mathrm{Push}(s, (x_1, v_1), …, (x_n, v_n)) = \{ x_1 ↦ v_1 ; … ; x_n ↦ v_n \}~::~s
\]

\[
  \mathrm{Pop}(f~::~s) = s
\]

et extension aux m

\[
  \irule{Call}
  {(m  , e_1) → (m_1, v_1) \\
   (m_1, e_2) → (m_2, v_2) \\
   … \\
   (m_{n-1}, e_n) → (m_n, v_n) \\
   f = (i, arg_1, …, arg_n) \\
   m' = \mathrm{Push}(m_n, (arg_1, v_1), …, (arg_n, v_n)) \\
   (m', i) → (m'', Return v) \\
   m''' = \mathrm{Pop}(m'')
  }
  {(m, f(e_1, …, e_n)) → (m''', v)}
\]

Instructions

(attention au pas)

\[
  \irule{Set}
  {
    (m, e) → (m', v) \\
    m'' = m' [ x ↦ v ]
  }
  {(m, x ← e) → (m'', pass)}
\]

\begin{itemize}
\item
  ajout des adresses
\item
  declaration
\item
  champs de records
\end{itemize}
