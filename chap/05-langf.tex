On définit ici un langage impératif servant de base à nos analyses. Un premier
système de types sera donné dans le chapitre~\ref{cha:typbase}.

\section{Principes}

Nous voulons capturer l'essence de C. Les traits principaux sont les suivants :

\begin{itemize}
\item
  les types de données sont très simples : entiers machine, flottants,
  pointeurs et types composés (structures et tableaux) composés de
  ceux-ci.
\item
  les variables sont mutables, et on peut passer des données par valeur
  ou par pointeur.
\item
  le flôt de contrôle repose sur les construction ``if'' et ``while''.
\item
  le code est organisé en fonctions ``simples'', c'est-à-dire qui ne
  sont pas des fermetures.
\end{itemize}

\section{Syntaxe}

Les figures~\ref{fig:stx}, \ref{fig:stx-data} et \ref{fig:stx-ops} présentent
notre langage intermédiaire. Il contient la plupart des fonctionnalités
présentes dans les langages impératifs comme C.

Un programme est organisé en fonctions, qui contiennent des instructions, qui
elles-même manipulent des expressions.

Le flot de contrôle est simplifié par rapport à C : il ne contient que
l'alternative ("if") et la boucle "while". Les autres formes de boucle
("do/while" et "for") peuvent être émulées par une boucle "while".

Les fonctionnalités manquantes, et comment les émuler, seront discutés dans le
chapitre\ref{chap:nexistepas}. % TODO

Pour l'alternative, on introduit également la forme courte $\iThen{e}{i} =
\iIf{e}{i}{\iPass}$.

Les opérateurs sont donnés dans la figure~\ref{fig:stx-ops}.

\begin{figure}

  \gramlr{Constantes}{
    \begin{align*}
      c \gramisa & i      & \textrm{Entier}
      \\ \gramor & f      & \textrm{Flottant}
      \\ \gramor & \eNull & \textrm{Pointeur nul}
    \end{align*}
  }

  \gramlr{Expressions}{
    \begin{align*}
      e \gramisa & c               & \textrm{Constante}
      \\ \gramor & lv              & \textrm{Accès mémoire}
      \\ \gramor & \opun~e         & \textrm{Opération unaire}
      \\ \gramor & e~\opbin~e      & \textrm{Opération binaire}
      \\ \gramor & \& lv           & \textrm{Pointeur}
      \\ \gramor & lv ← e          & \textrm{Affectation}
      \\ \gramor & \{ f_1 : e_1 ;
                  … ; f_n : e_n \} & \textrm{Structure}
      \\ \gramor & \{e_1 ;…; e_n\} & \textrm{Tableau}
      \\ \gramor & f               & \textrm{Fonction}
      \\ \gramor & e (e_1, …, e_n) & \textrm{Appel de fonction}
    \end{align*}
  }

  \gramlr{Left-values}{
    \begin{align*}
      lv \gramisa & x     & \textrm{Variable}
      \\  \gramor & *lv   & \textrm{Déréférencement}
      \\  \gramor & lv.f  & \textrm{Accès à un champ}
      \\  \gramor & lv[e] & \textrm{Accès à un élément}
    \end{align*}
  }
  \caption{Syntaxe - expressions}
  \label{fig:stx-data}
\end{figure}

\begin{figure}
  \gramlr{Instructions}{
    \begin{align*}
      i \gramisa & \iPass        & \textrm{Instruction vide}
      \\ \gramor & i;i           & \textrm{Séquence}
      \\ \gramor & e             & \textrm{Expression}
      \\ \gramor & \iIf{e}{i}{i} & \textrm{Alternative}
      \\ \gramor & \iWhile{e}{i} & \textrm{Boucle}
      \\ \gramor & \iReturn{e}   & \textrm{Retour de fonction}
    \end{align*}
  }

  \gramlr{Fonctions}{
    \begin{align*}
      f \gramisa & \mathrm{fun} (x_1, …, x_n)    & \textrm{Arguments} \\
                 & ((x'_1, e_1), …, (x'_p, e_p)) & \textrm{Variables locales} \\
                 & \{ i \}                       & \textrm{Corps} \\
    \end{align*}
  }

  \gramlr{Phrases}{
    \begin{align*}
      p \gramisa & x = e             & \textrm{Variable globale}
      \\ \gramor & e                 & \textrm{Évaluation d'expression}
      \\ \gramor & \tstruct{s}
                      \{ x_1 : t_1
                       ; …
                       ;  x_n : t_n
                      \}             & \textrm{Déclaration de structure}
    \end{align*}
  }

  \gramlr{Programme}{
    \begin{align*}
      P \gramisa & (p_1, …, p_n) & \textrm{Phrases}
    \end{align*}
  }

  \caption{Syntaxe - instructions}
  \label{fig:stx}
\end{figure}

\begin{figure}

  \gramlr{Opérateurs binaires}{
    \begin{align*}
      \opbin \gramisa & +,-,\times,/      & \textrm{Arithmétique entière}
      \\     \gramor  & +.,-.,\times.,/.  & \textrm{Arithmétique flottante}
      \\     \gramor  & +_p, -_p          & \textrm{Arithmétique de pointeurs}
      \\     \gramor  & =,≠,≤,≥,<,>       & \textrm{Comparaisons}
      \\     \gramor  & \&,|,\opxor       & \textrm{Opérateurs bit à bit}
      \\     \gramor  & \&\&,||           & \textrm{Opérateurs logiques}
      \\     \gramor  & \ll, \gg          & \textrm{Décalages}
    \end{align*}
  }

  \gramlr{Opérateurs unaires}{
    \begin{align*}
      \opun \gramisa & +,-   & \textrm{Arithmétique entière}
      \\    \gramor  & +.,-. & \textrm{Arithmétique flottante}
      \\    \gramor  & \sim  & \textrm{Négation bit à bit}
      \\    \gramor  & !     & \textrm{Négation logique}
    \end{align*}
  }

  \caption{Syntaxe - opérateurs}
  \label{fig:stx-ops}
\end{figure}

\section{Définitions préliminaires}

On suppose avoir à notre disposition un ensemble infini dénombrable
d'identificateurs \sId (par exemple des chaînes de caractères).

$X^*$ est l'ensemble des suites finies de $X$, indexées à partir de 1. Si $u ∈
X^*$, on note $|u|$ le nombre d'éléments de $u$ (le cardinal de son ensemble de
définition). Pour $1 ≤ i ≤ |u|$, on note $u_i = u(i)$ le i-ème élément de la
suite.

On peut aussi voir les suites comme des listes : on note $[]$ la suite vide,
telle que $|[]| = 0$. On définit en outre la construction de suite de la manière
suivante : si $x ∈ X$ et $u ∈ X^*$, la liste $x::u ∈ X^*$ est la liste $v$ telle
que :

\begin{align*}
  v_1 = & x \\
  ∀ i ∈ [1; |u|] , v_{i+1} = & u_i
\end{align*}

La concaténation des listes $u$ et $v$ est la liste $u@v = w$ telle que :

\begin{align*}
|w| = & |u| + |v| \\
∀ i ∈ [1 ; |u|] , w_i = & u_i \\
∀ j ∈ [1 ; |v|] , w_{|u| + j} = & v_j
\end{align*}

\section{Mémoire}

L'interprète que nous nous apprêtons à définir manipule des valeurs qui sont
associées aux variables du programme.

\begin{align*}
  \sVal = &          \sInt
            \bigdcup \sFloat
            \bigdcup \{ \eNull \}
            \bigdcup \sPhi \\
  \sInt = & ℤ/2^{32} ℤ - 2^{31} \\
  \sFloat = & \textsc{IeeeFloat}(32) \\
    \sPhi = & \mathrm{fix} (\sPhi') \\
    \sPhi'(X) = & X \\
                & \cup \sAddr \\
                & \cup \{*φ / φ ∈ \sPhi\} \\
                & \cup \{φ.f / φ ∈ \sPhi, f ∈ \sId\} \\
                & \cup \{φ[n] / φ ∈ \sPhi, n ∈ \sInt\} \\
  \sAddr = & \sId \bigdcup (ℕ × \sId) \\
\end{align*}

$\textsc{IeeeFloat}(n)$ correspond à l'ensemble des flottants IEEE 754 de $n$
bits\cite{ieee754}. Ici, \sInt est choisi pour représenter les nombres entiers
de $-2^{31}$ à $2^{31}-1$, mais ce choix est arbitraire : de la même manière, on
aurait pu choisir des nombres à 64 bits ou même de précision arbitraire.

L'ensemble des états mémoire est :

\[
  \sMem = ((\sId × \sVal)^*)^* × (\sId × \sVal)^*
\]

Un état mémoire état mémoire $(s, g) ∈ \sMem$ est composé :

\begin{itemize}
\item
  d'une part, d'une pile $s$ de cadres, qui sont des listes
  d'association (nom de variable, valeur).
\item
  d'autre part, une liste d'association qui représente les variables
  globales.
\end{itemize}

La structure de pile des locales permet de les organiser en niveaux indépendants:
à chaque appel de fonction, un nouveau cadre de pile est créé, comprenant ses
paramètres et ses variables locales.

Au contraire, pour les globales il n'y a pas de système d'empilement, puisque
ces variables sont accessibles depuis tout point du programme.

Ces définitions sont résumées dans la figure~\ref{fig:interp}

\begin{figure}

  \gramlr{Valeurs}{
    \begin{align*}
      v \gramisa & c               & \textrm{Constante}
      \\ \gramor & φ               & \textrm{Référence mémoire}
      \\ \gramor & \{ f_1 : v_1 ;
                  … ; f_n : v_n \} & \textrm{Structure}
      \\ \gramor & \{v_1 ;…; v_n\} & \textrm{Tableau}
      \\ \gramor & f               & \textrm{Fonction}
    \end{align*}
  }

  \gramlr{Adresses}{
    \begin{align*}
      a \gramisa & (n, x) & \textrm{Variable locale}
      \\ \gramor & x      & \textrm{Variable globale}
    \end{align*}
  }

  \gramlr{Chemins}{
    \begin{align*}
      φ \gramisa & a    & \textrm{Adresse}
      \\ \gramor & *φ   & \textrm{Déréférencement}
      \\ \gramor & φ.f  & \textrm{Accès à un champ}
      \\ \gramor & φ[n] & \textrm{Accès à un élément}
    \end{align*}
  }

  \gramlr{Pile}{
    \begin{align*}
      s \gramisa & []                       & \textrm{Pile vide}
      \\ \gramor & \{ x_1 ; … ; x_n \} :: s & \textrm{Ajout d'un cadre}
    \end{align*}
  }

  \gramlr{État mémoire}{
    \begin{align*}
      m \gramisa & (s,                    & \textrm{Pile}      \\
                 & \{ x_1 ;…; x_n \},     & \textrm{Globales}  \\
                 & \{a_1↦v_1;…;a_p↦v_p\}) & \textrm{Valeurs}
    \end{align*}
  }

  \caption{Composantes d'un état mémoire}
  \label{fig:interp}
\end{figure}

\begin{definition}[Recherche de variable]

  La recherche de variable permet d'associer à une variable $x$ une adresse $a$.

  Chaque fonction peut accéder aux variables locales de la fonction en cours,
  ainsi qu'aux variables globales.

  \begin{align*}
    \mathrm{Lookup} ((s, g), x) = & (|s|, x)
                                    \mbox{ si }|s| > 0
                                    \mbox{ et }∃ (x, v) ∈ s_1 \\
    \mathrm{Lookup} ((s, g), x) = & x \mbox{ si } (x, v) ∈ g
  \end{align*}

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. En retournant à
l'appelant, il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  On définit l'empilement d'un cadre de pile $f = ((x_1, v_1), …, (x_n, v_n))$
  sur un état mémoire $m = (s, g)$ :

  \[
    \mathrm{Push}((s, g), f) = (f::s, g)
  \]

  On définit aussi l'extension du dernier cadre de pile :

  \[
    \mathrm{Extend}((f::s, g), x) = (((x @ f) :: s), g)
  \]

  De même on définit le dépilement :

  \[
    \mathrm{Pop}(f::s, g) = (s, g)
  \]

\end{definition}

\begin{figure}

  \begin{tikzpicture}
    [ stack/.style={draw,shape=rectangle,minimum height=5mm,minimum width=2cm}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    ]

    \path (0,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$…$}
    ;

    \path (4,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;

    \draw [->] (1.2, 1) -- node[auto] {Pop} ++(1.6, 0);

    \path (8,0)   node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    ;

    \path (12,0)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;

    \draw [->] (9.2, 1) -- node[auto] {$\mathrm{Push}((x, 0))$} ++(1.6, 0);

    \path (4,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0$}
    ;

    \path (8,-3)  node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack, faded] {}
    -- ++ (0,0.5) node [stack] {$x↦0, y↦3$}
    ;

    \draw [->] (5.2, -2) -- node[auto] {$\mathrm{Extend}((y, 3))$} ++(1.6, 0);

  \end{tikzpicture}

  \caption{Opérations de pile}
  \label{fig:stackops}
\end{figure}

Ces définitions sont illustrées dans la figure~\ref{fig:stackops}.

\section{Accesseurs}

On définit quelques accesseurs. Un accesseur $ [ \cdot ] $ permet d'accéder à
une structure $s$ et d'obtenir un élément $e$ à partir d'un indice $i$ (noté $e
= s [ i ]$) ou de modifier le sous-élément à l'indice $i$ par $e$ (noté $ s [ i
← e ] $).

\begin{definition}[Accès à une liste d'associations]

  Une liste d'association est une liste de paires (clef, valeur) avec
  l'invariant supplémentaire que les clefs sont uniques. Il est donc possible de
  trouver au plus une valeur associée à une clef donnée. L'écriture est
  également possible, en remplaçant un couple par un couple avec une valeur
  différente.

  L'accesseur $[\cdot]_L$ est défini par :

  \begin{align*}
    l[x]_L     = & v \mbox{ où } \{v\} = \{y / (x, y) ∈ l\} \\
    l[x ← v]_L = & (x, v) :: \{ (y, v) ∈ g(x) / y ≠ x \})
  \end{align*}

\end{definition}

\begin{definition}[Accès par adresse]

  Les états mémoire sont constitués des listes d'association (nom, valeur).

  L'accesseur par adresse $[\cdot]_A$ permet de généraliser l'accès à ces
  valeurs en utilisant comme clef non pas un nom mais une adresse.

  Selon cette adresse, on accède soit à la liste des globales, soit à une des
  listes de la pile des locales.

  Pour $m = (s, g)$,

  \begin{align*}
    m [x]_A          = & g[x]_L           & \textrm{Lecture d'une globale} \\
    m [(n, x)]_A     = & s_{|l|-n+1}[x]_L & \textrm{Lecture d'une locale} \\
    m [x ← v]_A      = & (s, g[x←v]_L)    & \textrm{Écriture d'une globale} \\
    m [(n, x) ← v]_A = & (s', g)          & \textrm{Écriture d'une locale} \\
           \mbox{ où } & s'_{|l|-n+1} = s_{|l|-n+1}[x ← v]_L \\
                       & ∀ i ≠ |l|-n+1, s'_i = s_i
  \end{align*}

\end{definition}

Les numéros de cadre qui permettent d'identifier les globales (le $n$ dans $(n,
x)$) croissent avec la pile. D'autre part, l'empilement se fait en tête de liste
(près de l'indice 1). Donc pour accéder aux plus vieilles locales (numérotées
1), il faut accéder au dernier élément de la liste. Ceci explique pourquoi un
indice $|l|-n+1$ apparaît dans la définition précédente.

\begin{definition}[Accès par champ]

  Les valeurs qui sont des structures possèdent des sous-valeurs, associées à
  des noms de champ.

  L'accesseur $[ \cdot ]_F$ permet de lire et de modifier un champ de ces
  valeurs.

  C'est une erreur d'accéder à un champ d'une valeur non structure ($4[f]$ par
  exemple).

  \begin{align*}
    \{ f_1 : v_1; … ; f_n : v_n \}[f_i]_F = & v_i \\
    \{ f_1 : v_1; … ; f_n : v_n \}[f_p ← v]_F = & \{ f_1 : v'_1; … ; f_n : v'_n \} \\
          \mbox{ où } & v'_p = v \\
                      & ∀ i ≠ p, v'_i = v_i
  \end{align*}

\end{definition}

\begin{definition}[Accès par indice]

  On définit de même un accesseur $[\cdot]_I$ pour les accès par indice à des
  valeurs tableaux. Néanmoins le paramètre indice est toujours un entier et pas
  une expression arbitraire.

  \begin{align*}
    \{ v_1 ; … ; v_n \} [i]_I   = & e_i \\
    \{ v_1 ; … ; v_n \} [i←v]_I = & \{ v'_1 ; … ; v'_n \} \\
                      \mbox{ où } & v'_i = v \\
                                  & ∀j≠i, v'_j = v_j
  \end{align*}

\end{definition}

\begin{definition}[Accès par chemin]

  L'accès par chemin $[\cdot]_Φ$ permet de lire et de modifier la mémoire en
  profondeur.

  \begin{align*}
    m[a]_Φ        = & m[a]_A \\
    m[*φ]_Φ       = & m[φ']_Φ \mbox{ où } φ' = m[φ]_Φ \\
    m[φ.f]_Φ      = & m[φ]_φ[f]_F \\
    m[φ[i]]_Φ     = & m[φ]_φ[i]_I \\
    m[a ← v]_Φ    = & m[a ← v]_A \\
    m[*φ ← v]_Φ   = & m[φ' ← v]_Φ \mbox{ où } φ' = m[φ]_Φ \\
    m[φ.f ← v]_Φ  = & m[φ ← (m[φ]_Φ[f←v]_F)]_Φ \\
    m[φ[i] ← v]_Φ = & m[φ ← (m[φ]_Φ[i←v]_I)]_Φ
  \end{align*}

\end{definition}

Cette dernière définition mérite une explication. Dans le cas de la lecture, il
suffit d'appliquer les bons accesseurs : $[\cdot]_F$ pour $φ.f$, etc.

En revanche, la modification est plus complexe. Les deux premiers cas ($φ = a$
et $φ = *φ'$) modifient directement une valeur complète (en modifiant une
association), mais les deux suivants ($φ = φ'.f$ et $φ = φ'[i]$) ne font
qu'altérer une sous-valeur existante. Il est donc nécessaire de procéder en 3
étapes :

\begin{itemize}
\item obtenir la valeur à modifier (soit $m[φ]_φ$)
\item construitre une valeur altérée (en appliquant par exemple $[f←v]_f$)
\item affecter cette valeur au même chemin (le $m[φ ← …]_φ$ externe)
\end{itemize}

Dans la suite, on notera uniquement $[\cdot]$ tous ces accesseurs lorsque ce
n'est pas ambigü.

\section{Contextes d'évaluation}

L'évaluation des expressions repose sur la notion de contextes d'évaluation.
L'idée est que si on peut évaluer une expression, alors on peut évaluer une
expression qui contient celle-ci.

Par exemple, supposons que $\mm{m}{f(3)}{m}{2}$. Alors on peut ajouter la
constante $1$ à gauche de chaque expression sans changer le résultat :
$\mm{m}{1+f(3)}{m}{1+2}$. On a utilisé le même contexte
$C = 1+\ctxEmpty$.

Pour pouvoir raisonner en termes de contextes, 3 points sont nécessaires :

\begin{itemize}
\item comment découper une expression selon un contextes
\item comment appliquer une règle d'évaluation sous un contexte
\item comment regrouper une expression et un contexte
\end{itemize}

\begin{figure}
  \gramlr{Contextes}{
  \begin{align*}
  C \gramisa & \ctxEmpty
  \\ \gramor & \ctxOp{C}{e}
  \\ \gramor & \ctxOp{v}{C}
  \\ \gramor & \ctxUnOp{C}
  \\ \gramor & \ctxLvDeref{C}
  \\ \gramor & \ctxLvField{φ}{C}
  \\ \gramor & \ctxLvIndex{φ}{C}
  \\ \gramor & \ctxLvIndex{C}{e}
  \\
  \\ \gramor & C;i 
  \\ \gramor & \iIf{C}{i_1}{i_2}
  \\ \gramor & \iWhile{C}{i}
  \\ \gramor & \iReturn{C}
  \end{align*}
  }

\caption{Contextes d'exécution}
\label{fig:eval-ctx}
\end{figure}

Le premier point consiste à définir les contextes eux-mêmes
(figure~\ref{fig:eval-ctx}).

Le deuxième est résolu la règle d'inférence suivante :

\begin{mathpar}
  \semrule{Ctx}
\end{mathpar}

Enfin, le troisième revient à définit l'opérateur de substitution
$\phxx{\ctxSub}$ présent dans la règle précédente.

Dans la définition de l'ensemble des contextes, chaque cas hormis le cas de base
fait apparaître exactement un "$C$". Chaque contexte est donc constitué
d'exactement un "trou" $\ctxEmpty$ (une dérivation de $C$ est toujours
linéaire). L'opération de substitution consiste à remplacer ce trou :

\begin{align*}
  \ctxSub{\ctxEmpty}{e_0} = & e_0 \\
  \ctxSub{(\ctxOp{C}{e}     )}{e_0} = & \ctxOp{\ctxSub{C}{e_0}}{e}      \\
  \ctxSub{(\ctxOp{v}{C}     )}{e_0} = & \ctxOp{v}{\ctxSub{C}{e_0}}      \\
  \ctxSub{(\ctxUnOp{C}      )}{e_0} = & \ctxUnOp{\ctxSub{C}{e_0}}       \\
  \ctxSub{(\ctxLvDeref{C}   )}{e_0} = & \ctxLvDeref{\ctxSub{C}{e_0}}    \\
  \ctxSub{(\ctxLvField{φ}{C})}{e_0} = & \ctxLvField{φ}{\ctxSub{C}{e_0}} \\
  \ctxSub{(\ctxLvIndex{φ}{C})}{e_0} = & \ctxLvIndex{φ}{\ctxSub{C}{e_0}} \\
  \ctxSub{(\ctxLvIndex{C}{e})}{e_0} = & \ctxLvIndex{\ctxSub{C}{e_0}}{e} \\
  \\
  \ctxSub{(C;i              )}{e_0} = & \ctxSub{C}{e_0};i               \\
  \ctxSub{(\iIf{C}{i_1}{i_2})}{e_0} = & \iIf{\ctxSub{C}{e_0}}{i_1}{i_2} \\
  \ctxSub{(\iWhile{C}{i}    )}{e_0} = & \iWhile{\ctxSub{C}{e_0}}{i}     \\
  \ctxSub{(\iReturn{C}      )}{e_0} = & \iReturn{\ctxSub{C}{e_0}}       \\
\end{align*}

Une dérivation.

\begin{mathpar}
\inferrule*
  {
    \inferrule*[vdots=2em]
      {
        \inferrule*[leftskip=4cm, vdots=2em]
          {
            \mmstar{m}{e_1}{m'}{v_1}
            \\
            (C = \ctxOp{\ctxEmpty}{e_2})
          }
          {
            \mmstar{m}{e_1~\opbin~e_2}{m'}{v_1~\opbin~e_2}
          }
        \\
        \inferrule*[rightskip=4cm, vdots=2em]
          {
            \mmstar{m'}{e_2}{m''}{v_2}
            \\
            (C = \ctxOp{v_1}{\ctxEmpty})
          }
          {
            \mmstar{m}{v_1~\opbin~e_2}{m'}{v_1~\opbin~v_2}
          }
      }
      { \mmstar{m}{e}{m''}{v_1\opbin~v_2} }
    \\
    \inferrule*[rightskip=2cm, vdots=2em]
      { }
      { \mmstar{m''}{v_1\opbin~v_2}{m''}{v_1~\widehat{\opbin}~v_2} }
  }
  { \mmstar{m}{e}{m''}{v_1~\widehat{\opbin}~v_2} }
\end{mathpar}

\section{Expressions}

\begin{definition}[Évaluation d'une expression]

  L'évaluation d'une expression $e$ se fait sous un état mémoire particulier $m$
  et est susceptible de modifier celui-ci en le transformant en un nouveau $m'$.
  Le résultat est toujours une valeur $v$, c'est à dire que nous présentons pour
  les expressions une sémantique à grands pas. Cette évaluation est notée :

  \[
    \mm{m}{e}{m'}{v}
  \]

\end{definition}

\begin{definition}[Évaluation d'une left-value]

  L'évaluation d'une left-value $lv$ produit un "chemin" $φ$ dans une variable,
  qui est en fait équivalent à une left-value dont toutes les sous-expressions
  (d'indices) ont été évaluées.

  On note :

  \[
    \mmlv{m}{lv}{m'}{φ}
  \]

\end{definition}

La sémantique présentée n'a pas d'erreur explicite. Si aucune règle ne peut
s'appliquer, on considère que l'exécution est terminée.

Puisque des left-values peuvent apparaitre dans les expressions, et des
expressions dans les left-values (en indice de tableau), leurs règles
d'évaluation sont mutuellement récursives.

\subsection*{Left-values}

\begin{figure}

  \centering

  \begin{tikzpicture}
    \node              (a1) {$x$};
    \node[right of=a1] (a2) {$.f$};
    \node[right of=a2] (a3) {$[2*n]$};
    \node[right of=a3] (a4) {$.g$};

    \node[below of=a1] (b1) {$(2, x)$};
    \node[below of=a2] (b2) {$.f$};
    \node[below of=a3] (b3) {$[4]$};
    \node[below of=a4] (b4) {$.g$};

    \draw[->] (a1) -- (b1);
    \draw[->] (a2) -- (b2);
    \draw[->] (a3) -- (b3);
    \draw[->] (a4) -- (b4);
  \end{tikzpicture}

  \caption{Évaluation des left-values.}
  \label{fig:eval-lv}
\end{figure}

Obtenir un chemin à partir d'un nom de variable revient à résoudre le nom de
cette variable : est-elle accessible ? Le nom désigne-t'il une variable locale
ou une variable globale ?

\begin{mathpar}
  \semrule{Phi-Var}
\end{mathpar}

Les règles portant sur le déréférencement et l'accès à un champ de structure
sont similaires : on commence par évaluer la left-value sur laquelle porte ce
modificateur, et on place le même modificateur sur le chemin résultant.

\begin{mathpar}
  \semrule{Phi-Deref}

  \semrule{Phi-Struct}
\end{mathpar}

Enfin, pour évaluer un chemin dans un tableau, on commence par procéder comme
précédemment, c'est-à-dire en évaluant la left-value sur laquelle porte
l'opération d'indexation. Puis on évalue l'expression d'indice en une valeur qui
permet de construire le chemin résultant.

\begin{mathpar}
  \semrule{Phi-Array}
\end{mathpar}

Notons qu'en procédant ainsi, on évalue les left-values de gauche à droite :
dans l'expression $x[e_1][e_2][e_3]$, $e_1$ est évalué en premier, puis
$e_2$, puis $e_3$.

Un exemple d'évaluation est donné dans la figure~\ref{fig:eval-lv}.

\subsection*{Expressions}

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \semrule{Exp-Cst}
\end{mathpar}

De même, une fonction n'est pas évaluée plus :

\begin{mathpar}
  \semrule{Exp-Fun}
\end{mathpar}

% TODO vraiment?

Pour lire le contenu d'un emplacement mémoire (left-value), il faut tout d'abord
l'évaluer en un chemin.

\begin{mathpar}
  \semrule{Exp-Lv}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, est encore imposé : de gauche à droite). À
chaque opérateur $\opbin$, correspond un opérateur sémantique $\widehat{\opbin}$
qui agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers. Afin d'interdire la division par zéro, celle ci et le
modulo sont traités dans une règle à part.

\begin{mathpar}
  \semrule{Exp-UnOp}

  \semrule{Exp-BinOp}

  \semrule{Exp-Div}
\end{mathpar}

Il est nécessaire de dire un mot sur les opérations $\widehat{+_p}$
et $\widehat{-_p}$ définissant l'arithmétique des pointeurs. Celles-ci sont
uniquement définies pour les références mémoire à un tableau, c'est à dire
celles qui ont la forme $φ[n]$. On a alors :

\begin{align*}
  φ[n] +_p m = & φ[n+m] \\
  φ[n] -_p m = & φ[n-m] \\
\end{align*}

Pour prendre l'adresse d'une variable, il suffit de résoudre celle-ci dans
l'état mémoire courant.

\begin{mathpar}
  \semrule{Exp-AddrOf}
\end{mathpar}

L'affectation se déroule 3 étapes : d'abord, l'expression est évaluée en une
valeur $v$. Ensuite, la left-value est évaluée en un chemin $φ$. Enfin, un
nouvel état mémoire est construit, où la valeur accessible par $φ$ est remplacée
par $v$. Comme dans le langage C, l'expression d'affectation produit une valeur,
qui est celle qui a été affectée.

\begin{mathpar}
  \semrule{Exp-Set}
\end{mathpar}

\subsection*{Expressions composées}

On commence par définir une opération d'évaluation de plusieurs expressions à la
fois : on note

\begin{mathpar}
  \evstar{m}{e_1 \\ \vdots \\ e_n}
         {m'}{v_1 \\ \vdots \\ v_n}
\end{mathpar}

si $∃ (m_1, …, m_n) , ∀ i ∈ [ 1; n-1 ], \mm{m_i}{e_i}{m_{i+1}}{e_{i+1}} $ avec
$m = m_1$ et $m' = m_n$.

Notons que l'évaluation se fait encore de gauche à droite. On utilise la
notation vecteur colonne pour signifier qu'il s'agit ici de métasyntaxe (il n'y
a pas de tuples dans le langage).

Cette évaluation chaînée est au coeur de la règle suivante qui permet d'évaluer
les structures : à une structure (syntaxique) correspond une valeur structurelle
dont les champs sont ceux de la première structure évalués :

\begin{mathpar}
  \semrule{Exp-Struct}
\end{mathpar}

De même, l'évaluation d'un littéral de tableau se fait en évaluant de gauche à
droite ses éléments :

\begin{mathpar}
  \semrule{Exp-Array}
\end{mathpar}

\shorthandoff{!}
\begin{figure}

  \centering

  \begin{tikzpicture}
    [node distance=2cm]

    \node (m0) {$m_0$};
    \node[below of=m0]                    (m1) {$m_1$};
    \node[below of=m1]                    (m2) {$m_2$};
    \node[right of=m2, node distance=3cm] (m3) {$m_3$};
    \node[below of=m3]                    (m4) {$m_4$};
    \node[right of=m4, node distance=3cm] (m5) {$m_5$};
    \node[below of=m5]                    (m6) {$m_6$};
    \node[below of=m6]                    (m7) {$m_7$};
    \node at ($(m1)!(m7)!(0,1)$)          (m8) {$m_8$};
    \node[below of=m8]                    (m9) {$m_9$};

    \draw [->] (m0) -- node[auto] {$e → \mathrm{fun}(\vec{a})
                                   (\vec{l}↦\vec{e'})\{i\}$}            (m1);
    \draw [->] (m1) -- node[auto] {$\vec{e} → \vec{v}$}                 (m2);
    \draw [->] (m2) -- node[auto] {$\mathrm{Push}(\vec{a}↦\vec{v})$}    (m3);
    \draw [->] (m3) -- node[auto] {$\vec{e'} → \vec{v'}$}               (m4);
    \draw [->] (m4) -- node[auto] {$\mathrm{Extend}(\vec{l}↦\vec{v'})$} (m5);
    \draw [->] (m5) -- node[auto] {$i → \iReturn{e}$}                   (m6);
    \draw [->] (m6) -- node[auto] {$e → v$}                             (m7);
    \draw [->] (m7) -- node[auto] {$\mathrm{Pop}$}                      (m8);
    \draw [->] (m8) -- node[auto] {$\mathrm{Cleanup}$}                  (m9);

    \draw [dashed, ->] ($ (m0) + (-5mm, -3mm) $)
                    -- node[auto, swap] {$f(\vec{e}) → v$}
                       ($ (m9) + (-5mm, 3mm) $);

  \end{tikzpicture}

  \caption{L'appel d'une fonction. La taille de la pile croît de gauche à
  droite, et les réductions se font de haut en bas.}
  \label{fig:fcall-details}

\end{figure}
\shorthandon{!}

L'appel de fonction repose également sur cette évaluation multiple. Tout
d'abord, les arguments sont évalués et placés dans un nouveau cadre de pile.
Puis les expressions qui initialisent les variables locales sont elle aussi
évaluées et ajoutées à ce même cadre de pile (opérateur $\mathrm{Extend}$).
Ensuite, le corps de la fonction est évalué jusqu'à se réduire en une
instruction $\iReturn{v}$. Puis, le cadre précédemment utilisé est dépilé.

La dernière étape consiste à nettoyer la mémoire de références à l'ancien cadre
de pile. En effet, si une référence au dernier cadre est toujours présente après
le retour, elle pourra se résoudre en un objet différent plus tard dans
l'exécution du programme.

La fonction $\mathrm{Cleanup}$ est donnée par :

\def\cleanuplist#1#2{\mathrm{CleanupList}(#1, #2)}
\def\cllive#1#2{\mathrm{Live}(#1, #2)}

\begin{align*}
  \mathrm{Cleanup}(s, g)  = & (s', g') \\
                    où g' = & \cleanuplist{|s|}{g} \\
                       s' = & [\cleanuplist{|s|}{s_1},
                            …, \cleanuplist{|s|}{s_n}] \\
       \cleanuplist{p}{u} = & \{(x, v) ∈ u / v\mbox{ n'est pas une adresse} \} \\
                       \cup & \{(x, φ) ∈ u / \cllive{p}{φ} \} \\
    \cllive{p}{(n, x)} = & n < p \\
    \cllive{p}{(x)}    = & \mathrm{Vrai} \\
    \cllive{p}{*φ}     = & \cllive{p}{φ} \\
    \cllive{p}{φ.f}    = & \cllive{p}{φ} \\
    \cllive{p}{φ[n]}   = & \cllive{p}{φ}
\end{align*}

Sans cette règle, examinons le programme suivant :

\begin{Verbatim}
f ()                g (p)           h ()
  (x=0)               (x=0.0)         (p=f())
{                   {               {
  return (&x);        *p = 1;         g(p);
}                   }               }
\end{Verbatim}

L'exécution de $h()$ donne à $p$ la valeur $(1, x)$. Donc en arrivant dans $g$, le
déréférencement de $p$ va modifier $x$.

\begin{figure}
  \centering


  \begin{tikzpicture}
    [ stack/.style={draw,minimum height=5mm,minimum width=3cm ,shape=rectangle}
    , every node/.style={font=\footnotesize}
    , faded/.style={fill=black!20}
    , substack/.style={draw, minimum height=5mm, }
    , oldstack/.style={loosely dashed}
    , fixmatrix/.style={matrix, row sep=-\pgflinewidth, column sep=-\pgflinewidth}
    , >=stealth'
    ]

    \path (0, 0)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p) { }; & \node { }; & \node (q) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x) { }; & \node (y) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, 0) {
          \node (r) { }; & \node { }; \\
      };

      \draw[->] (p.center) -- ++(0, 0.5);
      \draw[->] (q.center) -| ($ (r.center) - (3mm, 0) $);
      \draw[->] ($ (r.center) + (3mm, 0) $) |- (y.center);

      %%%%%

    \path (0, -3)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [stack, faded] {}
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, minimum width=10mm}] {
        \node (p2) { }; & \node { }; & \node (q2) { }; \\
      }
      -- ++ (0, 0.5)
      node [fixmatrix, nodes={substack, oldstack, minimum width=15mm}]{
        \node (x2) { }; & \node (y2) { }; \\
      };

      \node [fixmatrix, nodes={substack, minimum width=15mm}]
        at (5, -3) {
          \node (r2) { }; & \node { }; \\
      };

      \draw[->] (q2.center) -| ($ (r2.center) - (3mm, 0) $);

      \def\crossat#1{
        \draw ($ #1 + (2mm, 2mm) $) -- ++ (-4mm, -4mm);
        \draw ($ #1 + (-2mm, 2mm) $) -- ++ (4mm, -4mm);
      }

      \crossat{(r2.center) + (3mm, 0)}
      \crossat{(p2.center)}

  \end{tikzpicture}

  \caption{Nettoyage d'un cadre de pile}
  \label{fig:stackcleanup}
\end{figure}

\begin{mathpar}
  \semrule{Exp-Call}
\end{mathpar}

Cette évaluation est décrite dans la figure~\ref{fig:fcall-details}.

\section{Instructions}

Contrairement à l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante :
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ "plus simple" en partant d'un état mémoire
$m'$. Un tel pas est noté :

\[
  \mmi{m}{i}{m'}{i'}
\]

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$ :

\begin{align*}
  \msi{m}{(x ← 3 ; y ← x)} → & \msi{m [x ↦ \widehat{3}]}{y ← x} \\
                           → & \msi{m [x ↦ \widehat{3}][y ↦ \widehat{3}]}{\iPass}
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \semrule{Seq}

  \semrule{Pass}

  \semrule{Exp}
\end{mathpar}

Pour traiter l'alternative, on a besoin de 2 règles. Elles commencent de la même
manière, en évaluant la condition. Si le résultat est 0 (et seulement dans ce
cas), c'est la règle \textsc{If-False} qui est appliquée et l'instruction
revient à évaluer la branche "else". Dans les autres cas, c'est la règle
\textsc{If-True} qui s'applique et la branche "then" qui est prise.

\begin{mathpar}
  \semrule{If-False}

  \semrule{If-True}
\end{mathpar}

Le traitement de la boucle est une simple règle de réécriture :

\begin{mathpar}
  \semrule{While}
\end{mathpar}

Cette règle revient à dire qu'on peut dérouler une boucle. Pour la comprendre,
on peut remarquer qu'une boucle "while" est en réalité équivalente une infinité
de "if" imbriqués.

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    if(e) {
        i;
        if(e) {
            i;
            if(e) {
                i;
                ...
            }
        }
    }
}
\end{Verbatim}
\end{minipage}

Donc en remplaçant le second "if" par le "while", on obtient :

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    while(e) {
        i
    }
}
\end{Verbatim}
\end{minipage}

Enfin, si un "return" apparaît dans une séquence, on peut supprimer la suite :

\begin{mathpar}
  \semrule{Return}
\end{mathpar}

\section{Phrases}

Un programme est constitué d'une suite de phrases : déclarations de fonctions,
de variables et de types, et évaluation d'expressions.

Il est donc logique que l'évaluation d'une phrase fasse passer d'un état mémoire
à un autre :

\[
  \ph{m}{p}{m'}
\]

La définition d'une structure est ignorée. En effet, celle-ci ne sert qu'au
typage.

\begin{mathpar}
  \semrule{Ph-Struct}
\end{mathpar}

L'évaluation d'une expression est uniquement faite pour ses effets de bord. Par
exemple, après avoir défini les fonctions du programme, on pourra appeller
$\textrm{main}()$.

\begin{mathpar}
  \semrule{Ph-Exp}
\end{mathpar}

La déclaration d'une variable globale (avec un initialiseur) consiste à évaluer
cet initialiseur et à étendre l'état mémoire avec ce couple (variable, valeur).

\begin{mathpar}
  \semrule{Ph-Var}
\end{mathpar}

\section{Exécution}

L'exécution d'un programme est sans surprise l'exécution de ses phrases, les
unes à la suite des autres.

On commence par étendre l'extension $→^*$ au listes de la relation $→$ :

\begin{mathpar}
  \semrule{Ph*-Nil}

  \semrule{Ph*-Cons}
\end{mathpar}

L'exécution d'un programme est alors :

\[
  \phstar{([], [])}{P}{m}
\]

\section{Exemple : l'algorithme d'Euclide}

Version par divisions successives:

\begin{Verbatim}
function gcd(a, b)
  var t = 0;
  while b != 0
    t = b
    b = a mod b
    a = t
  return a
\end{Verbatim}

Soit :

\def\exinnerif{t←b;b←a\%b;a←t}

\begin{mathpar}
  f(a, b) (t = 0) \{
    \iWhile{b ≠ 0}{
      \exinnerif
    };
    \iReturn{a}
  \}
\end{mathpar}

\[
  \msi{m}{f(1071, 462)} → ?
\]

\[
  \msi{m[a↦1071][b↦462][t↦0]}{\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} → ?
\]

(on notera cet état $s_0 = \msi{m_0}{i_0}$)

\[
  \mm{m_0}{a = 0}{m_0}{0}
\]

donc

\[
  \mm{m_0}{\iThen{a = 0}{\iReturn{b}}}{m[a↦1071][b↦462]}{\iPass}
\]

{ \scriptsize
\begin{align}
  s_0 → & \msi{m_0  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_0  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0  }{ b←a\%b;a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0''}{ a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_1  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_2  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_3  }{ \iPass; \iReturn{a}} \\
      → & \msi{m_3  }{ \iReturn{a}}
\end{align}

\begin{align*}
  m_0'  = & m_0  [t↦462] = m[a↦1071][b↦462][t↦462] \\
  m_0'' = & m_0' [b↦147] = m[a↦1071][b↦147][t↦462] \\
  m_1   = & m_0''[a↦462] = m[a↦462][b↦147][t↦462] \\
  m_2   = & m_1[t↦147][b↦21][a↦147] = m[a↦147][b↦21][t↦147] \\
  m_3   = & m_2[t↦21][b↦0][a↦21] = m[a↦21][b↦0][t↦21]
\end{align*}
}

\begin{center}\rule{3in}{0.4pt}\end{center}

\section*{TODO}

\begin{itemize}
\item liste d'assos -> fonction
\item interdire d'avoir plusieurs variables qui ont le même nom dans un cadre
\item dédupliquer la def de l'état mémoire
\item syntaxe concrète
\item procédures vs fonctions
\item top ?
\end{itemize}

% vim: spelllang=fr
