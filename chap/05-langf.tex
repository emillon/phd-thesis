On définit ici un langage impératif.

\section{Syntaxe}

Donnée dans la figure~\ref{fig:stx}.

\begin{figure}

  \gramlr{Constantes}{
    \begin{align*}
      c \gramisa & i & \textrm{Entier}
      \\ \gramor & f & \textrm{Flottant}
    \end{align*}
  }

  \gramlr{Expressions}{
    \begin{align*}
      e \gramisa & c               & \textrm{Constante}
      \\ \gramor & x               & \textrm{Variable}
      \\ \gramor & \opsymb~e       & \textrm{Opération unaire}
      \\ \gramor & e~\opsymb~e     & \textrm{Opération binaire}
      \\ \gramor & \& x            & \textrm{Pointeur}
      \\ \gramor & * e             & \textrm{Déréférencement}
      \\ \gramor & f (e_1, …, e_n) & \textrm{Appel de fonction}
    \end{align*}
  }

  \gramlr{Instructions}{
    \begin{align*}
      i \gramisa & \iPass        & \textrm{Instruction vide}
      \\ \gramor & i;i           & \textrm{Séquence}
      \\ \gramor & x ← e         & \textrm{Affectation}
      \\ \gramor & \iIf{e}{i}{i} & \textrm{Alternative}
      \\ \gramor & \iWhile{e}{i} & \textrm{Boucle}
      \\ \gramor & \iReturn{e}   & \textrm{Retour de fonction}
    \end{align*}
  }

  \gramlr{Fonctions}{
    \begin{align*}
      f \gramisa & (i, (x_1, …, x_n)) & \textrm{Corps et arguments}
    \end{align*}
  }

  \caption{Syntaxe}
  \label{fig:stx}
\end{figure}

\section{Sémantique}

On définit dans la suite une sémantique pour le langage défini dans la
figure~\ref{fig:stx}.

\section{État mémoire}

Un programme, pour s'exécuter, dispose de mémoire organisée en variables. Plus
précisément, lors de l'exécution de chaque fonction, un cadre de pile est créé,
contenant un ensemble de variables accessibles par cette fonction. Il y en outre
un ensemble de variables globales accessibles depuis n'importe quel point du
programme.

\begin{figure}

  \gramlr{Valeurs}{
    \begin{align*}
      v \gramisa & c & \textrm{Constante}
      \\ \gramor & a & \textrm{Adresse}
    \end{align*}
  }

  \gramlr{Adresses}{
    \begin{align*}
      a \gramisa & (n, x) & \textrm{Variable locale}
      \\ \gramor & x      & \textrm{Variable globale}
    \end{align*}
  }

  \gramlr{Pile}{
    \begin{align*}
      s \gramisa & []                                   & \textrm{Pile vide}
      \\ \gramor & \{ x_1 ↦ v_1 ; … ; x_n ↦ v_n \} :: s & \textrm{Ajout d'un cadre}
    \end{align*}
  }

  \gramlr{État mémoire}{
    \begin{align*}
      m \gramisa & (s, \{ x_1 ↦ v_1 ; … ; x_n ↦ v_n \}) & \textrm{Pile, globales}
    \end{align*}
  }

  \caption{Interpréteur}
  \label{fig:interp}
\end{figure}

Chaque fonction peut donc accéder aux variables du dernier cadre de pile, ainsi
qu'aux variables globales.

\[
  (x, v) ∈ m
\]

\[
  m[x ↦ v]
\]

\begin{definition}{Manipulations de pile}

  Empilement / dépilement

  \[
    \mathrm{Push}(s, (x_1, v_1), …, (x_n, v_n)) = \{ x_1 ↦ v_1 ; … ; x_n ↦ v_n \}~::~s
  \]

  \[
    \mathrm{Pop}(f~::~s) = s
  \]

  + extension aux $m$.

\end{definition}

\begin{definition}{Recherche de variable}

  \[
    \textrm{VarLookup} (x, (s, g)) =
      \begin{cases}
        x      & \mbox{si } x ∈ g \\
      (0, x)   & \mbox{si } x ∉ g \mbox{ et } s = f::[]
                 \mbox{ avec } x ∈ f \\
      (n+1, x) & \mbox{si } x ∉ g \mbox{ et } s = f::s'
                 \mbox{ avec } \textrm{VarLookup} (x, (s, g)) = (n, x)
      \end{cases}
  \]

\end{definition}

\section{Expressions}

Réduction (grand pas) :

\[
  (m, e) → (m', v)
\]

Constante :

$\widehat{c}$ désigne la valeur (sémantique) de la constante (syntaxique) $c$.

\begin{mathpar}
  \irule{Exp-Cst}
    { }
    {(m, c) → (m, \widehat{c})}
\end{mathpar}

Cas variable :

\begin{mathpar}
  \irule{Exp-Var}
  {(x, v) ∈ m}
  {(m, x) → (m, v)}
\end{mathpar}

Cas op :

\begin{mathpar}
  \irule{Exp-UnOp}
  {(m, e) → (m', v) \\ v' = \widehat{\opsymb}~v}
  {(m, \opsymb~e) → (m', v') }
\end{mathpar}

À chaque opérateur $\opsymb$, correspond un opérateur sémantique
$\widehat{\opsymb}$ qui agit sur les valeurs. Par exemple, l'opérateur
$\widehat{+}$ est l'addition classique entre entiers.

\begin{mathpar}
  \irule{Exp-BinOp}
  {(m, e_1) → (m', v_1) \\
   (m', e_2) → (m'', v_2) \\
   v' = v_1~\widehat{\opsymb}~v_2
  }
  {
    (m, e_1~\opsymb~e_2) → (m'', v')
  }
\end{mathpar}

Adresse :

\begin{mathpar}
  \irule{Exp-AddrOf}
    {a = \textrm{VarLookup} (x, m)}
    {(m, \&x) → (m, a)}
\end{mathpar}

Déréférencement :

\begin{mathpar}
  \irule{Exp-AddrOf}
    { (m, e) → (m', a) \\
      (a, v) ∈ m'
    }
    {
      (m, *e) → (m', v)
    }
\end{mathpar}

Appel de fonction :

\[
  \irule{Call}
  {(m  , e_1) → (m_1, v_1) \\
   (m_1, e_2) → (m_2, v_2) \\
   … \\
   (m_{n-1}, e_n) → (m_n, v_n) \\
   f = (i, arg_1, …, arg_n) \\
   m' = \mathrm{Push}(m_n, (arg_1, v_1), …, (arg_n, v_n)) \\
   (m', i) → (m'', \iReturn{v}) \\
   m''' = \mathrm{Pop}(m'')
  }
  {(m, f(e_1, …, e_n)) → (m''', v)}
\]

\section{Instructions}

(attention au pas)

\[
  \irule{Set}
  {
    (m, e) → (m', v) \\
    m'' = m' [ x ↦ v ]
  }
  {(m, x ← e) → (m'', pass)}
\]

\begin{itemize}
\item
  ajout des adresses
\item
  declaration
\item
  champs de records
\end{itemize}
