On définit ici un langage impératif servant de base à nos analyses. Un premier
système de types sera donné dans le chapitre~\ref{cha:typbase}.

\section{Syntaxe}

La figure~\ref{fig:stx} présente notre langage intermédiaire. Il contient la
plupart des fonctionnalités présentes dans les langages impératifs comme C.

Un programme est organisé en fonctions, qui contiennent des instructions, qui
elles-même manipulent des expressions. Le flôt de contrôle est minimal, avec un
opérateur d'alternative et de boucle.

Pour l'alternative, on introduit également la forme courte $\iThen{e}{i} =
\iIf{e}{i}{\iPass}$.

Les opérateurs sont donnés dans la figure~\ref{fig:stx-ops}.

\begin{figure}

  \gramlr{Constantes}{
    \begin{align*}
      c \gramisa & i      & \textrm{Entier}
      \\ \gramor & f      & \textrm{Flottant}
      \\ \gramor & \eNull & \textrm{Pointeur nul}
    \end{align*}
  }

  \gramlr{Expressions}{
    \begin{align*}
      e \gramisa & c               & \textrm{Constante}
      \\ \gramor & lv              & \textrm{Accès mémoire}
      \\ \gramor & \opsymb~e       & \textrm{Opération unaire}
      \\ \gramor & e~\opsymb~e     & \textrm{Opération binaire}
      \\ \gramor & \& x            & \textrm{Pointeur}
      \\ \gramor & lv ← e          & \textrm{Affectation}
      \\ \gramor & \{ f_1 : e_1 ;
                  … ; f_n : e_n \} & \textrm{Structure}
      \\ \gramor & \{e_1 ;…; e_n\} & \textrm{Tableau}
      \\ \gramor & f (e_1, …, e_n) & \textrm{Appel de fonction}
    \end{align*}
  }

  \gramlr{Left-values}{
    \begin{align*}
      lv \gramisa & x     & \textrm{Variable}
      \\  \gramor & *lv   & \textrm{Déréférencement}
      \\  \gramor & lv.f  & \textrm{Accès à un champ}
      \\  \gramor & lv[n] & \textrm{Accès à un élément}
    \end{align*}
  }

  \gramlr{Instructions}{
    \begin{align*}
      i \gramisa & \iPass        & \textrm{Instruction vide}
      \\ \gramor & i;i           & \textrm{Séquence}
      \\ \gramor & e             & \textrm{Expression}
      \\ \gramor & \iIf{e}{i}{i} & \textrm{Alternative}
      \\ \gramor & \iWhile{e}{i} & \textrm{Boucle}
      \\ \gramor & \iReturn{e}   & \textrm{Retour de fonction}
    \end{align*}
  }

  \gramlr{Fonctions}{
    \begin{align*}
      f \gramisa & (i,                             & \textrm{Corps} \\
                 & (x_1, …, x_n),                  & \textrm{Arguments} \\
                 & ((x'_1, e_1), …, (x'_p, e_p)))  & \textrm{Variables locales}
    \end{align*}
  }

  \gramlr{Programme}{
    \begin{align*}
      P \gramisa & ((f_1, …, f_n),   & \textrm{Fonctions} \\
                 & ((x_1, e_1), …, (x_p, e_p))) & \textrm{Globales}
    \end{align*}
  }

  \caption{Syntaxe}
  \label{fig:stx}
\end{figure}

\begin{figure}

  \gramlr{Opérateurs}{
    \begin{align*}
      \opsymb \gramisa & +,-,\times,/      & \textrm{Arithmétique entière}
      \\      \gramor  & +.,-.,\times.,/.  & \textrm{Arithmétique flottante}
      \\      \gramor  & =,≠,≤,≥,<,>       & \textrm{Comparaisons}
      \\      \gramor  & \&,|,\opxor,\sim  & \textrm{Opérateurs bit à bit}
      \\      \gramor  & \&\&,||,!         & \textrm{Opérateurs logiques}
      \\      \gramor  & \ll, \gg          & \textrm{Décalages}
    \end{align*}
  }

  \caption{Syntaxe des opeérateurs}
  \label{fig:stx-ops}
\end{figure}

\section{Définitions préliminaires}

On suppose avoir à notre disposition un ensemble infini dénombrable
d'identificateurs \sId (par exemple des chaînes de caractères).

$X^*$ est l'ensemble des suites finies de $X$, indexées à partir de 1. Si $u ∈
X^*$, on note $|u|$ le nombre d'éléments de $u$ (le cardinal de son ensemble de
définition). Pour $1 ≤ i ≤ |u|$, on note $u_i = u(i)$ le i-ème élément de la
suite.

On peut aussi voir les suites comme des listes : on note $[]$ la suite vide,
telle que $|[]| = 0$. On définit en outre la construction de suite de la manière
suivante : si $x ∈ X$ et $u ∈ X^*$, la liste $x::u ∈ X^*$ est la liste $v$ telle
que :

\begin{align*}
  v_1 = & x \\
  ∀ i ∈ [1; |u|] , v_{i+1} = & u_i
\end{align*}

\section{Mémoire}

L'interprète que nous nous apprêtons à définir manipule des valeurs qui sont
associées aux variables du programme.

\begin{align*}
  \sVal = & \sInt \bigdcup \sFloat \bigdcup \sAddr \\
  \sInt = & ℤ/2^{32} ℤ - 2^{31} \\
  \sAddr = & \sId \bigdcup (ℕ × \sId) \\
  \sFloat = & \textsc{IeeeFloat}(32)
\end{align*}

\sFloat correspond à l'ensemble des flottants IEEE 754\cite{ieee754}. Ici, \sInt
est choisi pour représenter les nombres entiers de $-2^{31}$ à $2^{31}-1$, mais
ce choix est arbitraire : de la même manière, on aurait pu choisir des nombres à
64 bits ou même de précision arbitraire.

L'ensemble des états mémoire est :

\[
  \sMem = {\sId^*}^* × \sId^* × \sVal^\sAddr
\]

L'interprétation est la suivante : une adresse est soit un nom de variable
globale, soit un nom de variable locale à un niveau donné.

Un état mémoire contient deux ensembles de variables (locales et globales), et
une fonction qui à chacune de ces variables associe une valeur.

Plus précisément, un état mémoire $m = (s, g, l)$ est composé de :

\begin{itemize}
\item
  une pile de variables locales $s$. Celles-ci sont organisées en
  niveaux indépendants : à chaque appel de fonction, un nouveau cadre de
  pile est créé, comprenant ses paramètres et ses variables locales.
\item
  un ensemble de variables globales $g$. Contrairement aux variables
  locales, il n'y a pas de système d'empilement, puisque toutes ces
  variables sont accessibles depuis tout point du programme.
\item
  une liste d'associations $l$ qui à chaque adresse mémoire associe une
  valeur.
\end{itemize}

Les variables qui apparaissent dans $s$ et $g$ sont uniquement des symboles
(leurs noms) : les valeurs sont dans $l$.

Les adresses intervenant dans $l$ sont soit un nom de variable globale, soit un
couple $(n, x)$ où $n$ est un entier qui correspond à la hauteur de pile de la
variable considérée. Cela permet de distinguer entre deux variables qui ont le
même nom, par exemple dans le cas d'un appel récursif.

Ces définitions sont résumées dans la figure~\ref{fig:interp}

\begin{figure}

  \gramlr{Valeurs}{
    \begin{align*}
      v \gramisa & c               & \textrm{Constante}
      \\ \gramor & a               & \textrm{Adresse}
      \\ \gramor & \{ f_1 : v_1 ;
                  … ; f_n : v_n \} & \textrm{Structure}
      \\ \gramor & \{v_1 ;…; v_n\} & \textrm{Tableau}
    \end{align*}
  }

  \gramlr{Adresses}{
    \begin{align*}
      a \gramisa & (n, x) & \textrm{Variable locale}
      \\ \gramor & x      & \textrm{Variable globale}
    \end{align*}
  }

  \gramlr{Chemins}{
    \begin{align*}
      φ \gramisa & a    & \textrm{Adresse}
      \\ \gramor & *φ   & \textrm{Déréférencement}
      \\ \gramor & φ.f  & \textrm{Accès à un champ}
      \\ \gramor & φ[n] & \textrm{Accès à un élément}
    \end{align*}
  }

  \gramlr{Pile}{
    \begin{align*}
      s \gramisa & []                                   & \textrm{Pile vide}
      \\ \gramor & \{ x_1 ; … ; x_n \} :: s & \textrm{Ajout d'un cadre}
    \end{align*}
  }

  \gramlr{État mémoire}{
    \begin{align*}
      m \gramisa & (s,                    & \textrm{Pile}      \\
                 & \{ x_1 ;…; x_n \},     & \textrm{Globales}  \\
                 & \{a_1↦v_1;…;a_p↦v_p\}) & \textrm{Valeurs}
    \end{align*}
  }

  \caption{Interpréteur}
  \label{fig:interp}
\end{figure}

\begin{definition}[Recherche de variable]

  La recherche de variable permet d'associer à une variable $x$ une adresse $a$.

  Chaque fonction peut accéder aux variables locales de la fonction en cours,
  ainsi qu'aux variables globales.

  \begin{align*}
    \mathrm{Lookup} ((s, g), x) = & (|s|, x)
                                    \mbox{ si }|s| > 0
                                    \mbox{ et }∃ (x, v) ∈ s_1 \\
    \mathrm{Lookup} ((s, g), x) = & x \mbox{ si } (x, v) ∈ g
  \end{align*}

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. De même, en
retournant il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  On définit l'empilement d'un cadre de pile :

  \[
    \mathrm{Push}(s, (x_1, …, x_n)) = \{ x_1 ; … ; x_n \}::s
  \]

  On peut étendre cette notation aux états mémoire, en associant des valeurs à
  ces nouvelles variables :

  \[
    \mathrm{Push}((s, g, l), ((x_1, v_1), …, (x_n, v_n))) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Push}(s, (x_1, …, x_n)) \\
    l' = & l \bigdcup \{(p, x_1) ↦ v_1; … ; (p, x_n) ↦ v_n\} \\
    p  = & |s| + 1
  \end{align*}

  On définit aussi l'extension du dernier cadre de pile :

  \[
    \mathrm{Extend}(f::s, x) = ((f::x) :: s)
  \]

  et son extension triviale aux états mémoire.

  De même on définit le dépilement :

  \[
    \mathrm{Pop}(f::s) = s
  \]

  ainsi que son extension aux états mémoire :

  \[
    \mathrm{Pop}((s, g, l)) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Pop}(s) \\
    l' = & \{ (x) ∈ l \} \bigdcup \{ (p, x) ∈ l \mbox{ où } p < |s| \}
  \end{align*}

\end{definition}

\section{Accesseurs}

On définit quelques accesseurs. Un accesseur $ [ \cdot ] $ permet d'accéder à
une structure $s$ et d'obtenir un élément $e$ à partir d'un indice $i$ (noté $e
= s [ i ]$) ou de modifier le sous-élément à l'indice $i$ par $e$ (noté $ s [ i
← e ] $).

\begin{definition}[Accès à une liste d'associations]

  \begin{align*}
    l[x]_l     = & v \mbox{ où } \{v\} = \{y / (x, y) ∈ l\} \\
    l[x ← v]_l = & (x, v) :: \{ (y, v) ∈ g(x) / y ≠ x \})
  \end{align*}

\end{definition}

\begin{definition}[Accès par adresse]

  L'accesseur de base pour les états mémoire est l'accesseur par adresse
  $[\cdot]_a$.

  Pour $m = (s, g)$,

  \begin{align*}
    m [x]_a          = & g[x]_l        & \textrm{Lecture d'une globale} \\
    m [(n, x)]_a     = & l_n[x]_l      & \textrm{Lecture d'une locale} \\
    m [x ← v]_a      = & (s, g[x←v]_l) & \textrm{Écriture d'une globale} \\
    m [(n, x) ← v]_a = & (s', g)       & \textrm{Écriture d'une locale} \\
           \mbox{ où } & s'_n = s_n[x ← v]_l \\
                       & ∀ i ≠ n, s'_i = s_i
  \end{align*}

\end{definition}

\begin{definition}[Accès par champ]

  \begin{align*}
    \{ f_1 : v_1; … ; f_n : v_n \}[f_i]_f = & v_i \\
    \{ f_1 : v_1; … ; f_n : v_n \}[f_p ← v]_f = & \{ f_1 : v'_1; … ; f_n : v'_n \} \\
          \mbox{ où } & v'_p = v \\
                      & ∀ i ≠ p, v'_i = v_i
  \end{align*}

\end{definition}

\begin{definition}[Accès par indice]

  \begin{align*}
    \{ v_1 ; … ; v_n \} [i]_i   = & e_i \\
    \{ v_1 ; … ; v_n \} [i←v]_i = & \{ v'_1 ; … ; v'_n \} \\
                      \mbox{ où } & v'_i = v \\
                                  & ∀j≠i, v'_j = v_j
  \end{align*}

\end{definition}

\begin{definition}[Accès par chemin]

  \begin{align*}
    m[a]_φ        = & m[a]_a \\
    m[*φ]_φ       = & m[a]_a \mbox{ où } a = m[φ]_φ \\
    m[φ.f]_φ      = & m[φ]_φ[f]_f \\
    m[φ[i]]_φ     = & m[φ]_φ[i]_i \\
    m[a ← v]_φ    = & m[a ← v]_a \\
    m[*φ ← v]_φ   = & m[a ← v]_a \mbox{ où } a = m[φ]_φ \\
    m[φ.f ← v]_φ  = & m[φ ← (m[φ]_φ[f←v]_f)]_φ \\
    m[φ[i] ← v]_φ = & m[φ ← (m[φ]_φ[i←v]_i)]_φ
  \end{align*}

\end{definition}

\section{Expressions}

\begin{definition}[Évaluation d'une expression]

  L'évaluation d'une expression $e$ se fait sous un état mémoire particulier $m$
  et est susceptible de modifier celui-ci en le transformant en un nouveau $m'$.
  Le résultat est toujours une valeur $v$, c'est à dire que nous présentons pour
  les expressions une sémantique à grands pas. Cette évaluation est notée :

  \[
    \mm{m}{e}{m'}{v}
  \]

\end{definition}

\begin{definition}[Évaluation d'une left-value]

  L'évaluation d'une left-value $lv$ produit un "chemin" $φ$ dans une variable,
  qui est en fait équivalent à une left-value dont toutes les sous-expressions
  (d'indices) ont été évaluées.

  On note :

  \[
    \mmlv{m}{lv}{m'}{φ}
  \]

\end{definition}

Puisque des left-values peuvent apparaitre dans les expressions, et des
expressions dans les left-values (en indice de tableau), leurs règles
d'évaluation sont mutuellement récursives.

Commençons par décrire le cas des left-values. Obtenir un chemin à partir d'un
nom de variable revient à résoudre le nom de cette variable : est-elle
accessible ? Le nom désigne-t'il une variable locale ou une variable globale ?

\begin{mathpar}
  \irule{Phi-Var}
    { a = \mathrm{Lookup}(x, m) }
    {
      \mmlv{m}{x}{m}{a}
    }
\end{mathpar}

Les règles portant sur le déréférencement et l'accès à un champ de structure
sont similaires : on commence par évaluer la left-value sur laquelle porte ce
modificateur, et on place le même modificateur sur le chemin résultant.

\begin{mathpar}
  \irule{Phi-Deref}
    { \mmlv{m}{ lv}{m'}{ φ} }
    { \mmlv{m}{*lv}{m'}{*φ} }

  \irule{Phi-Struct}
    { \mmlv{m}{lv  }{m'}{φ  } }
    { \mmlv{m}{lv.f}{m'}{φ.f} }
\end{mathpar}

Enfin, pour évaluer un chemin dans un tableau, on commence par procéder comme
précédemment, c'est-à-dire en évaluant la left-value sur laquelle porte
l'opération d'indexation. Puis on évalue l'expression d'indice en une valeur qui
permet de construire le chemin résultant.

\begin{mathpar}
  \irule{Phi-Array}
    { \mmlv{m}{lv}{m'}{φ} \\
      \mm{m'}{e}{m''}{v}
    }
    { \mmlv{m}{lv[e]}{m''}{φ[v]} }
\end{mathpar}

Notons qu'en procédant ainsi, on évalue les left-values de gauche à droite :
dans l'expression $x[e_1][e_2][e_3]$, $e_1$ est évalué en premier, puis
$e_2$, puis $e_3$.

Revenons au expressions.

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \irule{Exp-Cst}
    { }
    {\mm{m}{c}{m}{\widehat{c}}}
\end{mathpar}

Pour lire le contenu d'un emplacement mémoire (left-value), il faut tout d'abord
l'évaluer en un chemin.

\begin{mathpar}
  \irule{Exp-Lv}
  { \mmlv{m}{lv}{m'}{φ} \\
    v = m'[φ]
  }
  {\mm{m}{lv}{m'}{v}}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, de gauche à droite, est imposé). À chaque
opérateur $\opsymb$, correspond un opérateur sémantique $\widehat{\opsymb}$ qui
agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers. Afin d'interdire la division par zéro, celle ci et le
modulo sont traités dans une règle à part.

\begin{mathpar}
  \irule{Exp-UnOp}
  {\mm{m}{e}{m'}{v}}
  {\mm{m}{\opsymb~e}{m'}{\widehat{\opsymb}~v}}

  \irule{Exp-BinOp}
  { \opsymb ∉ \{/, \%\} \\
      \mm{m}{e_1}{m'}{v_1} \\
      \mm{m'}{e_2}{m''}{v_2}
  }
  {\mm{m}{e_1~\opsymb~e_2}{m''}{v_1~\widehat{\opsymb}~v_2}}

  \irule{Exp-Div}
  { \opsymb ∈ \{/, \%\} \\
    \mm{m}{e_1}{m'}{v_1} \\
    \mm{m'}{e_2}{m''}{v_2}
    v_2 ≠ \widehat{0}
  }
  {\mm{m}{e_1~\opsymb~e_2}{m''}{v_1~\widehat{\opsymb}~v_2}}
\end{mathpar}

Adresse :

\begin{mathpar}
  \irule{Exp-AddrOf}
    { a = \mathrm{Lookup} (x, m)
    }
    {\mm{m}{\&x}{m}{a}}
\end{mathpar}

\begin{mathpar}
  \irule{Exp-Set}
  {
    \mm{m}{e}{m'}{v} \\
    \mmi{m'}{lv}{m''}{φ} \\
    m''' = m'' [ φ ← v ]
  }
  {\mm{m}{lv ← e}{m'''}{v}}
\end{mathpar}

L'évaluation d'un appel de fonction commence de manière semblable au cas d'un
opérateur : on évalue de gauche à droite les arguments. Ceux-ci sont ensuite
placés dans un nouveau cadre de pile. Le corps de la fonction est évalué dans
cet environnement, et le cadre dépilé.

On commence par définir une opération d'évaluation de plusieurs expressions à la
fois : on note

\begin{mathpar}
  \evstar{m}{e_1 \\ \vdots \\ e_n}
         {m'}{v_1 \\ \vdots \\ v_n}
\end{mathpar}

si $∃ (m_1, …, m_n) , ∀ i ∈ [ 1; n-1 ], \mm{m_i}{e_i}{m_{i+1}}{e_{i+1}} $ avec
$m = m_1$ et $m' = m_n$.

Notons que l'évaluation se fait dans un ordre précis : de gauche à droite. On
utilise la notation vecteur colonne pour signifier qu'il s'agit ici de
métasyntaxe (il n'y a pas de tuples dans le langage).

Cette évaluation chaînée est au coeur de la règle suivante qui permet d'évaluer
les structures : à une structure (syntaxique) correspond une valeur structurelle
dont les champs sont ceux de la première structure évalués :

\begin{mathpar}

  \irule{Exp-Struct}
  {
    \evstar{m}{e_1 \\ \vdots \\ e_n}
          {m'}{v_1 \\ \vdots \\ v_n}
  }
  {
    \mm{m}{ \{ f_1 : e_1 ; … ; f_n : e_n \} }
      {m'}{ \{ f_1 : v_1 ; … ; f_n : v_n \} }
  }
\end{mathpar}

\shorthandoff{!}
\begin{figure}

  \centering

  \begin{tikzpicture}
    [node distance=2cm]

    \node (m0) {$m_0$};
    \node[below of=m0]                    (m1) {$m_1$};
    \node[right of=m1, node distance=3cm] (m2) {$m_2$};
    \node[below of=m2]                    (m3) {$m_3$};
    \node[right of=m3, node distance=3cm] (m4) {$m_4$};
    \node[below of=m4]                    (m5) {$m_5$};
    \node[below of=m5]                    (m6) {$m_6$};
    \node at ($(m0)!(m6)!(0,1)$)          (m7) {$m_7$};

    \draw [->] (m0) -- node[auto] {$\vec{e} → \vec{v}$}               (m1);
    \draw [->] (m1) -- node[auto] {$\mathrm{Push}(\vec{a}↦\vec{v})$}  (m2);
    \draw [->] (m2) -- node[auto] {$\vec{e'} → \vec{v'}$}             (m3);
    \draw [->] (m3) -- node[auto] {$\mathrm{Extend}(\vec{l}↦\vec{v'})$} (m4);
    \draw [->] (m4) -- node[auto] {$i → \iReturn{e}$}                 (m5);
    \draw [->] (m5) -- node[auto] {$e → v$}                           (m6);

    \draw [->] (m6) -- node[auto] {$\mathrm{Pop}(\vec{a} \bigdcup \vec{l})$} (m7);

    \draw [dashed, ->] ($ (m0) + (-5mm, -3mm) $)
                    -- node[auto, swap] {$f(\vec{e}) → v$}
                       ($ (m7) + (-5mm, 3mm) $);

  \end{tikzpicture}

  \caption{L'appel d'une fonction}
  \label{fig:fcall-details}

\end{figure}
\shorthandon{!}

L'appel de fonction repose également sur cette évaluation multiple. Tout
d'abord, les arguments sont évalués et placés dans un nouveau cadre de pile.
Puis les expressions qui initialisent les variables locales sont elle aussi
évaluées et ajoutées à ce même cadre de pile (opérateur $\mathrm{Extend}$).
Ensuite, le corps de la fonction est évalué jusqu'à se réduire en une
instruction $\iReturn{v}$. Enfin, le cadre précédemment utilisé est dépilé.
Cette évaluation est décrite dans la figure~\ref{fig:fcall-details}.

\begin{mathpar}
  \irule{Exp-Call}
  {
    f = (i, (a_1, …, a_n), ((l'_1, l'_1), …, (l'_p, e'_p))) \\
    \evstar{m_0}{e_1 \\ \vdots \\ e_n}
           {m_1}{v_1 \\ \vdots \\ v_n} \\
    m_2 = \mathrm{Push}(m_1, ((a_1, v_1), …, (a_n, v_n))) \\
    \evstar{m_2}{e'_1 \\ \vdots \\ e'_p}
           {m_3}{v'_1 \\ \vdots \\ v'_p} \\
    m_4 = \mathrm{Extend}(m_3, ((l_1, v_1), …, (l_n, v_n))) \\
    \mm{m_4}{i}{m_5}{\iReturn{e}} \\
    \mm{m_5}{e}{m_6}{v} \\
    m_7 = \mathrm{Pop}(m_6)
  }
  {\mm{m_0}{f(e_1, …, e_n)}{m_6}{v}}
\end{mathpar}

\section{Instructions}

Contrairement à l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante :
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ "plus simple" en partant d'un état mémoire
$m'$. Un tel pas est noté :

\[
  \mmi{m}{i}{m'}{i'}
\]

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$ :

\begin{align*}
  \msi{m}{(x ← 3 ; y ← x)} → & \msi{m [x ↦ \widehat{3}]}{y ← x} \\
                           → & \msi{m [x ↦ \widehat{3}][y ↦ \widehat{3}]}{\iPass}
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \irule{Seq}
    {
      \mmi{m}{i}{m'}{\iPass}
    }
    {
      \mmi{m}{(i;i')}{m'}{i'}
    }

  \irule{Pass}
    {
    }
    {
      \mmi{m}{(\iPass;i)}{m}{i}
    }

  \irule{Exp}
    { \mm{m}{e}{m'}{v} }
    { \mmi{m}{e}{m'}{\iPass} }

\end{mathpar}

Pour traiter l'alternative, on a besoin de 2 règles. Elles commencent de la même
manière, en évaluant la condition. Si le résultat est 0 (et seulement dans ce
cas), c'est la règle \textsc{If-False} qui est appliquée et l'instruction
revient à évaluer la branche "else". Dans les autres cas, c'est la règle
\textsc{If-True} qui s'applique et la branche "then" qui est prise.

\begin{mathpar}
  \irule{If-False}
    {
      \mm{m}{e}{m'}{\widehat{0}} \\
      \mmi{m'}{i_f}{m''}{i'}
    }
    {
      \mmi{m}{\iIf{e}{i_t}{i_f}}{m''}{i'}
    }

  \irule{If-True}
    {
      \mm{m}{e}{m'}{v} \\
      v ≠ \widehat{0} \\
      \mmi{m'}{i_t}{m''}{i'}
    }
    {
      \mmi{m}{\iIf{e}{i_t}{i_f}}{m''}{i'}
    }
\end{mathpar}

Le traitement de la boucle est une simple règle de réécriture :

\begin{mathpar}
  \irule{While}
    { }
    {
      \mmi{m}{\iWhile{e}{i}}{m}{\iThen{e}{i;\iWhile{e}{i}}}
    }
\end{mathpar}

Cette règle revient à dire qu'on peut dérouler une boucle. Pour la comprendre,
on peut remarquer qu'une boucle "while" est en réalité équivalente une infinité
de "if" imbriqués.

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    if(e) {
        i;
        if(e) {
            i;
            if(e) {
                i;
                ...
            }
        }
    }
}
\end{Verbatim}
\end{minipage}

Donc en remplaçant le second "if" par le "while", on obtient :

\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
while(e) {
    i
}
\end{Verbatim}
\end{minipage}
$\widehat{=}$\hspace{1cm}
\begin{minipage}{0.3\textwidth}
\begin{Verbatim}
if(e) {
    i;
    while(e) {
        i
    }
}
\end{Verbatim}
\end{minipage}

Si un "return" apparaît dans une séquence, on peut supprimer la suite :

\begin{mathpar}
  \irule{Return}
  { }
  { \mmi{m}{\iReturn{e};i}{m}{\iReturn{e}} }
\end{mathpar}

\section{Exécution}

On considère un programme $P = ((f_1, …, f_n), ((x_1, e_1), … (x_p, e_p)))$.

Son état mémoire initial est

\[
  m_{0}(P) = ([], (x_1, …, x_p), \{x_1 ↦ 0, …, x_p ↦ 0\}))
\]

Et son exécution est celle de l'instruction

\[
  i_0(P) = x_1 ← e_1;…;x_p ← e_p;f_1()
\]

L'état initial est $(m_0(P), i_0(P))$.

\section{Exemple : l'algorithme d'Euclide}

Version par divisions successives:

\begin{Verbatim}
function gcd(a, b)
  var t = 0;
  while b != 0
    t = b
    b = a mod b
    a = t
  return a
\end{Verbatim}

Soit :

\def\exinnerif{t←b;b←a\%b;a←t}

\begin{mathpar}
  f(a, b) (t = 0) \{
    \iWhile{b ≠ 0}{
      \exinnerif
    };
    \iReturn{a}
  \}
\end{mathpar}

\[
  \msi{m}{f(1071, 462)} → ?
\]

\[
  \msi{m[a↦1071][b↦462][t↦0]}{\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} → ?
\]

(on notera cet état $s_0 = \msi{m_0}{i_0}$)

\[
  \mm{m_0}{a = 0}{m_0}{0}
\]

donc

\[
  \mm{m_0}{\iThen{a = 0}{\iReturn{b}}}{m[a↦1071][b↦462]}{\iPass}
\]

{ \scriptsize
\begin{align}
  s_0 → & \msi{m_0  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_0  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0  }{ b←a\%b;a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_0''}{ a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_1  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_1  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_2  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_2  }{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}} \\
      → & \msi{m_3  }{ \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}} \\
      → & \msi{m_3  }{ \iPass; \iReturn{a}} \\
      → & \msi{m_3  }{ \iReturn{a}}
\end{align}

\begin{align*}
  m_0'  = & m_0  [t↦462] = m[a↦1071][b↦462][t↦462] \\
  m_0'' = & m_0' [b↦147] = m[a↦1071][b↦147][t↦462] \\
  m_1   = & m_0''[a↦462] = m[a↦462][b↦147][t↦462] \\
  m_2   = & m_1[t↦147][b↦21][a↦147] = m[a↦147][b↦21][t↦147] \\
  m_3   = & m_2[t↦21][b↦0][a↦21] = m[a↦21][b↦0][t↦21]
\end{align*}
}

\begin{center}\rule{3in}{0.4pt}\end{center}

\section*{TODO}

\begin{itemize}
\item mettre ensemble les noms de variables et leurs valeurs
\item top ?
\item sémantique des erreurs?
\item
  si on prend l'adresse d'une locale, et qu'on la redéférence, comment s'assurer
  qu'il n'y a pas de dangling pointer? (ça peut être important pour la soundness
  de l'analyse)

  Options :

\begin{itemize}
\item
  on fait juste une restriction (forget) au pop (solution actuelle).
\item
  on donne à chaque stackframe un numéro fresh. Cela revient à considérer la
  stack comme un heap.
\end{itemize}

\end{itemize}

% vim: spelllang=fr
