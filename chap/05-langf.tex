On définit ici un langage impératif.

\section{Syntaxe}

Donnée dans la figure~\ref{fig:stx}.

\begin{figure}

  \gramlr{Constantes}{
    \begin{align*}
      c \gramisa & i & \textrm{Entier}
      \\ \gramor & f & \textrm{Flottant}
    \end{align*}
  }

  \gramlr{Expressions}{
    \begin{align*}
      e \gramisa & c               & \textrm{Constante}
      \\ \gramor & lv              & \textrm{Accès mémoire}
      \\ \gramor & \opsymb~e       & \textrm{Opération unaire}
      \\ \gramor & e~\opsymb~e     & \textrm{Opération binaire}
      \\ \gramor & \& x            & \textrm{Pointeur}
      \\ \gramor & * e             & \textrm{Déréférencement}
      \\ \gramor & f (e_1, …, e_n) & \textrm{Appel de fonction}
    \end{align*}
  }

  \gramlr{Opérateurs}{
    \begin{align*}
      \opsymb \gramisa & +,-,\times,/      & \textrm{Arithmétique entière}
      \\      \gramor  & +.,-.,\times.,/.  & \textrm{Arithmétique flottante}
      \\      \gramor  & =,≠,≤,≥,<,>       & \textrm{Comparaisons}
      \\      \gramor  & \&,|,\opxor,\sim  & \textrm{Opérateurs bit à bit}
      \\      \gramor  & \&\&,||,!         & \textrm{Opérateurs logiques}
      \\      \gramor  & ⋘, ⋙              & \textrm{Décalages}
    \end{align*}
  }

  \gramlr{Left-values}{
    \begin{align*}
      lv \gramisa & x   & \textrm{Variable}
      \\  \gramor & *lv & \textrm{Déréférencement}
    \end{align*}
  }

  \gramlr{Instructions}{
    \begin{align*}
      i \gramisa & \iPass        & \textrm{Instruction vide}
      \\ \gramor & i;i           & \textrm{Séquence}
      \\ \gramor & lv ← e         & \textrm{Affectation}
      \\ \gramor & \iIf{e}{i}{i} & \textrm{Alternative}
      \\ \gramor & \iWhile{e}{i} & \textrm{Boucle}
      \\ \gramor & \iReturn{e}   & \textrm{Retour de fonction}
    \end{align*}
  }

  \gramlr{Fonctions}{
    \begin{align*}
      f \gramisa & (i, (x_1, …, x_n)) & \textrm{Corps et arguments}
    \end{align*}
  }

  \caption{Syntaxe}
  \label{fig:stx}
\end{figure}

\section{Sémantique}

On définit dans la suite une sémantique pour le langage défini dans la
figure~\ref{fig:stx}.

\section{État mémoire}

Un programme, pour s'exécuter, dispose de mémoire organisée en variables. Plus
précisément, lors de l'exécution de chaque fonction, un cadre de pile est créé,
contenant un ensemble de variables accessibles par cette fonction. Il y en outre
un ensemble de variables globales accessibles depuis n'importe quel point du
programme.

En plus de ces ensembles de variables, chaque état mémoire comprend une liste
d'associations $(a, v)$ qui à une adresse associe une valeur.

\begin{figure}

  \gramlr{Valeurs}{
    \begin{align*}
      v \gramisa & c & \textrm{Constante}
      \\ \gramor & a & \textrm{Adresse}
    \end{align*}
  }

  \gramlr{Adresses}{
    \begin{align*}
      a \gramisa & (n, x) & \textrm{Variable locale}
      \\ \gramor & x      & \textrm{Variable globale}
    \end{align*}
  }

  \gramlr{Pile}{
    \begin{align*}
      s \gramisa & []                                   & \textrm{Pile vide}
      \\ \gramor & \{ x_1 ; … ; x_n \} :: s & \textrm{Ajout d'un cadre}
    \end{align*}
  }

  \gramlr{État mémoire}{
    \begin{align*}
      m \gramisa & (s,    \{ x_1 ; … ; x_n \}, \{a_1 ↦ v_1; … ; a_p ↦ v_p\})
          & \textrm{Pile, globales,             valeurs}
    \end{align*}
  }

  \caption{Interpréteur}
  \label{fig:interp}
\end{figure}

Chaque fonction peut donc accéder aux variables du dernier cadre de pile, ainsi
qu'aux variables globales :

\begin{definition}[Visibilité]
  On dit qu'une variable $x$ est visible dans la pile $s$ (ou dans un état
  mémoire $m$ qui a une telle pile) si $x$ fait partie des variables globales de
  $s$ ou (si elle existe) dans la tête de pile de $s$.
\end{definition}

\begin{definition}[Recherche de variable]

  \[
    \mathrm{VarLookup} (x, (s, g, l)) =
      \begin{cases}
        x      & \mbox{si } x ∈ g \\
      (0, x)   & \mbox{si } x ∉ g \mbox{ et } s = f::[]
                 \mbox{ avec } x ∈ f \\
      (n+1, x) & \mbox{si } x ∉ g \mbox{ et } s = f::s'
                 \mbox{ avec } \mathrm{VarLookup} (x, (s, g, e)) = (n, x)
      \end{cases}
  \]

\end{definition}

\begin{definition}[Manipulations des états mémoire]

  On note $(a, v) ∈ m$ si $(a, v)$ fait partie de la liste d'associations de
  mémoire de $m$ (c'est à dire si $(a, v) ∈ l$ avec $m = (s, g, l)$).

  Par extension, on note aussi $(x, v) ∈ m$ si $(a, v) ∈ m$ avec $a =
  \mathrm{VarLookup}(x, m)$.

  On note $m[a ↦ v]$ l'état mémoire obtenu en remplaçant dans la liste
  d'associations de mémoire de $m$, la valeur associée à $a$ par $v$.

  On étend de même cette notation pour $m[x ↦ v]$ pour $m[a ↦ v]$ avec
  $a = \mathrm{VarLookup}(x, m)$.

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. De même, en
retournant il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  La hauteur d'une pile est le nombre de cadres qu'elle contient :

  \begin{align*}
    \mathrm{StackHeight}([])     = & 0 \\
    \mathrm{StackHeight}(f~::~s) = & 1 + \mathrm{StackHeight}(s)
  \end{align*}

  On définit l'empilement d'un cadre de pile :

  \[
    \mathrm{Push}(s, (x_1, …, x_n)) = \{ x_1 ; … ; x_n \}~::~s
  \]

  On peut étendre cette notation aux états mémoires, en associant des valeurs à
  ces nouvelles variables :

  \[
    \mathrm{Push}((s, g, l), (x_1, v_1), …, (x_n, v_n)) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Push}(s, (x_1, …, x_n)) \\
    l' = & l \cup \{(p, x_1) ↦ v_1; … ; (p, x_n) ↦ v_n\} \\
    p  = & \mathrm{StackHeight}(s) + 1
  \end{align*}

  De même on définit le dépilement :

  \[
    \mathrm{Pop}(f~::~s) = s
  \]

  ainsi que son extension aux états mémoire :

  \[
    \mathrm{Pop}((s, g, l)) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Pop}(s) \\
    l' = & \{ (x) ∈ l \} \cup \{ (p, x) ∈ l / p < \mathrm{StackHeight}(s) \}
  \end{align*}

\end{definition}

\begin{definition}[Adresse effective]

  Pour permettre les accès indirects (par pointeur), ce ne sont pas directement
  les variables qui sont accédées en lecture ou écriture, mais des left-values.

  Dans un état mémoire donné $m$, on peut associer une adresse $a$ qui est celle
  à considérer. Cette adresse effective notée $\mathrm{EffAddr}(m, lv)$ est
  calculée de la manière suivante :

  \begin{align*}
    \mathrm{EffAddr}(m, x)   = & \mathrm{VarLookup}(m, x) \\
    \mathrm{EffAddr}(m, *lv) = & v \textrm{ si } (a, v) ∈ m
                                 \textrm{ et } a = \mathrm{EffAddr}(m, lv)
  \end{align*}
\end{definition}

\section{Expressions}

\begin{definition}[Évaluation d'une expression]

  L'évaluation d'une expression $e$ se fait sous un état mémoire particulier $m$
  et est susceptible de modifier celui-ci en le transformant en un nouveau $m'$.
  Le résultat est toujours une valeur $v$, c'est à dire que nous présentons pour
  les expressions une sémantique à grands pas. Cette évaluation est notée :

  \[
    (m, e) → (m', v)
  \]

\end{definition}

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \irule{Exp-Cst}
    { }
    {(m, c) → (m, \widehat{c})}
\end{mathpar}

Pour lire le contenu d'une variable, il faut tout d'abord s'assurer que celle-ci
est visible. Sa valeur est alors celle qui y est associée dans l'environnement
mémoire. Celui-ci n'est pas modifié.

\begin{mathpar}
  \irule{Exp-Lv}
  {x \mbox{ visible dans } m \\
    a = \mathrm{EffAddr}(m, lv) \\
    (a, v) ∈ m
  }
  {(m, x) → (m, v)}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, de gauche à droite, est imposé). À chaque
opérateur $\opsymb$, correspond un opérateur sémantique $\widehat{\opsymb}$ qui
agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers.


\begin{mathpar}
  \irule{Exp-UnOp}
  {(m, e) → (m', v)}
  {(m, \opsymb~e) → (m', \widehat{\opsymb}~v)}

  \irule{Exp-BinOp}
  {(m, e_1) → (m', v_1) \\
   (m', e_2) → (m'', v_2)
  }
  {(m, e_1~\opsymb~e_2) → (m'', v_1~\widehat{\opsymb}~v_2)}
\end{mathpar}

Adresse :

\begin{mathpar}
  \irule{Exp-AddrOf}
    { x \mbox{ visible dans } m \\
    a = \mathrm{VarLookup} (x, m)
    }
    {(m, \&x) → (m, a)}
\end{mathpar}

L'évaluation d'un appel de fonction commence de manière semblable au cas d'un
opérateur : on évalue de gauche à droite les arguments. Ceux-ci sont ensuite
placés dans un nouveau cadre de pile. Le corps de la fonction est évalué dans
cet environnement, et le cadre dépilé.

\begin{mathpar}
  \irule{Exp-Call}
  {(m  , e_1) → (m_1, v_1) \\
   (m_1, e_2) → (m_2, v_2) \\
   … \\
   (m_{n-1}, e_n) → (m_n, v_n) \\
   f = (i, (x_1, …, x_n)) \\
   m' = \mathrm{Push}(m_n, (x_1, v_1), …, (x_n, v_n)) \\
   (m', i) → (m'', \iReturn{v})
  }
  {(m, f(e_1, …, e_n)) → ( \mathrm{Pop}(m''), v)}
\end{mathpar}

\section{Instructions}

Contrairement à l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante :
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ "plus simple" en partant d'un état mémoire
$m'$. Un tel pas est noté :

\[
  (m, i) → (m', i')
\]

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$ :

\begin{align*}
  (m, (x ← 3 ; y ← x)) → & (m [x ↦ \widehat{3}], y ← x) \\
                       → & (m [x ↦ \widehat{3}][y ↦ \widehat{3}], \iPass)
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \irule{Seq}
    {
      (m, i) → (m', \iPass)
    }
    {
      (m, (i;i')) → (m', i')
    }


  \irule{Set}
  {
    (m, lv) → (m', v) \\
    a = \mathrm{EffAddr}(m, lv)
  }
  {(m, lv ← e) → (m' [ a ↦ v ], \iPass)}

\end{mathpar}

Alternative

\begin{mathpar}
  \irule{If-False}
    {
      (m, e) → (m', \widehat{0}) \\
      (m', i_f) → (m'', i')
    }
    {
      (m, \iIf{e}{i_t}{i_f}) → (m'', i')
    }

  \irule{If-True}
    {
      (m, e) → (m', v) \\
      v ≠ \widehat{0} \\
      (m', i_t) → (m'', i')
    }
    {
      (m, \iIf{e}{i_t}{i_f}) → (m'', i')
    }
\end{mathpar}

Boucle

\begin{mathpar}
  \irule{While}
    { }
    {
      (m, \iWhile{e}{i}) → (m, \iIf{e}{i;\iWhile{e}{i}}{\iPass})
    }

\end{mathpar}

TODO

\begin{itemize}
\item
  declarations
\item
  champs de records
\item
  faut-il une règle $(m, \iPass;i) → (m, i)$ ?
\item
  faut-il une règle $(m, \iReturn{e};i) → (m, \iReturn{e})$ ?
\item
  interdire la division par zéro
\end{itemize}
