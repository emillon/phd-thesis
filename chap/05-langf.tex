On définit ici un langage impératif.

\section{Syntaxe}

Donnée dans la figure~\ref{fig:stx}.

\begin{figure}

  \gramlr{Constantes}{
    \begin{align*}
      c \gramisa & i & \textrm{Entier}
      \\ \gramor & f & \textrm{Flottant}
    \end{align*}
  }

  \gramlr{Expressions}{
    \begin{align*}
      e \gramisa & c               & \textrm{Constante}
      \\ \gramor & lv              & \textrm{Accès mémoire}
      \\ \gramor & \opsymb~e       & \textrm{Opération unaire}
      \\ \gramor & e~\opsymb~e     & \textrm{Opération binaire}
      \\ \gramor & \& x            & \textrm{Pointeur}
      \\ \gramor & f (e_1, …, e_n) & \textrm{Appel de fonction}
    \end{align*}
  }

  \gramlr{Opérateurs}{
    \begin{align*}
      \opsymb \gramisa & +,-,\times,/      & \textrm{Arithmétique entière}
      \\      \gramor  & +.,-.,\times.,/.  & \textrm{Arithmétique flottante}
      \\      \gramor  & =,≠,≤,≥,<,>       & \textrm{Comparaisons}
      \\      \gramor  & \&,|,\opxor,\sim  & \textrm{Opérateurs bit à bit}
      \\      \gramor  & \&\&,||,!         & \textrm{Opérateurs logiques}
      \\      \gramor  & \ll, \gg          & \textrm{Décalages}
    \end{align*}
  }

  \gramlr{Left-values}{
    \begin{align*}
      lv \gramisa & x   & \textrm{Variable}
      \\  \gramor & *lv & \textrm{Déréférencement}
    \end{align*}
  }

  \gramlr{Instructions}{
    \begin{align*}
      i \gramisa & \iPass        & \textrm{Instruction vide}
      \\ \gramor & i;i           & \textrm{Séquence}
      \\ \gramor & lv ← e         & \textrm{Affectation}
      \\ \gramor & \iIf{e}{i}{i} & \textrm{Alternative}
      \\ \gramor & \iWhile{e}{i} & \textrm{Boucle}
      \\ \gramor & \iReturn{e}   & \textrm{Retour de fonction}
    \end{align*}
  }

  \gramlr{Fonctions}{
    \begin{align*}
      f \gramisa & (i,                             & \textrm{Corps} \\
                 & (x_1, …, x_n),                  & \textrm{Arguments} \\
                 & ((x'_1, e_1), …, (x'_p, e_p)))  & \textrm{Variables locales}
    \end{align*}
  }

  \gramlr{Programme}{
    \begin{align*}
      P \gramisa & ((f_1, …, f_n),   & \textrm{Fonctions} \\
                 & ((x_1, e_1), …, (x_p, e_p))) & \textrm{Globales}
    \end{align*}
  }

  \caption{Syntaxe}
  \label{fig:stx}
\end{figure}

\section{Définitions préliminaires}

On suppose avoir à notre disposition un ensemble infini dénombrable
d'identificateurs \sId (par exemple des chaînes de caractères).

$X^*$ est l'ensemble des suites finies de $X$, indexées à partir de 1. Si $u ∈
X^*$, on note $|u|$ le nombre d'éléments de $u$ (le cardinal de son ensemble de
définition). Pour $1 ≤ i ≤ |u|$, on note $u_i = u(i)$ le i-ème élément de la
suite.

On peut aussi voir les suites comme des listes : on note $[]$ la suite vide,
telle que $|[]| = 0$. On définit en outre la construction de suite de la manière
suivante : si $x ∈ X$ et $u ∈ X^*$, la liste $x::u ∈ X^*$ est la liste $v$ telle
que :

\begin{align*}
  v_1 = & x \\
  ∀ i ∈ [1; |u|] , v_{i+1} = & u_i
\end{align*}

\section{Mémoire}

L'interprète que nous nous apprêtons à définir manipule des valeurs qui sont
associées aux variables du programme.

\begin{align*}
  \sVal = & \sInt \cup \sFloat \cup \sAddr \\
  \sInt = & ℤ/2^{32} ℤ - 2^{31} \\
  \sAddr = & \sId \cup (ℕ × \sId)
\end{align*}

\sFloat correspond à l'ensemble des flottants IEEE 754\cite{ieee754}. Ici, \sInt
est choisi pour représenter les nombres entiers de $-2^{31}$ à $2^{31}-1$, mais
ce choix est arbitraire : de la même manière, on aurait pu choisir des nombres à
64 bits ou même de précision arbitraire.

L'ensemble des états mémoire est :

\[
  \sMem = {\sId^*}^* × \sId^* × \sVal^\sAddr
\]

L'interprétation est la suivante : une adresse est soit un nom de variable
globale, soit un nom de variable locale à un niveau donné.

Un état mémoire contient deux ensembles de variables (locales et globales), et
une fonction qui à chacune de ces variables associe une valeur.

Plus précisément, un état mémoire $m = (s, g, l)$ est composé de :

\begin{itemize}
\item
  une pile de variables locales $s$. Celles-ci sont organisées en
  niveaux indépendants : à chaque appel de fonction, un nouveau cadre de
  pile est créé, comprenant ses paramètres et ses variables locales.
\item
  un ensemble de variables globales $g$. Contrairement aux variables
  locales, il n'y a pas de système d'empilement, puisque toutes ces
  variables sont accessibles depuis tout point du programme.
\item
  une liste d'associations $l$ qui à chaque adresse mémoire associe une
  valeur.
\end{itemize}

Les variables qui apparaissent dans $s$ et $g$ sont uniquement des symboles
(leurs noms) : les valeurs sont dans $l$.

Les adresses intervenant dans $l$ sont soit un nom de variable globale, soit un
couple $(n, x)$ où $n$ est un entier qui correspond à la hauteur de pile de la
variable considérée. Cela permet de distinguer entre deux variables qui ont le
même nom, par exemple dans le cas d'un appel récursif.

Ces définitions sont résumées dans la figure~\ref{fig:interp}

\begin{figure}

  \gramlr{Valeurs}{
    \begin{align*}
      v \gramisa & c & \textrm{Constante}
      \\ \gramor & a & \textrm{Adresse}
    \end{align*}
  }

  \gramlr{Adresses}{
    \begin{align*}
      a \gramisa & (n, x) & \textrm{Variable locale}
      \\ \gramor & x      & \textrm{Variable globale}
    \end{align*}
  }

  \gramlr{Pile}{
    \begin{align*}
      s \gramisa & []                                   & \textrm{Pile vide}
      \\ \gramor & \{ x_1 ; … ; x_n \} :: s & \textrm{Ajout d'un cadre}
    \end{align*}
  }

  \gramlr{État mémoire}{
    \begin{align*}
      m \gramisa & (s,    \{ x_1 ; … ; x_n \}, \{a_1 ↦ v_1; … ; a_p ↦ v_p\})
          & \textrm{Pile, globales,             valeurs}
    \end{align*}
  }

  \caption{Interpréteur}
  \label{fig:interp}
\end{figure}

Chaque fonction peut accéder aux variables locales de la fonction en cours,
ainsi qu'aux variables globales.

\begin{definition}[Visibilité]
  On dit qu'une variable $x$ est visible dans la pile $s$ (ou dans un état
  mémoire $m$ qui a une telle pile) si $x$ fait partie des variables globales de
  $s$ ou de la tête de pile de $s$.
\end{definition}

\begin{definition}[Recherche de variable]

  La recherche de variable permet d'associer à une variable $x$ une adresse $a$.

  \[
    \mathrm{VarLookup} (x, (s, g, l)) =
      \begin{cases}
        x      & \mbox{si } x ∈ g \\
      (0, x)   & \mbox{si } x ∉ g \mbox{ et } s = f::[]
                 \mbox{ avec } x ∈ f \\
      (n+1, x) & \mbox{si } x ∉ g \mbox{ et } s = f::s'
                 \mbox{ avec } \mathrm{VarLookup} (x, (s, g, e)) = (n, x)
      \end{cases}
  \]

\end{definition}

\begin{definition}[Manipulations des états mémoire]

  On note $(a, v) ∈ m$ si $(a, v)$ fait partie de la liste d'associations de
  mémoire de $m$ (c'est à dire si $(a, v) ∈ l$ avec $m = (s, g, l)$).

  Par extension, on note aussi $(x, v) ∈ m$ si $(a, v) ∈ m$ avec $a =
  \mathrm{VarLookup}(x, m)$.

  On note $m[a ↦ v]$ l'état mémoire obtenu en remplaçant dans la liste
  d'associations de mémoire de $m$, la valeur associée à $a$ par $v$.

  On étend de même cette notation pour $m[x ↦ v]$ pour $m[a ↦ v]$ avec
  $a = \mathrm{VarLookup}(x, m)$.

\end{definition}

En entrant dans une fonction, on rajoutera un cadre de pile qui contient les
paramètres de la fonction ainsi que ses variables locales. De même, en
retournant il faudra supprimer ce cadre de pile.

\begin{definition}[Manipulations de pile]

  On définit l'empilement d'un cadre de pile :

  \[
    \mathrm{Push}(s, (x_1, …, x_n)) = \{ x_1 ; … ; x_n \}::s
  \]

  On peut étendre cette notation aux états mémoires, en associant des valeurs à
  ces nouvelles variables :

  \[
    \mathrm{Push}((s, g, l), ((x_1, v_1), …, (x_n, v_n))) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Push}(s, (x_1, …, x_n)) \\
    l' = & l \cup \{(p, x_1) ↦ v_1; … ; (p, x_n) ↦ v_n\} \\
    p  = & |s| + 1
  \end{align*}

  De même on définit le dépilement :

  \[
    \mathrm{Pop}(f::s) = s
  \]

  ainsi que son extension aux états mémoire :

  \[
    \mathrm{Pop}((s, g, l)) = (s', g, l')
  \]

  avec

  \begin{align*}
    s' = & \mathrm{Pop}(s) \\
    l' = & \{ (x) ∈ l \} \cup \{ (p, x) ∈ l \mbox{ où } p < |s| \}
  \end{align*}

\end{definition}

\begin{definition}[Adresse effective]

  Pour permettre les accès indirects (par pointeur), ce ne sont pas directement
  les variables qui sont accédées en lecture ou écriture, mais des left-values.

  Dans un état mémoire donné $m$, on peut associer une adresse $a$ qui est celle
  à considérer. Cette adresse effective notée $\mathrm{EffAddr}(m, lv)$ est
  calculée de la manière suivante :

  \begin{align*}
    \mathrm{EffAddr}(m, x)   = & \mathrm{VarLookup}(m, x) \\
    \mathrm{EffAddr}(m, *lv) = & v \textrm{ si } (a, v) ∈ m
                                 \textrm{ et } a = \mathrm{EffAddr}(m, lv)
  \end{align*}
\end{definition}

\section{Expressions}

\begin{definition}[Évaluation d'une expression]

  L'évaluation d'une expression $e$ se fait sous un état mémoire particulier $m$
  et est susceptible de modifier celui-ci en le transformant en un nouveau $m'$.
  Le résultat est toujours une valeur $v$, c'est à dire que nous présentons pour
  les expressions une sémantique à grands pas. Cette évaluation est notée :

  \[
    (m, e) → (m', v)
  \]

\end{definition}

Évaluer une constante est le cas le plus simple, puisqu'en quelque sorte
celle-ci est déjà évaluée. À chaque constante syntaxique $c$, on peut associer
une valeur sémantique $\widehat{c}$. Par exemple, au chiffre (symbole) $3$, on
associe le nombre (entier) $\widehat{3}$.

\begin{mathpar}
  \irule{Exp-Cst}
    { }
    {(m, c) → (m, \widehat{c})}
\end{mathpar}

Pour lire le contenu d'une variable, il faut tout d'abord s'assurer que celle-ci
est visible. Sa valeur est alors celle qui y est associée dans l'environnement
mémoire. Celui-ci n'est pas modifié.

\begin{mathpar}
  \irule{Exp-Lv}
  {x \mbox{ visible dans } m \\
    a = \mathrm{EffAddr}(m, lv) \\
    (a, v) ∈ m
  }
  {(m, x) → (m, v)}
\end{mathpar}

Pour évaluer une expression constituée d'un opérateur, on évalue une expression,
puis l'autre (l'ordre d'évaluation, de gauche à droite, est imposé). À chaque
opérateur $\opsymb$, correspond un opérateur sémantique $\widehat{\opsymb}$ qui
agit sur les valeurs. Par exemple, l'opérateur $\widehat{+}$ est l'addition
classique entre entiers. Afin d'interdire la division par zéro, celle ci et le
modulo sont traités dans une règle à part.

\begin{mathpar}
  \irule{Exp-UnOp}
  {(m, e) → (m', v)}
  {(m, \opsymb~e) → (m', \widehat{\opsymb}~v)}

  \irule{Exp-BinOp}
  { \opsymb ∉ \{/, \%\} \\
    (m, e_1) → (m', v_1) \\
    (m', e_2) → (m'', v_2)
  }
  {(m, e_1~\opsymb~e_2) → (m'', v_1~\widehat{\opsymb}~v_2)}

  \irule{Exp-Div}
  { \opsymb ∈ \{/, \%\} \\
    (m, e_1) → (m', v_1) \\
    (m', e_2) → (m'', v_2) \\
    v_2 ≠ \widehat{0}
  }
  {(m, e_1~\opsymb~e_2) → (m'', v_1~\widehat{\opsymb}~v_2)}
\end{mathpar}

Adresse :

\begin{mathpar}
  \irule{Exp-AddrOf}
    { x \mbox{ visible dans } m \\
    a = \mathrm{VarLookup} (x, m)
    }
    {(m, \&x) → (m, a)}
\end{mathpar}

L'évaluation d'un appel de fonction commence de manière semblable au cas d'un
opérateur : on évalue de gauche à droite les arguments. Ceux-ci sont ensuite
placés dans un nouveau cadre de pile. Le corps de la fonction est évalué dans
cet environnement, et le cadre dépilé.

On commence par définir une opération d'évaluation de plusieurs expressions à la
fois. Notons que l'évaluation se fait dans un ordre précis, de gauche à droite.

\begin{mathpar}
  \irule{Eval*-Nil}
    { }
    {\mathrm{Eval}^*(m, [], m)}

  \irule{Eval*-Cons}
    { (m, e) → (m', v) \\
      \mathrm{Eval}^*(m', l, m'')
    }
    {\mathrm{Eval}^*(m, (e, v)::l, m'')}
\end{mathpar}

\begin{mathpar}
  \irule{Exp-Call}
  {
    f = (i, (x_1, …, x_n), ((x'_1, e'_1), …, (x'_p, e'_p))) \\
    \mathrm{Eval}^*(m ,  ((e_1, v_1),…,(e_n, v_n)), m') \\
    \mathrm{Eval}^*(m' , ((e'_1, v'_1),…,(e'_p, v'_p)), m'') \\
   m''' = \mathrm{Push}(m'', ((x_1, v_1), …, (x_n, v_n),
      (x'_1, v'_1), … (x'_p, v'_p)
   )) \\
   (m''', i) → (m'''', \iReturn{v})
  }
  {(m, f(e_1, …, e_n)) → ( \mathrm{Pop}(m''''), v)}
\end{mathpar}

\section{Instructions}

Contrairement à l'évaluation des expressions, on choisit une sémantique de
réécriture à petits pas. La sémantique fonctionne de la manière suivante :
partant d'un état mémoire $m$, on veut exécuter une instruction $i$. Les règles
d'évaluation suivantes permettent de réduire le problème en se ramenant à
l'exécution d'une instruction $i'$ "plus simple" en partant d'un état mémoire
$m'$. Un tel pas est noté :

\[
  (m, i) → (m', i')
\]

Par exemple, exécuter $x ← 3 ; y ← x$ revient à évaluer $y ← x$ depuis un état
mémoire dans lequel on a déjà réalisé la première affectation. La seconde
affectation se réalise de même et permet de réécrire l'instruction restante en
$\iPass$ :

\begin{align*}
  (m, (x ← 3 ; y ← x)) → & (m [x ↦ \widehat{3}], y ← x) \\
                       → & (m [x ↦ \widehat{3}][y ↦ \widehat{3}], \iPass)
\end{align*}

Il n'est pas possible de réduire plus loin l'instruction $\iPass$. Dans un tel
cas, l'évaluation est terminée.

Les seuls cas terminaux sont $\iPass$ et $\iReturn{e}$.

Les cas de la séquence et de l'affectation ont été utilisés dans l'exemple
ci-dessus.

\begin{mathpar}
  \irule{Seq}
    {
      (m, i) → (m', \iPass)
    }
    {
      (m, (i;i')) → (m', i')
    }

  \irule{Pass}
    {
    }
    {
      (m, (\iPass;i)) → (m, i)
    }

  \irule{Set}
  {
    (m, lv) → (m', v) \\
    a = \mathrm{EffAddr}(m, lv)
  }
  {(m, lv ← e) → (m' [ a ↦ v ], \iPass)}

\end{mathpar}

Alternative

\begin{mathpar}
  \irule{If-False}
    {
      (m, e) → (m', \widehat{0}) \\
      (m', i_f) → (m'', i')
    }
    {
      (m, \iIf{e}{i_t}{i_f}) → (m'', i')
    }

  \irule{If-True}
    {
      (m, e) → (m', v) \\
      v ≠ \widehat{0} \\
      (m', i_t) → (m'', i')
    }
    {
      (m, \iIf{e}{i_t}{i_f}) → (m'', i')
    }
\end{mathpar}

Boucle

(on définit $\iThen{e}{i} = \iIf{e}{i}{\iPass}$)

\begin{mathpar}
  \irule{While}
    { }
    {
      (m, \iWhile{e}{i}) → (m, \iThen{e}{i;\iWhile{e}{i}})
    }
\end{mathpar}


Early return

\begin{mathpar}
  \irule{Return}
  { }
  { (m, \iReturn{e};i) → (m, \iReturn{e}) }
\end{mathpar}

\section{Exécution}

On considère un programme $P = ((f_1, …, f_n), ((x_1, e_1), … (x_p, e_p)))$.

Son état mémoire initial est

\[
  m_{0}(P) = ([], (x_1, …, x_p), \{x_1 ↦ 0, …, x_p ↦ 0\}))
\]

Et son exécution est celle de l'instruction

\[
  i_0(P) = x_1 ← e_1;…;x_p ← e_p;f_1()
\]

L'état initial est $(m_0(P), i_0(P))$.

\section{Exemple : l'algorithme d'Euclide}

Version par divisions successives:

\begin{Verbatim}
function gcd(a, b)
  var t = 0;
  while b != 0
    t = b
    b = a mod b
    a = t
  return a
\end{Verbatim}

Soit :

\def\exinnerif{t←b;b←a\%b;a←t}

\begin{mathpar}
  f(a, b) (t = 0) \{
    \iWhile{b ≠ 0}{
      \exinnerif
    };
    \iReturn{a}
  \}
\end{mathpar}

\[
  (m, f(1071, 462)) → ?
\]

\[
  (m[a↦1071][b↦462][t↦0], \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) → ?
\]

(on notera cet état $s_0 = (m_0, e_0)$)

\[
  (m_0, a = 0) → (m_0, 0)
\]

donc

\[
  (m_0, \iThen{a = 0}{\iReturn{b}}) → (m[a↦1071][b↦462], \iPass)
\]

{ \scriptsize
\begin{align}
  s_0 → & (m_0, \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}) \\
      → & (m_0, \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_0', b←a\%b;a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_0'', a←t;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_1, \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_1, \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}) \\
      → & (m_1, \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_2, \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_2, \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}) \\
      → & (m_2, \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_3, \iWhile{b ≠ 0}{ \exinnerif }; \iReturn{a}) \\
      → & (m_3, \iThen{b ≠ 0}{ \exinnerif;\iWhile{b ≠ 0}{ \exinnerif }}; \iReturn{a}) \\
      → & (m_3, \iPass; \iReturn{a}) \\
      → & (m_3, \iReturn{a})
\end{align}

\begin{align*}
  m_0'  = & m_0  [t↦462] = m[a↦1071][b↦462][t↦462] \\
  m_0'' = & m_0' [b↦147] = m[a↦1071][b↦147][t↦462] \\
  m_1   = & m_0''[a↦462] = m[a↦462][b↦147][t↦462] \\
  m_2   = & m_1[t↦147][b↦21][a↦147] = m[a↦147][b↦21][t↦147] \\
  m_3   = & m_2[t↦21][b↦0][a↦21] = m[a↦21][b↦0][t↦21]
\end{align*}
}


\begin{center}\rule{3in}{0.4pt}\end{center}

TODO

\begin{itemize}
\item
  déplacer $lv ← e$ dans les expressions
\item
  champs de records
\end{itemize}

% vim: spelllang=fr
