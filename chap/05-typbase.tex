Dans ce chapitre nous présentons un langage impératif permettant de modéliser
C. Nous donnons sa syntaxe, une sémantique opérationelle ainsi qu'un
système de types permettant d'obtenir plus de garanties que le système de typse
original de C tel que décrit dans \cite{AnsiC}.

Il permet le polymorphisme sur les types pointeurs, permettant par exemple de
typer :

\begin{mathpar}
⊢ \text{memcpy} : ∀ a . (a^*, a^*, \text{size\_t}) \rightarrow \tVoid
\end{mathpar}

La traduction depuis C sera explicitée dans le chapitre~\ref{cha:implem}.

\section{Syntaxe}

La grammaire suivante définit un langage impératif. On suppose qu'on peut
compiler un programme écrit en C vers ce langage.

Un programme est un triplet $P = (\vec{f}, \vec{x}, b)$ constitué d'un ensemble
de fonctions, d'un ensemble de variables et d'un bloc d'instructions. Ce bloc
sera exécuté au lancement du programme ; il peut par exemple contenir le code
d'initialisation des variables globales et l'appel à la fonction principale.

\input{fig/syntax.tex}

\todo{expliquer pourquoi un while expr ne suffit pas}

La différence principale avec C est que les expressions sont sans effets de
bords, donc que leur évaluation peut être faite sans modifier l'environnement.

\section{Sémantique}

Dans cette section, nous définissons une sémantique pour ce langage impératif ;
elle pourra servir à l'implantation d'un interpréteur et à raisonner de manière
formelle sur les programme. Mathématiquement, cela consiste en la définition
d'une relation de transition $\rightarrow$ entre états de l'interpréteur.

Un état est constitué d'une part d'un point de contrôle dans le programme
(section~\ref{sec:cfg}, et d'autre part de l'état $σ$ de la mémoire
(section~\ref{sec:sigma}).

\subsection{Graphe de flot de contrôle}
\label{sec:cfg}

Dans la syntaxe ci-dessus, on peut classifier les instructions en deux familles:
celles qui définissent le flot de contrôle (\npkIf{$\cdot$}{$\cdot$}{$\cdot$},
\npkDoWith{$\cdot$}{$\cdot$}, \npkGoto{$\cdot$}, \npkWhile{$\cdot$}) et celles
qui définissent le flot de données. Une première transformation va transformer
chaque fonction en son graphe de flot de contrôle, défini comme suit :

\begin{itemize}
\item
  les nœuds sont des points de contrôle, qui représentent par exemple
  l'adresse mémoire de l'instruction qui vient d'être exécutée.
\item
  les arêtes sont soit des instructions "de données" (affectation,
  appel de fonction, déclaration), soit des conditions (ie une
  expression).
\end{itemize}

\begin{minipage}{0.5\textwidth}
\input{gen/euclide.c.pyg.tex}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\input{gen/euclide-npk.c.pyg.tex}
\end{minipage}

\input{fig/euclide.tex}

Intuitivement, on peut "passer" d'un état à un autre soit en passant par une
arête "condition" qui s'évalue à une valeur "vrai", soit en appliquant les
effets de bord d'une arête "instruction".

Dans la suite, on suppose qu'on a à notre disposition un ensemble de jugements :
$\langle l, instr, l' \rangle$ qui signifie qu'on peut passer du point $l$ au
point $l'$ en effectuant l'instruction $instr$.

\subsection{État mémoire}
\label{sec:sigma}

La mémoire interne de l'interpréteur est une correspondance entre l'ensemble des
adresses (infini dénombrable) et l'ensemble des valeurs. Un état mémoire $σ$ est
une fonction partielle de $Addr$ vers $Val$.

Ces valeurs peuvent être de plusieurs formes :

\gramlr{Valeurs}{
\begin{align*}
v  \gramisa  & n           & \textrm{Entier}
\\ \gramor   & f           & \textrm{Flottant}
\\ \gramor   & \cNil       & \textrm{Pointeur nul}
\\ \gramor   & \&a         & \textrm{Pointeur sur l'adresse $a$}
\\ \gramor   & \&f         & \textrm{Pointeur sur la fonction $f$}
\\ \gramor   & \top        & \textrm{Valeur non initialisée}
\end{align*}
}

\todo{Pile d'appels}

\subsection{Left values}

La mémoire est organisée en adresses, mais pourtant dans le programme cette
notion n'est pas directement visible. Les accès sont réalisés à travers des
"left values". Dans le langage C, elles correspondent aux constructions qui
peuvent se retrouver à gauche du signe "=" dans une affectation.

Une left value est donc soit une variable (locale ou globale), soit l'accès à un
indice d'une left value, soit l'accès à un champ d'une left value, soit le
déréférencement d'une left value.

\subsection{Jugements}

La sémantique concrète que nous définissons ici est constituée de jugements
logiques. Le jugement principal est une relation de transition $\rightarrow$
entre états de l'interpréteur : il sera donc noté $(l, σ) \rightarrow (l', σ')$.

Pour aider à définir ces pas, il est nécessaire d'évaluer les expressions en
fonction d'un certain état de la mémoire. On notera que dans l'état mémoire
$σ$, l'expression $e$ produit la valeur $v$ en écrivant $σ ⊢ e ⇒ v$.

Enfin, les expressions font intervenir des left-values. Puisque les états
mémoires sont définis en termes d'adresses, il faut faire la correspondance à
l'aide d'un jugement $σ ⊢ lv ⇒ a$.

\subsection{Sémantique des left-values}

\todo{Addr / Value}

Confusion : que mettre dans $σ$ : addr $\rightarrow$ value ou lv $\rightarrow$
addr ? Il faut les 2.

\begin{mathpar}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  σ ⊢ v ⇒ a
}
\and
\irule{Eval-Lv-Deref}{
  σ ⊢ e ⇒ \&a
}{
  σ ⊢ *e ⇒ a
}
\and
\irule{Eval-Lv-Field}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ lv.f ⇒ a + f
}
\and
\irule{Eval-Lv-Array}{
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ n \\
}{
  σ ⊢ lv[e] ⇒ a + n
}
\end{mathpar}

\subsection{Sémantique des expressions}

Les expressions peuvent être évaluées en valeurs. Dans le cas où l'expression
est une constante, c'est aussi le résultat.

\begin{mathpar}
\irule{Eval-Cst}{
}{
  σ ⊢ c ⇒ c
}
\end{mathpar}

Si l'expression est une left-value, on établit à quelle adresse elle correspond
et on récupère dans l'état mémoire à quelle valeur celle-ci correspond.

\begin{mathpar}
\irule{Eval-Lv}{
  σ ⊢ lv ⇒ a \\
  (a, v) ∈ σ
}{
  σ ⊢ lv ⇒ v
}
\end{mathpar}

En ce qui concerne les opérations (unaires ou binaires), on commence par évaluer
les opérandes. Le résultat est l'opération "concrète" sur les valeurs, notée
$\widehat{\textrm{op}}$. Par exemple, pour la construction syntaxique $+$, on
utilise l'addition sur les valeurs $\widehat{+}$ (c'est-à-dire l'addition
usuelle).

\begin{mathpar}
\irule{Eval-Unop}{
  σ ⊢ e ⇒ v
}{
  σ ⊢ \textrm{op}~e ⇒ \widehat{\textrm{op}}~v
}
\and
\irule{Eval-Binop}{
  σ ⊢ e_1 ⇒ v_1 \\
  σ ⊢ e_2 ⇒ v_2
}{
  σ ⊢ e_1~\textrm{op}~e_2 ⇒ v_1 \widehat{\textrm{op}}~v_2
}
\end{mathpar}

Enfin, les adresses sont aussi des valeurs. Le cas des pointeurs sur fonction
est direct puisque toutes les fonctions sont globales ; pour le cas des
pointeurs sur données on commence par déterminer l'adresse de l'objet pointé
depuis l'état mémoire.

\begin{mathpar}
\irule{Eval-AddrOfFun}{
}{
  σ ⊢ \&f ⇒ \&f
}
\and
\irule{Eval-AddrOf}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ \&lv ⇒ \&a
}
\end{mathpar}

\subsection{Sémantique des instructions}

La règle la plus simple concerne l'affectation : on peut affecter une
expressions à une left value si elles ont le même type.

\begin{mathpar}
  \irule{Instr-Assign}{
    \langle l, lv \leftarrow e, l' \rangle \\
    σ ⊢ lv ⇒ a \\
    σ ⊢ e ⇒ v
  }{
    (l, σ) \rightarrow (l', σ [ a ↦ v ])
  }
\end{mathpar}

Déclarer une variable, c'est rendre accessible dans un bloc une variable non
initialisée, qui n'est plus accessible par la suite : Si on suppose qu'on peut
traverser le bloc interne $b$ sous un $σ$ enrichi d'une nouvelle variable $x$,
on peut donc traverser l'instruction \npkDecl{x}{b}.

\begin{minipage}{0.6\textwidth}
\begin{mathpar}
  \irule{Instr-Decl}{
    \langle l, \npkDecl{x}{b}, l' \rangle \\
    \langle l_b, b, l_b' \rangle \\
    σ' = σ ⊕ \{ x \rightarrow \top \} \\
    (l_b, σ', s) \rightarrow (l_b', σ'')
  }{
    (l, σ) \rightarrow (l', σ'' \backslash x)
  }
\end{mathpar}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\input{fig/sem-decl.tex}
\end{minipage}

\todo{fcall}

TODO pour :

\[
\irule{Instr-Fcall}{
  \langle l, lv \leftarrow fe(\vec{e}), l' \rangle \\
  σ ⊢ fe ⇒ f \\
  σ ⊢ \vec{e} ⇒ \vec{v} \\
  σ' = σ ⊕ \{args(f) = \vec{v}\} ⊕ \{ !ret \rightarrow \top \} \\
  (Entry(f), σ') \rightarrow (Exit(f), σ'') \\
  σ'' ⊢ !ret ⇒ v_{ret} \\
  σ'' ⊢ lv ⇒ a
}{
  (l, σ) \rightarrow (l', σ'' \backslash (args(f) \cup \{!ret\}) ⊕ \{ a \rightarrow v_{ret}\}, ?)
}
\]

\todo{definir $σ ⊢ fe ⇒ f$}

\subsection{Sémantique des conditions}

On utilise un encodage similaire à la déclaration. Tout d'abord, on évalue la
condition dans un contexte $σ$. Si elle s'évalue en un entier non nul, et qu'une
transition à travers le bloc $i_t$ est possible, alors on peut faire passer à
travers le "\textsc{If}".

\begin{minipage}{0.5\textwidth}
\input{fig/sem-if.tex}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{mathpar}
\irule{If-True}{
  \langle l, \npkIf{e}{i_t}{i_f}, l' \rangle \\
  σ ⊢ e ⇒ n \\
  n ≠ 0 \\
  \langle l_i, i_t, l_i' \rangle \\
  (l_i, σ) \rightarrow (l_i', σ')
}{
  (l, σ) \rightarrow (l', σ')
}
\and
\irule{If-False}{
  \langle l, \npkIf{e}{i_t}{i_f}, l' \rangle \\
  σ ⊢ e ⇒ 0 \\
  \langle l_i, i_f, l_i' \rangle \\
  (l_i, σ) \rightarrow (l_i', σ')
}{
  (l, σ) \rightarrow (l', σ')
}
\end{mathpar}
\end{minipage}

\section{Règles de typage}

Dans cette section, on définit la notion de programme bien typé. L'analyse par
typage permet de vérifier qu'à chaque expression on peut associer un type, et ce
de manière cohérente entre plusieurs utilisations d'une variable.

Un jugement de typage est de la forme $Γ ⊢ e : τ$ et se lit "sous $Γ$, $e$ est
typable en $τ$". Un environnement de typage $Γ$ contient le contexte nécessaire
à l'analyse, c'est à dire le type des fonctions et variables du programme.

Les instructions et blocs, au contraire, n'ont pas de type. On note $Γ ⊢ i$ pour
"sous $Γ$, $i$ est bien typé", c'est à dire que ces sous expressions sont
typables et que les types sont en accord avec le flot de données (par exemple,
pour que l'instruction $lv \leftarrow e$ soit bien typée sous $Γ$, il faut que les types
de $lv$ et de $e$ puissent avoir le même type sous $Γ$).

Les types des valeurs sont :

\gramlr{Types}{
\begin{align*}
τ  \gramisa & \tInt, \tFloat, \tVoid        & \textrm{Constante}
\\ \gramor  &  a                            & \textrm{Variable}
\\ \gramor  & (τ_1, …, τ_n) \rightarrow τ_r & \textrm{Fonction}
\\ \gramor  & [τ]                           & \textrm{Tableau}
\\ \gramor  & τ*                            & \textrm{Pointeur}
\\ \gramor  & \{ f_1:τ_1
              ,    …
              , f_n:τ_n \}                  & \textrm{Structure}
\end{align*}
}

Et les environnements de typage :

\gramlr{Environnements}{
\begin{align*}
Γ  \gramisa & ε     & \textrm{Environnement vide}
\\ \gramor  & Γ,v:τ & \textrm{Ajout d'une variable}
\end{align*}
}

On va associer à chaque variable globale un type. Mais faire de même pourrait
être trop restrictif. En effet, une fonction comme memcpy peut être utilisée
pour copier des tableaux d'entiers, mais aussi de flottants. On va donc associer
un schéma de types à chaque fonction.

\gramlr{Schémas}{
\begin{align*}
σ \gramisa & ∀ \vec{a} . τ
\end{align*}
}

En associant un schéma de type $σ$ à une fonction $f$, on indique que la
fonction pourra être utilisée avec tout type $τ$ qui est une instanciation de
$σ$.

\todo{Gen, inst}

\subsection{Programme}

Au niveau global, un programme P est bien typé (noté $⊢ P$) s'il existe un
environnement $Γ = (\vec{σ}, \vec{τ})$ permettant de typer ses composantes (les fonctions, les
globales et le bloc d'initialisation).

\[
\irule{Prog}{
  (\vec{σ}, \vec{τ}) ⊢ \vec{f} : \vec{σ} \\
  (\vec{σ}, \vec{τ}) ⊢ \vec{x} : \vec{t} \\
  (\vec{σ}, \vec{τ}) ⊢ b
}{
  ⊢ (\vec{f}, \vec{x}, b)
}
\]

\subsection{Flot de contrôle}

Les règles suivantes permettent de définir les jugements $Γ ⊢ i$. De manière
générale, les instructions sont bien typées si leurs sous-instructions sont bien typées.

\begin{mathpar}
\irule{Pass}{
}{
  Γ ⊢ ε
}
\and
\irule{Seq}{
  Γ ⊢ s \\
  Γ ⊢ b
}{
  Γ ⊢ s;b
}
\and
\irule{While}{
  Γ ⊢ b
}{
  Γ ⊢ \npkWhile{b}
}
\and
\irule{Goto}{
}{
  Γ ⊢ \npkGoto{l}
}
\and
\irule{DoWith}{
  Γ ⊢ b
}{
  Γ ⊢ \npkDoWith{b}{l}
}
\end{mathpar}

Dans le cas de la conditionnelle, il est en plus nécessaire de vérifier que la
condition est un entier.

\begin{mathpar}
\irule{If}{
  Γ ⊢ e : \tInt \\
  Γ ⊢ i_t \\
  Γ ⊢ i_f
}{
  Γ ⊢ \npkIf{e}{i_t}{i_f}
}
\end{mathpar}

\subsection{Left values}

On associe à chaque left-value un type, qui est aussi le type des valeurs que
celle-ci peut contenir. Le cas des variables est direct : si un couple
(variable, type) est dans l'environnement de typage, la variable possède ce
type.

\begin{mathpar}
\irule{Lv-Var}{
  (v, τ) ∈ Γ
}{
  Γ ⊢ v : τ
}
\end{mathpar}

Si une expression a un type pointeur, en la déréférençant on obtient une valeur
du type pointé.

\begin{mathpar}
\irule{Lv-Deref}{
  Γ ⊢ e : τ*
}{
  Γ ⊢ *e : τ
}
\end{mathpar}

\todo{accès à un élément d'un type composite}

\begin{mathpar}
\irule{Lv-Field}{
  Γ ⊢ lv : τ_s \\
  (f, τ_f) ∈ τ_s
}{
  Γ ⊢ lv.f : τ_f
}
\and
\irule{Lv-Array}{
  Γ ⊢ lv : [τ] \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ lv[e] : τ
}
\end{mathpar}

\subsection{Expressions}

Les constantes ont leurs types habituels. Notons que le pointeur nul (\cNil) a
un type polymorphe.

\begin{mathpar}
\irule{Const-Int}{
}{
  Γ ⊢ n : \tInt
}
\and
\irule{Const-Float}{
}{
  Γ ⊢ f : \tFloat
}
\and
\irule{Const-Nil}{
}{
  Γ ⊢ \cNil : τ*
}
\end{mathpar}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
\irule{Op-Int}{
  \textrm{op} ∈ \{+,-,\times,/,\&,|,\&\&,||,⋘,⋙\} \\
  Γ ⊢ e_1 : \tInt \\
  Γ ⊢ e_2 : \tInt
}{
  Γ ⊢ e_1 \textrm{op} e_2 : \tInt
}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
\irule{Op-Float}{
  \textrm{op} ∈ \{+.,-.,\times.,/.\} \\
  Γ ⊢ e_1 : \tFloat \\
  Γ ⊢ e_2 : \tFloat
}{
  Γ ⊢ e_1 \textrm{op}~ e_2 : \tFloat
}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes de types
\tInt ou \tFloat et renvoient un \tInt.

\begin{mathpar}
\irule{Op-Cmp}{
  \textrm{op} ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : τ \\
  Γ ⊢ e_2 : τ \\
  τ ∈ \{ \tInt, \tFloat \}
}{
  Γ ⊢ e_1 \textrm{op} e_2 : \tInt
}
\end{mathpar}

L'opérateur unaire $-$ peut être appliqué à un \tInt ou à un \tFloat.

\begin{mathpar}
\irule{Unop-Minus}{
  τ ∈ \{ \tInt, \tFloat \} \\
  Γ ⊢ e : τ
}{
  Γ ⊢ -e : τ
}
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
\irule{Unop-Not}{
  \textrm{op} ∈ \{ \textasciitilde, ! \} \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ \textrm{op}~e : \tInt
}
\end{mathpar}

On peut prendre l'adresse d'une left-value, et obtenir un pointeur vers
celle-ci. Le type du résultat est un type pointeur vers le type de base.

\begin{mathpar}
\irule{AddrOf}{
  Γ ⊢ lv : τ
}{
  Γ ⊢ \&lv : τ*
}
\end{mathpar}

La règle concernant les pointeurs sur fonction est similaire, à ceci près que
les fonctions ont des schémas de type. Un pointeur sur fonction peut donc avoir
n'importe quelle instanciation de ce schéma.

\begin{mathpar}
\irule{AddrOfFun}{
  Γ ⊢ f : σ \\
  τ ≤ σ
}{
  Γ ⊢ \&lv : τ
}
\end{mathpar}

\subsection{Fonctions}

Pour typer une fonction, on commence par ajouter ses paramètres dans
l'environnement de typage, et on type la définition de la fonction. Le type
résultant est généralisé.

\[
\irule{Fun}{
  Γ' = Γ ⊕ \{ args(f) = \vec{τ} \} \\
  Γ' ⊢ body(f) \\
  Γ' ⊢ !ret : τ_r
}{
  Γ ⊢ f : Gen(\vec{τ} \rightarrow τ_r, Γ)
}
\]

\subsection{Instructions}

\begin{mathpar}
\irule{Decl}{
  Γ ⊕ \{x : τ\} ⊢ b
}{
  Γ ⊢ \npkDecl{x}{b}
}
\and
\irule{Assign}{
  Γ ⊢ lv : τ \\
  Γ ⊢ e  : τ
}{
  Γ ⊢ lv \leftarrow e
}
\and
\irule{Fcall}{
  Γ ⊢ lv : τ_{ret} \\
  Γ ⊢ fe : σ \\
  Γ ⊢ \vec{e} : \vec{τ} \\
  (\vec{τ} \rightarrow τ_r) ≤ σ
}{
  Γ ⊢ lv \leftarrow fe(\vec{e})
}
\end{mathpar}

\section{Limitations}
\subsection{Programmes non typables}
\subsection{Incohérences}
