Ici nous enrichissons le langage défini dans le chapitre~\ref{cha:lang} d'un
système de types. Celui-ci permet d'obtenir plus de garanties que celui de C tel
que décrit dans \cite{AnsiC}.

Il permet le polymorphisme sur les types pointeurs, permettant par exemple de
typer :

\begin{mathpar}
⊢ \text{memcpy} : ∀ a . (a^*, a^*, \tInt) \rightarrow \tVoid
\end{mathpar}

\section{Règles de typage}

\subsection{Types}

Dans cette section, on définit la notion de programme bien typé. L'analyse par
typage permet de vérifier qu'à chaque expression on peut associer un type, et ce
de manière cohérente entre plusieurs utilisations d'une variable.

Les types des valeurs sont :

\gramlr{Types}{
\begin{align*}
τ  \gramisa & \tInt, \tFloat, \tVoid        & \textrm{Constante}
\\ \gramor  &  a                            & \textrm{Variable}
\\ \gramor  & (τ_1, …, τ_n) \rightarrow τ_r & \textrm{Fonction}
\\ \gramor  & [τ]                           & \textrm{Tableau}
\\ \gramor  & τ*                            & \textrm{Pointeur}
\\ \gramor  & \{ f_1:τ_1
              ,    …
              , f_n:τ_n \}                  & \textrm{Structure}
\end{align*}
}

L'ensemble des types possibles (défini inductivement ci-dessus) sera noté
\textsc{Typ}, et l'ensemble des variables de type par \textsc{VarTyp}.

\subsection{Schémas de type}

On va associer à chaque variable globale un type. Mais faire de même pourrait
être trop restrictif. En effet, une fonction comme memcpy peut être utilisée
pour copier des tableaux d'entiers, mais aussi de flottants. On va donc associer
un schéma de types à chaque fonction.

\gramlr{Schémas}{
\begin{align*}
σ \gramisa & ∀ \vec{a} . τ
\end{align*}
}

Un schéma de types correspond à un ensemble de types. Prenons l'exemple de la
fonction identité : elle a pour schéma de types $∀ a . a \rightarrow a$, ce qui
signifie que pour chaque type $τ$, on peut l'utiliser avec le type $τ
\rightarrow τ$. Plus précisément, cela veut dire que puisque $a$ est quantifiée,
on peut le substituer par n'importe quel autre type.

\begin{definition}[Substitution]
Une substitution est une fonction partielle de \textsc{VarTyp} dans
\textsc{Typ}. Elle sera notée par exemple $s = \{ a ↦ \tInt, b ↦ (\tFloat
\rightarrow \tInt)\}$.

Le support d'une substition, noté $\textrm{Supp}(s)$, est son domaine de
définition.

On définit aussi l'application d'une substitution sur un type quelconque : si
$s$ est une substitution, $\overline{s}$ est son extension définie par :

\begin{align*}
\overline{s}(a)   =~& s(a) & \textrm{si $a$ est une variable}  \\
\overline{s}(c)   =~& c    & \textrm{si $c$ est une constante} \\
\overline{s}([τ]) =~& [\overline{s}(τ)] & \\
\overline{s}(τ*)  =~& \overline{s}(τ)*   & \\
\overline{s}(τ_1, …, τ_n) \rightarrow τ_r =~& (\overline{s}(τ_1), …, \overline{s}(τ_n)) \rightarrow \overline{s}(τ_r) \\
\overline{s}(\{ f_1:τ_1, … ,f_n:τ_n \}) =~& \{ f_1:\overline{s}(τ_1), …, f_n:\overline{s}(τ_n) \}
\end{align*}

Par souci de simplicité, on notera $s$ pour $\overline{s}$.
\end{definition}

\begin{definition}[Instanciation]
Un schéma de types $σ = ∀ \vec{a} . τ$ peut être instancié en un type $μ$ s'il
existe une substition $s$ telle que :

\begin{itemize}
\item $\textrm{Supp}(s) ⊆ \vec{a}$
\item $s(τ) = μ$
\end{itemize}

On note alors $μ ≤ σ$.
\end{definition}

\begin{definition}[Variables libres]
Les variables libres d'un type sont l'ensemble des variables de types qui
apparaissent dans celui-ci :

\begin{align*}
\tFV{a}   =~& ∅    & \textrm{si $a$ est une variable}  \\
\tFV{c}   =~& ∅    & \textrm{si $c$ est une constante} \\
\tFV{[τ]} =~& \tFV{τ} & \\
\tFV{τ*}  =~& \tFV{τ} & \\
\tFV{(τ_1, …, τ_n) \rightarrow τ_r} =~& \tFV{τ_1} ∪ … ∪ \tFV{τ_n} ∪ \tFV{τ_r} \\
\tFV{\{ f_1:τ_1, … ,f_n:τ_n \}} =~& \tFV{τ_1} ∪ … ∪ \tFV{τ_n}
\end{align*}
\end{definition}

\begin{definition}[Généralisation]
La généralisation consiste à construire un schéma de type à partir d'un type, en
quantifiant sur les variables libres :

\[
\textrm{Gen}(τ) = ∀ \vec{a} . τ \quad \textrm{où} \quad \vec{a} = \tFV{τ}
\]
\end{definition}

En associant un schéma de type $σ$ à une fonction $f$, on indique que la
fonction pourra être utilisée avec tout type $τ$ qui est une instanciation de
$σ$.

\subsection{Environnements de typage}

Chaque jugement de typage est effectué dans un environnement de typage $Γ$
particulier, qui contient le contexte nécessaire : ici, le type des fonctions et
variables du programme.

\gramlr{Environnements}{
\begin{align*}
Γ  \gramisa & (Γ_{fun}, Γ_{var}) & \textrm{Fonctions, variables}
\end{align*}

\begin{align*}
Γ_{fun} \gramisa & ε           & \textrm{Environnement vide}
\\      \gramor  & Γ_{fun},f:σ & \textrm{Ajout d'une fonction}
\end{align*}

\begin{align*}
Γ_{var} \gramisa & ε           & \textrm{Environnement vide}
\\      \gramor  & Γ_{var},v:τ & \textrm{Ajout d'une variable}
\end{align*}
}

Lorsque ce n'est pas ambigü, si $Γ=(Γ_{fun},Γ_{var})$ on notera les extensions
d'environnement $Γ,f:σ$ pour $((Γ_{fun},f:σ), Γ_{var})$ et $Γ,x:τ$ pour
$(Γ_{fun},(Γ_{var},x:τ))$. De même, on notera $(f, σ) ∈ Γ$ si $(f, σ) ∈
Γ_{fun}$, ou $(x, τ) ∈ Γ$ si $(x, τ) ∈ Γ_{var}$.

\subsection{Jugements de typage}

Un des principes du typage est d'associer à chaque expression un type, qui
décrit le genre des valeurs produites par l'évaluation de cette fonction.

\begin{definition}[Jugement de typage]
Un jugement de typage est de la forme $Γ ⊢ e : τ$ et se lit "sous $Γ$, $e$ est
typable en $τ$".
\end{definition}

Les instructions et blocs, au contraire, n'ont pas de type.

\begin{definition}[Bloc bien typé]
On note $Γ ⊢ i$ pour "sous $Γ$, $i$ est bien typé", c'est à dire que ces sous
expressions sont typables en accord avec le flot de données (par exemple, pour
que l'instruction $lv \leftarrow e$ soit bien typée sous $Γ$, il faut que les
types de $lv$ et de $e$ puissent avoir le même type sous $Γ$).
\end{definition}

Le cas des fonctions est particulier puisque celles-ci ont un schéma de types
qui leur est associé.

\begin{definition}[Fonction bien typée]
On note $Γ ⊢ f : σ$ le fait qu'une fonction $f$ est typable en un schéma $σ$ dans $Γ$.
\end{definition}

Enfin, la notion de programme bien typé est intrinsèque : elle se fait
indépendemment d'un environnement externe.

\begin{definition}[Programme bien typé]
Un programme $P$ est bien typé s'il existe un environnement $Γ$ permettant de bien
typer toutes les composantes (fonctions, globales et bloc d'initialisation) d'un
programme. On notera alors $⊢ P$.
\end{definition}

\subsection{Programme}

Au niveau global, un programme P est bien typé (noté $⊢ P$) s'il existe un
environnement $Γ = (\vec{σ}, \vec{τ})$ permettant de typer ses composantes (les fonctions, les
globales et le bloc d'initialisation).

\[
\irule{Prog}{
  (\vec{σ}, \vec{τ}) ⊢ \vec{f} : \vec{σ} \\
  (\vec{σ}, \vec{τ}) ⊢ \vec{x} : \vec{t} \\
  (\vec{σ}, \vec{τ}) ⊢ b
}{
  ⊢ (\vec{f}, \vec{x}, b)
}
\]

\subsection{Flot de contrôle}

Les règles suivantes permettent de définir les jugements $Γ ⊢ i$. De manière
générale, les instructions sont bien typées si leurs sous-instructions sont bien typées.

\begin{mathpar}
\irule{Pass}{
}{
  Γ ⊢ ε
}
\and
\irule{Seq}{
  Γ ⊢ s \\
  Γ ⊢ b
}{
  Γ ⊢ s;b
}
\and
\irule{While}{
  Γ ⊢ b
}{
  Γ ⊢ \npkWhile{b}
}
\and
\irule{Goto}{
}{
  Γ ⊢ \npkGoto{l}
}
\and
\irule{DoWith}{
  Γ ⊢ b
}{
  Γ ⊢ \npkDoWith{b}{l}
}
\end{mathpar}

Dans le cas de la conditionnelle, il est en plus nécessaire de vérifier que la
condition est un entier.

\begin{mathpar}
\irule{If}{
  Γ ⊢ e : \tInt \\
  Γ ⊢ i_t \\
  Γ ⊢ i_f
}{
  Γ ⊢ \npkIf{e}{i_t}{i_f}
}
\end{mathpar}

\subsection{Left values}

On associe à chaque left-value un type, qui est aussi le type des valeurs que
celle-ci peut contenir. Le cas des variables est direct : si un couple
(variable, type) est dans l'environnement de typage, la variable possède ce
type.

\begin{mathpar}
\irule{Lv-Var}{
  (v, τ) ∈ Γ
}{
  Γ ⊢ v : τ
}
\end{mathpar}

Si une expression a un type pointeur, en la déréférençant on obtient une valeur
du type pointé.

\begin{mathpar}
\irule{Lv-Deref}{
  Γ ⊢ e : τ*
}{
  Γ ⊢ *e : τ
}
\end{mathpar}

\todo{accès à un élément d'un type composite}

\begin{mathpar}
\irule{Lv-Field}{
  Γ ⊢ lv : τ_s \\
  (f, τ_f) ∈ τ_s
}{
  Γ ⊢ lv.f : τ_f
}
\and
\irule{Lv-Array}{
  Γ ⊢ lv : [τ] \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ lv[e] : τ
}
\end{mathpar}

\subsection{Expressions}

Les constantes ont leurs types habituels. Notons que le pointeur nul (\cNil) a
un type polymorphe.

\begin{mathpar}
\irule{Const-Int}{
}{
  Γ ⊢ n : \tInt
}
\and
\irule{Const-Float}{
}{
  Γ ⊢ f : \tFloat
}
\and
\irule{Const-Nil}{
}{
  Γ ⊢ \cNil : τ*
}
\end{mathpar}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
\irule{Op-Int}{
  \textrm{op} ∈ \{+,-,\times,/,\&,|,\opxor,\&\&,||,⋘,⋙\} \\
  Γ ⊢ e_1 : \tInt \\
  Γ ⊢ e_2 : \tInt
}{
  Γ ⊢ e_1~\textrm{op}~e_2 : \tInt
}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
\irule{Op-Float}{
  \textrm{op} ∈ \{+.,-.,\times.,/.\} \\
  Γ ⊢ e_1 : \tFloat \\
  Γ ⊢ e_2 : \tFloat
}{
  Γ ⊢ e_1~\textrm{op}~e_2 : \tFloat
}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes de types
"comparables". On introduit donc un jugement $\textsc{Comparable}(τ)$ qui est
vrai pour les types \tInt, \tFloat et pointeurs. Les comparaisons renvoient
alors un \tInt.

\begin{mathpar}
\irule{Cmp-Num}
  {τ ∈ \{ \tInt, \tFloat \}}
  {\textsc{Comparable}(τ)}
\and
\irule{Cmp-Ptr}
  { }
  {\textsc{Comparable}(τ*)}
\and
\irule{Op-Cmp}{
  \textrm{op} ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : τ \\
  Γ ⊢ e_2 : τ \\
  \textsc{Comparable}(τ)
}{
  Γ ⊢ e_1~\textrm{op}~e_2 : \tInt
}
\end{mathpar}

L'opérateur unaire "$-$" peut être appliqué à un \tInt ou à un \tFloat.

\begin{mathpar}
\irule{Unop-Minus}{
  τ ∈ \{ \tInt, \tFloat \} \\
  Γ ⊢ e : τ
}{
  Γ ⊢ -e : τ
}
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
\irule{Unop-Not}{
  \textrm{op} ∈ \{ \textasciitilde, ! \} \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ \textrm{op}~e : \tInt
}
\end{mathpar}

On peut prendre l'adresse d'une left-value, et obtenir un pointeur vers
celle-ci. Le type du résultat est un type pointeur vers le type de base.

\begin{mathpar}
\irule{AddrOf}{
  Γ ⊢ lv : τ
}{
  Γ ⊢ \&lv : τ*
}
\end{mathpar}

La règle concernant les pointeurs sur fonction est similaire, à ceci près qu'une
fonction a un schéma de type, qu'il faut instancier afin d'obtenir un type
pointeur.

\begin{mathpar}
\irule{AddrOfFun}{
  Γ ⊢ f : σ \\
  τ ≤ σ
}{
  Γ ⊢ \&f : τ
}
\end{mathpar}

\subsection{Fonctions}

Pour typer une fonction, on commence par ajouter ses paramètres dans
l'environnement de typage, et on type la définition de la fonction. Le type
résultant est généralisé.

\todo{Vérifier qu'il n'y a pas de problème entre polymorphisme et mutabilité}

\todo{Notation vecteur}

\[
\irule{Fun}{
  Γ' = Γ ⊕ \{ args(f) = \vec{τ} \} \\
  Γ' ⊢ body(f) \\
  Γ' ⊢ !ret : τ_r
}{
  Γ ⊢ f : Gen(\vec{τ} \rightarrow τ_r, Γ)
}
\]

\subsection{Instructions}

Pour typer une déclaration, il suffit de rajouter la variable avec n'importe
quel type dans l'environnement de typage.

\begin{mathpar}
\irule{Decl}{
  Γ , x : τ ⊢ b
}{
  Γ ⊢ \npkDecl{x}{b}
}
\end{mathpar}

Une affectation est bien typée si elle faite entre une left-value et une
expression de même type.

\begin{mathpar}
\irule{Assign}{
  Γ ⊢ lv : τ \\
  Γ ⊢ e  : τ
}{
  Γ ⊢ lv \leftarrow e
}
\end{mathpar}

\wip{}

\begin{mathpar}
\irule{Fcall}{
  Γ ⊢ lv : τ_{ret} \\
  Γ ⊢ fe : σ \\
  Γ ⊢ \vec{e} : \vec{τ} \\
  (\vec{τ} \rightarrow τ_r) ≤ σ
}{
  Γ ⊢ lv \leftarrow fe(\vec{e})
}
\end{mathpar}

\section{Limitations}
\subsection{Programmes non typables}
\subsection{Incohérences}
