\epigraph{Well-typed programs don't go wrong.}
{--- \textup{Robin Milner}}

Dans ce chapitre, nous enrichissons le langage défini dans le
chapitre~\ref{cha:lang} d'un système de types. Celui-ci permet de séparer les
programmes bien formés, comme celui de la figure~\ref{fig:progwf:good} des
programmes mal formés comme celui de la figure~\ref{fig:progwf:bad}.

\begin{SaveVerbatim}[]{VerbProgGood}
f()
(x=0)
{
  x = 1
  return x
}
\end{SaveVerbatim}

\begin{SaveVerbatim}[]{VerbProgBad}
f()
(x=0)
{
  x = 1
  return (*x)
}
\end{SaveVerbatim}

\begin{figure}

  \centering

  \subbottom[Programme bien formé]{
    \label{fig:progwf:good}
    \BUseVerbatim{VerbProgGood}
  }
  \hspace{2cm}
  \subbottom[Programme mal formé]{
    \label{fig:progwf:bad}
    \BUseVerbatim{VerbProgBad}
  }

  \caption{Programmes bien et mal formés}
  \label{fig:progwf}

\end{figure}

Le but d'un tel système de types est de rejeter les programmes qui sont
"évidemment faux", c'est à dire dont on peut prouver qu'il provoqueraient des
erreurs à l'exécution dues à une incompatibilité entre valeurs. En ajoutant
cette étape, on restreint la classe d'erreurs qui pourraient bloquer la
sémantique.

\section{Principe}

Le principe est d'associer à chaque construction syntaxique une étiquette
représentant le genre de valeurs qu'elle produira. Dans le programme de la
figure~\ref{fig:progwf:good}, la variable $x$ est initialisée avec la valeur
$0$, c'est donc un entier. Cela signifie que dans tout le programme, toutes les
instances de cette variable
\footnote{Deux variables peuvent avoir le même nom dans deux fonctions
  différentes, par exemple. Dans ce cas il n'y a aucune contrainte particulière
  entre ces deux variables. L'analyse de typage se fait toujours dans un
  contexte précis.
}
porteront ce type. La première instruction est l'affectation de la constante $1$
(entière) à $x$ dont on sait qu'elle porte des valeurs entières, ce qui est donc
correct. Le fait de rencontrer $\iReturn{x}$ permet de conclure que le type de
la fonction est $() → \tInt$.

Dans la seconde fonction, au contraire, l'opérateur $*$ est appliqué à $x$ (le
début de l'analyse est identique et permet de conclure que $x$ porte des valeurs
entières). Or cet opérateur prend un argument d'un type pointeur de la forme
$t*$ et renvoie alors une valeur de type $t$. Ceci est valable pour tout $t$
(\tInt, \tFloat où même $t'*$ : le déréférencement d'un pointeur sur pointeur
donne un pointeur), mais le type de $x$, \tInt, n'est pas de cette forme. Ce
programme est donc mal typé.

\section{Environnements et notations}

\begin{figure}

  \begin{align*}
  \gramdef{Type}{t}
      { \tInt                         }{Entier}
      { \tFloat                       }{Flottant}
      { t[]                           }{Tableau}
      { t*                            }{Pointeur}
      { S                             }{Structure}
      { (t_1, …, t_n) \rightarrow t_r }{Fonction}
      {END}
  \\
  \gramdef{Structure}{S}
      { \{ l_1 : t_1; … ; l_n : t_n \} }{Structure simple}
      {END}
  \\
  \gramdef{Environnement de typage}{Γ}
      { []         }{Environnement vide}
      { (a, t)::Γ' }{Extension}
      {END}
  \end{align*}

  \caption{Types et environnements de typage}

  \label{fig:les-types}

\end{figure}

Les types associés aux expressions sont décrits dans la
figure~\ref{fig:les-types}.

Pour maintenir les contextes de typage, un environnement $Γ$ associe un type à
un ensemble de variables.

Plus précisément, un environnement $Γ$ est une liste de couples (variable,
type).

Par exemple, $(p, \tInt*) ∈ Γ$ permet de typer (sous $Γ$) l'expression $p$ en
$\tInt*$, $*p$ en $\tInt$ et $p +_p 4$ en $\tInt*$.

Le type des fonctions semble faire apparaître un n-uplet $(t_1, …, t_n)$ mais ce
n'est qu'une notation : il n'y a pas de n-uplets de première classe, ils sont
toujours présents dans un type fonctionnel.

\paragraph{Typage d'une expression :} on note de la manière suivante le fait
qu'une expression $e$ (telle que définie dans la figure~\ref{fig:stx-data}) ait
pour type $t$ dans le contexte $Γ$.

  \[
    \ty{Γ}{e}{t}
  \]

\paragraph{Typage d'une instruction :} les instructions n'ont en revanche pas de
type. Mais il est tout de même nécessaire de vérifier que troutes les
sous-expressions apparaissant dans une instruction sont cohérentes ensemble.

On note de la manière suivante le fait que sous l'environnement $Γ$
l'instruction $i$ est bien typée :

  \[
    \tyi{Γ}{i}
  \]

\paragraph{Typage d'une phrase :} De par leur nature séquentielle, les phrases
qui composent un programme altèrent l'environnement de typage. Par exemple, la
déclaration d'une variable globale ajoute une valeur dans l'environnement.

On note

  \[
    \typh{Γ}{p}{Γ'}
  \]

si le typage de la phrase $p$ transforme l'environnement $Γ$ en $Γ'$.

On étend cette notation aux suites de phrases :

  \[
    \begin{cases}
      \typhstar{Γ}{[]}{Γ}  \\
      \typhstar{Γ}{p::ps}{Γ'} \mbox{ si }
        ∃ Γ'',
            \begin{cases}
              \typh{Γ}{p}{Γ''}  \\
              \typhstar{Γ''}{ps}{Γ'}
            \end{cases}
    \end{cases}
  \]

\paragraph{Typage d'un programme :} Un programme est bien typé si on peut typer
sa suite de phrases en partant d'un environnement vide.
On note

  \[
    ⊢ P \eqdef ∃ Γ_f, \typhstar{[]}{P}{Γ_f}
  \]

\section{Expressions}

\subsection*{Littéraux}

Le typage des littéraux numériques ne dépend pas de l'environnement de typage :
ce sont toujours des entiers ou des flottants.

\begin{mathpar}

  \disprule{Cst-Int}

  \disprule{Cst-Float}

\end{mathpar}

Le pointeur nul, quant à lui, est compatible avec tous les types pointeur.

\begin{mathpar}
  \disprule{Cst-Null}
\end{mathpar}

Enfin, le littéral unité a le type $\tUnit$.

\begin{mathpar}
  \disprule{Cst-Unit}
\end{mathpar}

\subsection*{Left-values}

Rappelons que l'environnement de typage $Γ$ contient le type des variables
accessibles du programme. Le cas où la left-value à typer est une variable est
donc direct : il suffit de retrouver son type dans l'environnement.

\begin{mathpar}
  \disprule{Lv-Var}
\end{mathpar}

Dans le cas d'un déréférencement, on commence par typer la left-value
déréférencée. Si elle a un type pointeur, la valeur déréférencée est du type
pointé.

\begin{mathpar}
  \disprule{Lv-Deref}
\end{mathpar}

Pour une left-value indexée (l'accès à tableau), on s'assure que l'indice soit
entier, et que la left-value a un type tableau : le type de l'élement est encore
une fois le type de base du type tableau ($t$ pour $t[]$).

\begin{mathpar}
  \disprule{Lv-Index}
\end{mathpar}

Le typage de l'accès à un champ est facilité par le fait que dans le programme,
le type complet de la structure est accessible sur le champ.

Dans la définition de cette règle on utilise la notation :

\[
(l, t) ∈ \{l_1 : t_1 ; … ; l_n : t_n \}
\eqdef
∃ i ∈ [1;n],
l = l_i ∧ t = t_i
\]

\begin{mathpar}
  \disprule{Lv-Field}
\end{mathpar}

\subsection*{Opérateurs}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
  \disprule{Op-Int}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
  \disprule{Op-Float}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes qui sont d'un
type qui supporte l'égalité. Ceci est représenté par un jugement
$\textsc{Eq}(t)$ qui est vrai pour les types \tInt, \tFloat et pointeurs. Les
opérateurs $=$ et $≠$ renvoient alors un \tInt.

\begin{mathpar}
\disprule{Eq-Num}

\disprule{Eq-Ptr}

\disprule{Eq-Array}

\disprule{Op-Eq}
\end{mathpar}

%TODO Eq-Struct

Les comparaisons sont plus restrictives, et ne s'appliquent qu'aux types
primitifs (on ne peut pas comparer deux pointeurs, ou deux tableaux).

\begin{mathpar}
  \disprule{Op-Comparable}
\end{mathpar}

% TODO extensions aux structs et tableaux

Les opérateurs unaires "$+$" et "$-$" appliquent aux \tInt, et leurs équivalents
"$+.$" et "$-.$" aux \tFloat.

\begin{mathpar}
\disprule{Unop-Plus-Int}
\and
\disprule{Unop-Plus-Float}

\disprule{Unop-Minus-Int}
\and
\disprule{Unop-Minus-Float}
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
  \disprule{Unop-Not}
\end{mathpar}

L'arithmétique de pointeurs préserve le type des pointeurs.

\begin{mathpar}
  \disprule{Ptr-Arith}
\end{mathpar}

\subsection*{Autres expressions}

Prendre l'adresse d'une left-value rend un type pointeur sur le type de
celle-ci.

\begin{mathpar}
  \disprule{Addr}
\end{mathpar}

Pour typer une affectation, on vérifie que la left-value (à gauche) et
l'expression (à droite) ont le même type. C'est alors le type résultat de
l'expression d'affectation.

\begin{mathpar}
  \disprule{Set}
\end{mathpar}

Un littéral tableau a pour type $t[]$ où $t$ est le type de chacun de ses
éléments.

\begin{mathpar}
  \disprule{Array}
\end{mathpar}

Un littéral de structure est bien typé si ses champs sont bien typés.

\begin{mathpar}
  \disprule{Struct}
\end{mathpar}

Pour typer un appel de fonction, on s'assure que la fonction a bien un type
fonctionnel. On type alors chacun des arguments avec le type attendu. Le
résultat est du type de retour de la fonction.

\begin{mathpar}
  \disprule{Call}
\end{mathpar}

\section{Instructions}

La séquence est simple à traiter : l'instruction vide est toujours bien typée,
et la suite de deux instructions est bien typée si celles-ci le sont également.

\begin{mathpar}
  \disprule{Pass}

  \disprule{Seq}
\end{mathpar}

Une instruction constituée d'une expression est bien typée si celle-ci peut être
typée dans ce même contexte.

\begin{mathpar}
  \disprule{Exp}
\end{mathpar}

Les constructions de contrôle sont bien typées si leurs sous-instructions sont
bien typées, et si la condition est d'un type entier.

\begin{mathpar}
  \disprule{If}

  \disprule{While}
\end{mathpar}

\section{Fonctions}

Le typage des fonctions fait intervenir une variable virtuelle $\vRet$. Cela
revient à typer l'instruction $\iReturn{e}$ comme $\vRet ← e$.

\begin{mathpar}
  \disprule{Return}
\end{mathpar}

Pour typer une définition de fonction, on commence par créer un nouvel
environnement de typage $Γ'$ obtenu par la suite d'opérations suivantes :

\begin{itemize}
\item
  on enlève (s'il existe) le couple $\vRet : t_f$ correspondant à la
  valeur de retour de la fonction appelante
\item
  on ajoute les types des arguments $a_i : t_i$
\end{itemize}

On vérifie alors que les initialiseurs $e_i$ ont le bon type $t'_i$. Ensuite, à
partir de $Γ'$ :

\begin{itemize}
\item
  on ajoute les types des variables locales $l_i : t'_i$
\item
  on ajoute le type de la valeur de retour de la fonction appelée,
  $\vRet : t$
\end{itemize}

Il reste alors à vérifier que dans l'environnement $Γ''$ résultant, le corps de
la fonction est bien typé. Le type de la fonction est alors $(t_1, …, t_n) → t$.

\begin{mathpar}
  \disprule{Fun}
\end{mathpar}

Cette règle utilise les notations suivantes :

\begin{align*}
\vec{a}
\eqdef &
(a_1, …, a_n) \textrm{ où } n = |a|
\\
\textrm{zip}(\vec{a}, \vec{b})
\eqdef &
((a_1, b_1), …, (a_n, b_n))
\textrm{ où } n = |a| = |b|
\\
Γ ⊢ \vec{e} : \vec{t}
\eqdef &
∀ i ∈ [1;n],
Γ ⊢ e_i : t_i
\textrm{ où } n = |e| = |t|
\end{align*}

% TODO suppression & adjonction aux Γ

\section{Phrases}

L'évaluation d'une expression est le cas le plus simple. En effet, il y a juste
à vérifier que celle-ci est bien typable (avec ce type) dans l'environnement de
départ. L'environnement n'est pas modifié.

\begin{mathpar}
  \disprule{Ph-Exp}
\end{mathpar}

La déclaration d'une variable globale commence de la même manière, mais on
enrichit l'environnement de cette nouvelle valeur.

\begin{mathpar}
  \disprule{Ph-Var}
\end{mathpar}

\section{Sûreté du typage}

Un programme bien typé possède des propriétés de sûreté.

\paragraph{Progrès :} l'évaluation d'un terme bien typé ne reste pas bloquée;
il y a toujours une règle qui s'applique.

\paragraph{Préservation :} l'évaluation d'un terme bien typé produit un terme
bien typé.

Puisqu'il s'agit de propriétés reliant la syntaxe à la sémantique, deux types
d'environnement sont utilisés en même temps. D'une part, les environnement de
typage $Γ$ pour la syntaxe, et d'autre part les environnements mémoire $m$ pour
la sémantique. Il est nécessaire de définir une relation de compatibilité entre
ces deux mondes, pour exprimer par exemple qu'un état mémoire contient dans la
variable $x$ un entier.

On commence par énoncer quelques lemmes utiles dans la démonstration de ces
théorèmes.

Les règles précédentes ont la particularité suivante : pour chaque forme
syntaxique, il n'y a souvent qu'une règle qui peut s'appliquer. Cela permet de
déduire quelle règle il faut appliquer pour vérifier (ou inférer) le type d'une
expression.

\begin{lemma}[Inversion] \label{lemma:inversion}

  À partir d'un jugement de typage, on peut en déduire des informations sur les
  types de ses sous-expressions.

\begin{itemize}
\item
  Constantes
  \begin{itemize}
    \item si $Γ ⊢ n : t$, alors $t = \tInt$
    \item si $Γ ⊢ d : t$, alors $t = \tFloat$
    \item si $Γ ⊢ \eNull : t$, alors $∃ t', t = t'*$
    \item si $Γ ⊢ \eUnit : t$, alors $t = \tUnit$
  \end{itemize}

\item Références mémoire :
  \begin{itemize}
    \item
      si $Γ ⊢ x : t$, $x : t ∈ Γ$
    \item
      si $Γ ⊢ *lv : t$, alors $Γ ⊢ lv : t*$
    \item
      si $Γ ⊢ lv[e] : t$, alors $Γ ⊢ lv : t[]$ et $Γ ⊢ e : \tInt$
    \item
      si $Γ ⊢ lv.l_S : t$, alors $Γ ⊢ lv : S$

  \end{itemize}
\item
  Appel de fonction : si $Γ ⊢ e (e_1, …, e_n) : t$, il existe $(t_1, …, t_n)$
  tels que

  \[
    \begin{cases}
      Γ ⊢ e : (t_1, …, t_n) → t \\
      ∀ i ∈ [1;n], Γ ⊢ e_i : t_i
    \end{cases}
  \]

\item Fonction : si $Γ ⊢ \mathrm{fun} (a_1, …, a_n) ((l_1, e_1), …, (l_p, e_p))
  \{i\} : t$, alors il existe $(t_1, …, t_n)$ et $t'$ tels que $t' = (t_1, …,
  t_n) → t$.

  % TODO ...
\end{itemize}

\end{lemma}

% TODO finir la preuve

\begin{proof}

  Pour chaque jugement, on considère les règles qui peuvent amener à cette
  conclusion.

\begin{itemize}
\item
  Références mémoire :

  \begin{itemize}

    \item $Γ ⊢ x : t$

      La seule règle de cette forme est \textsc{Lv-Var}. Puisque sa prémisse est
      vraie, on en conclut que $x : t ∈ Γ$.

    \item $Γ ⊢ *φ : t$

      De même, seule la règle \textsc{Lv-Deref} convient. On en conclut que $Γ ⊢ φ : t*$.

    \item $Γ ⊢ φ[] : t$

      Idem avec \textsc{Lv-Index}.

    \item $Γ ⊢ φ.l : t$

      $Γ ⊢ φ : \{ l: t ; … \}$ %TODO sûrement différent sans S

  \end{itemize}

\item
  Appel de fonction : pour en arriver à $Γ ⊢ e (e_1, …, e_n) : t$, seule la
  règle \textsc{Call} s'applique, ce qui permet de conclure.

\item Fonction : la seule règle possible pour conclure une dérivation de

  \[
    Γ ⊢ \mathrm{fun} (a_1, …, a_n) ((l_1, e_1), …, (l_p, e_p)) \{i\} : t
  \]
  est \textsc{Fun}.

\end{itemize}
\end{proof}

Il est aussi possible de réaliser l'opération inverse : à partir du type d'une
valeur, on peut déterminer sa forme syntaxique. C'est bien sûr uniquement
possible pour les valeurs, pas pour n'importe quelle expression (par exemple
l'expression $x$ (variable) peut avoir n'importe quel type $t$ dans le contexte
$Γ = x:t$).

\begin{lemma}[Formes canoniques] \label{lemma:canon}

  Il est possible de déterminer la forme syntaxique d'une valeur étant donné son
  type.

  \begin{itemize}
  \item si $Γ ⊢ v : \tInt$, $v = n$.
  \item si $Γ ⊢ v : \tFloat$, $v = d$.
  \item si $Γ ⊢ v : \tUnit$, $v = \eUnit$.
  \item si $Γ ⊢ v : t*$, $v = φ$ ou $v = \eNull$.
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = f$.
  \item si $Γ ⊢ v : t*$, $v = φ$.
  \item si $Γ ⊢ v : t[]$, $v = \{v_1; …; v_n\}$.
    %TODO structures
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = \mathrm{fun}
    (a_1, …, a_n) ((l_1, e_1), …, (l_p, e_p))$.
  \end{itemize}

\end{lemma}

Ces lemmes étant établis, on énonce maintenant le théorème de progrès accompagné
d'une notion de compatibilité entre envionnements de typage $Γ$ et états mémoire
$m$.

\begin{definition}[Compatibilité mémoire]

  Soient $Γ$ un environnement de typage et $m = x_1 ↦ v_1, …, x_n ↦ v_n$ un état
  mémoire. On dit que $m$ est compatible avec $Γ$ si

  \[
    ∃ (t_1, …, t_n),
    ∀ i ∈ [1;n],
    \begin{cases} Γ ⊢ x_i : t_i
               \\ Γ ⊢ v_i : t_i
    \end{cases}
  \]

  On note alors $\mcomp{Γ}{m}$.

  % TODO les états mémoires ne sont pas linéaires
  % TODO quid de ce qui n'est pas visible (ie, le tas)

\end{definition}

\begin{theorem}[Progrès]
  \label{thm:progres}

  Supposons que $Γ ⊢ e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai :

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mcomp{Γ}{m'} ∧ \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}

  C'est à dire, soit :

\begin{itemize}
  \item $e$ est complètement évaluée
  \item un pas d'évaluation préservant la compatibilité mémoire est possible
  \item une erreur de division, tableau ou pointeur se produit
\end{itemize}

\end{theorem}

\begin{theorem}[Progrès pour les left-values]
  \label{thm:progres-lv}

  Si $\mmstar{m}{lv}{m'}{v}$, $v$ est de la forme $φ$ (référence mémoire) ou $Ω$
  (erreur).

\end{theorem}

% TODO à prouver et rerédiger

La preuve des
théorèmes~\ref{thm:progres}
et~\ref{thm:progres-lv}
se trouve en annexe~\ref{proof:progres}.

\begin{lemma}[Permutation]
  L'ordre dans lequel les variables apparaissent dans un environnement
  n'influe pas sur la relation de typage.

  Pour toute permutation $σ$ de $[1;n]$, on note $σ(x_1 : t_1, …, x_n : t_n) =
  x_{σ(1)} : t_{σ(1)}, … x_{σ(n)} : t_{σ(n)}$.

  Alors : si $Γ ⊢ e : t$ et $Γ' = σ(Γ)$, alors $Γ' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Affaiblissement]
  De même que l'ordre n'influe pas le typage, on peut aussi ajouter des
  associations supplémentaires dans l'environnement sans modifier les typages
  dans cet environnement.

  Si $Γ ⊢ e : t$ et $x ∉ \mathrm{dom}(Γ)$, alors $Γ, x : t' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Substitution]
  Si dans une expression $e$ il apparait une variable $x$ de type $t'$, le
  typage est préservé lorsqu'on remplace ses occurrences par une expression $e'$
  de même type.

  Si $Γ, x : t' ⊢ e : t$ et $Γ ⊢ e' : t'$, alors $Γ ⊢ e [x/e'] : t$.
\end{lemma}

Ces lemmes permettent de prouver le théorème suivant :

\begin{theorem}[Préservation]
  \label{thm:preservation}

  Si une expression est typable, alors un pas d'évaluation ne modifie pas son
  type :

  Si $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{e'}$, alors $Γ ⊢ e' : t$.

\end{theorem}

La preuve de ce théorème se trouve en annexe~\ref{proof:preservation}.

\section*{TODO}

\begin{itemize}
\item ordre des sections
\item versions $Γ ⊢ i$ des propriétés
\item preuve de progres : état mémoire : doublet/triplet
\item définir les opérations d'ajout/remplacement sur les contextes de typage
\item 2 pointeurs peuvent etre égaux sans comparer les valeurs pointées
\item extension de contextes : :: ou , ?
\end{itemize}

\subsection*{Fonctions}

\begin{itemize}
\item
  page 50 règle CALL une remarque disant que cette règle doit être
  utilisée avec une autre qui va typer le corps de la fonction (mettre
  la ref) parce que sinon ça surprend
\item
  5.5 le fait de choisir une unique variable R t'oblige à ajouter une
  opération de suppression du R de la fonction appelante factice.
  Pourquoi ne pas générer des variables fraîches à partir du nom de la
  fonction + un identifiant unique ?
\item
  lemme 5.1 cas fonction, à quoi ça sert d'introduire la notation t'
  alors qu'il n'apparaît pas dans une règle ?
\end{itemize}

\subsection*{Rq}
(passe Sarah 17/01)

\begin{itemize}
\item
  5.3 left-values la règle LV-VAR suppose que x n'apparaît qu'une fois
  dans $\Gamma$ ou alors toujours accompagné du même type
\item
  p53 le terme de dérivation (première phrase de la preuve) n'a jamais
  été expliqué ?
\item
  lemme 5.1 constantes. Il faut expliquer à quel ensemble n et f
  appartiennent
\item
  lemme 5.2 même remarque que 5.1 concernant n et f (plus confusion f
  float et f fonction)
\item
  lemme 5.3 ça ne marche que si une variable n'apparaît qu'une fois dans
  le contexte ou avec toujours le même type (cf rem ci-dessous sur 5.3)
\item
  il manque les preuves de 5.3 et 5.4
\item
  lemme 5.4 $dom(\Gamma)$ a été défini quelque part ?
\item
  théormèe 5.2 rappeler où a été défini l'évaluation d'une expression et
  dans quel cas elle produit des valeurs
\end{itemize}

