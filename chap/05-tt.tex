\epigraph{Well-typed programs don't go wrong.}
{--- \textup{Robin Milner}}

Dans ce chapitre, nous enrichissons le langage défini dans le
chapitre~\ref{cha:lang} d'un système de types. Celui-ci permet de séparer les
programmes bien formés, comme celui de la figure~\ref{fig:progwf:good} des
programmes mal formés comme celui de la figure~\ref{fig:progwf:bad}.

\begin{SaveVerbatim}[]{VerbProgGood}
f()
(x=0)
{
  x = 1
  return x
}
\end{SaveVerbatim}

\begin{SaveVerbatim}[]{VerbProgBad}
f()
(x=0)
{
  x = 1
  return (*x)
}
\end{SaveVerbatim}

\begin{figure}

  \centering

  \subbottom[Programme bien formé]{
    \label{fig:progwf:good}
    \BUseVerbatim{VerbProgGood}
  }
  \hspace{2cm}
  \subbottom[Programme mal formé]{
    \label{fig:progwf:bad}
    \BUseVerbatim{VerbProgBad}
  }

  \caption{Programmes bien et mal formés}
  \label{fig:progwf}

\end{figure}

Le but d'un tel système de types est de rejeter les programmes qui sont
"évidemment faux", c'est à dire dont on peut prouver qu'il provoqueraient des
erreurs à l'exécution dues à une incompatibilité entre valeurs. En ajoutant
cette étape, on restreint la classe d'erreurs qui pourraient bloquer la
sémantique.

\section{Principe}

Le principe est d'associer à chaque construction syntaxique une étiquette
représentant le genre de valeurs qu'elle produira. Dans le programme de la
figure~\ref{fig:progwf:good}, la variable $x$ est initialisée avec la valeur
$0$, c'est donc un entier. Cela signifie que dans tout le programme, toutes les
instances de cette variable
\footnote{Deux variables peuvent avoir le même nom dans deux fonctions
  différentes, par exemple. Dans ce cas il n'y a aucune contrainte particulière
  entre ces deux variables. L'analyse de typage se fait toujours dans un
  contexte précis.
}
porteront ce type. La première instruction est l'affectation de la constante $1$
(entière) à $x$ dont on sait qu'elle porte des valeurs entières, ce qui est donc
correct. Le fait de rencontrer $\iReturn{x}$ permet de conclure que le type de
la fonction est $() → \tInt$.

Dans la seconde fonction, au contraire, l'opérateur $*$ est appliqué à $x$ (le
début de l'analyse est identique et permet de conclure que $x$ porte des valeurs
entières). Or cet opérateur prend un argument d'un type pointeur de la forme
$t*$ et renvoie alors une valeur de type $t$. Ceci est valable pour tout $t$
(\tInt, \tFloat où même $t'*$ : le déréférencement d'un pointeur sur pointeur
donne un pointeur), mais le type de $x$, \tInt, n'est pas de cette forme. Ce
programme est donc mal typé.

\section{Environnements et notations}

\begin{figure}

  \begin{align*}
  \gramdef{Type}{t}
      { \tInt                         }{Entier}
      { \tFloat                       }{Flottant}
      { t[]                           }{Tableau}
      { t*                            }{Pointeur}
      { S                             }{Structure}
      { (t_1, …, t_n) \rightarrow t_r }{Fonction}
      {END}
  \\
  \gramdef{Structure}{S}
      { \eStruct{ l_1 : t_1; … ; l_n : t_n } }{Structure simple}
      {END}
  \\
  \gramdef{Environnement de typage}{Γ}
      { []         }{Environnement vide}
      { (a, t)::Γ' }{Extension}
      {END}
  \end{align*}

  \caption{Types et environnements de typage}

  \label{fig:les-types}

\end{figure}

Les types associés aux expressions sont décrits dans la
figure~\ref{fig:les-types}.

Pour maintenir les contextes de typage, un environnement $Γ$ associe un type à
un ensemble de variables.

Plus précisément, un environnement $Γ$ est une liste de couples (variable,
type).

Par exemple, $(p, \tInt*) ∈ Γ$ permet de typer (sous $Γ$) l'expression $p$ en
$\tInt*$, $*p$ en $\tInt$ et $p +_p 4$ en $\tInt*$.

Le type des fonctions semble faire apparaître un n-uplet $(t_1, …, t_n)$ mais ce
n'est qu'une notation : il n'y a pas de n-uplets de première classe, ils sont
toujours présents dans un type fonctionnel.

\paragraph{Typage d'une expression :} on note de la manière suivante le fait
qu'une expression $e$ (telle que définie dans la figure~\ref{fig:stx-data}) ait
pour type $t$ dans le contexte $Γ$.

  \[
    \ty{Γ}{e}{t}
  \]

\paragraph{Typage d'une instruction :} les instructions n'ont en revanche pas de
type. Mais il est tout de même nécessaire de vérifier que troutes les
sous-expressions apparaissant dans une instruction sont cohérentes ensemble.

On note de la manière suivante le fait que sous l'environnement $Γ$
l'instruction $i$ est bien typée :

  \[
    \tyi{Γ}{i}
  \]

\paragraph{Typage d'une phrase :} De par leur nature séquentielle, les phrases
qui composent un programme altèrent l'environnement de typage. Par exemple, la
déclaration d'une variable globale ajoute une valeur dans l'environnement.

On note

  \[
    \typh{Γ}{p}{Γ'}
  \]

si le typage de la phrase $p$ transforme l'environnement $Γ$ en $Γ'$.

On étend cette notation aux suites de phrases :

  \[
    \begin{cases}
      \typhstar{Γ}{[]}{Γ}  \\
      \typhstar{Γ}{p::ps}{Γ'} \mbox{ si }
        ∃ Γ'',
            \begin{cases}
              \typh{Γ}{p}{Γ''}  \\
              \typhstar{Γ''}{ps}{Γ'}
            \end{cases}
    \end{cases}
  \]

\paragraph{Typage d'un programme :} Un programme est bien typé si on peut typer
sa suite de phrases en partant d'un environnement vide.
On note

  \[
    ⊢ P \eqdef ∃ Γ_f, \typhstar{[]}{P}{Γ_f}
  \]

\section{Expressions}

\subsection*{Littéraux}

Le typage des littéraux numériques ne dépend pas de l'environnement de typage :
ce sont toujours des entiers ou des flottants.

\begin{mathpar}

  \disprule{Cst-Int}

  \disprule{Cst-Float}

\end{mathpar}

Le pointeur nul, quant à lui, est compatible avec tous les types pointeur.

\begin{mathpar}
  \disprule{Cst-Null}
\end{mathpar}

Enfin, le littéral unité a le type $\tUnit$.

\begin{mathpar}
  \disprule{Cst-Unit}
\end{mathpar}

\subsection*{Left-values}

Rappelons que l'environnement de typage $Γ$ contient le type des variables
accessibles du programme. Le cas où la left-value à typer est une variable est
donc direct : il suffit de retrouver son type dans l'environnement.

\begin{mathpar}
  \disprule{Lv-Var}
\end{mathpar}

Dans le cas d'un déréférencement, on commence par typer la left-value
déréférencée. Si elle a un type pointeur, la valeur déréférencée est du type
pointé.

\begin{mathpar}
  \disprule{Lv-Deref}
\end{mathpar}

Pour une left-value indexée (l'accès à tableau), on s'assure que l'indice soit
entier, et que la left-value a un type tableau : le type de l'élement est encore
une fois le type de base du type tableau ($t$ pour $t[]$).

\begin{mathpar}
  \disprule{Lv-Index}
\end{mathpar}

Le typage de l'accès à un champ est facilité par le fait que dans le programme,
le type complet de la structure est accessible sur le champ.

Dans la définition de cette règle on utilise la notation :

\[
(l, t) ∈ \eStruct{l_1 : t_1 ; … ; l_n : t_n }
\eqdef
∃ i ∈ [1;n],
l = l_i ∧ t = t_i
\]

\begin{mathpar}
  \disprule{Lv-Field}
\end{mathpar}

\subsection*{Opérateurs}

Un certain nombre d'opérations est possible sur le type \tInt.

\begin{mathpar}
  \disprule{Op-Int}
\end{mathpar}

De même sur \tFloat.

\begin{mathpar}
  \disprule{Op-Float}
\end{mathpar}

Les opérateurs de comparaison peuvent s'appliquer à deux opérandes qui sont d'un
type qui supporte l'égalité. Ceci est représenté par un jugement
$\textsc{Eq}(t)$ qui est vrai pour les types \tInt, \tFloat et pointeurs. Les
opérateurs $=$ et $≠$ renvoient alors un \tInt.

\begin{mathpar}
\disprule{Eq-Num}

\disprule{Eq-Ptr}

\disprule{Eq-Array}

\disprule{Op-Eq}
\end{mathpar}

%TODO Eq-Struct

% TODO rajouter les ops de comparaison

% TODO extensions aux structs et tableaux

Les opérateurs unaires "$+$" et "$-$" appliquent aux \tInt, et leurs équivalents
"$+.$" et "$-.$" aux \tFloat.

\begin{mathpar}
\disprule{Unop-Plus-Int}
\and
\disprule{Unop-Plus-Float}

\disprule{Unop-Minus-Int}
\and
\disprule{Unop-Minus-Float}
\end{mathpar}

Les opérateurs de négation unaires, en revanche, ne s'appliquent qu'aux
entiers.

\begin{mathpar}
  \disprule{Unop-Not}
\end{mathpar}

L'arithmétique de pointeurs préserve le type des pointeurs.

\begin{mathpar}
  \disprule{Ptr-Arith}
\end{mathpar}

\subsection*{Autres expressions}

Prendre l'adresse d'une left-value rend un type pointeur sur le type de
celle-ci.

\begin{mathpar}
  \disprule{Addr}
\end{mathpar}

Pour typer une affectation, on vérifie que la left-value (à gauche) et
l'expression (à droite) ont le même type. C'est alors le type résultat de
l'expression d'affectation.

\begin{mathpar}
  \disprule{Set}
\end{mathpar}

Un littéral tableau a pour type $t[]$ où $t$ est le type de chacun de ses
éléments.

\begin{mathpar}
  \disprule{Array}
\end{mathpar}

Un littéral de structure est bien typé si ses champs sont bien typés.

\begin{mathpar}
  \disprule{Struct}
\end{mathpar}

Pour typer un appel de fonction, on s'assure que la fonction a bien un type
fonctionnel. On type alors chacun des arguments avec le type attendu. Le
résultat est du type de retour de la fonction.

\begin{mathpar}
  \disprule{Call}
\end{mathpar}

\section{Instructions}

La séquence est simple à traiter : l'instruction vide est toujours bien typée,
et la suite de deux instructions est bien typée si celles-ci le sont également.

\begin{mathpar}
  \disprule{Pass}

  \disprule{Seq}
\end{mathpar}

Une instruction constituée d'une expression est bien typée si celle-ci peut être
typée dans ce même contexte.

\begin{mathpar}
  \disprule{Exp}
\end{mathpar}

Une déclaration de variable est bien typée si son bloc interne est bien typé
quand on ajoute à l'environnement la variable avec le type de son initialiseur.

\begin{mathpar}
  \disprule{Decl}
\end{mathpar}

Les constructions de contrôle sont bien typées si leurs sous-instructions sont
bien typées, et si la condition est d'un type entier.

\begin{mathpar}
  \disprule{If}

  \disprule{While}
\end{mathpar}

\section{Fonctions}

Le typage des fonctions fait intervenir une variable virtuelle $\vRet$. Cela
revient à typer l'instruction $\iReturn{e}$ comme $\vRet ← e$.

\begin{mathpar}
  \disprule{Return}
\end{mathpar}

Pour typer une définition de fonction, on commence par créer un nouvel
environnement de typage $Γ'$ obtenu par la suite d'opérations suivantes :

\begin{itemize}
\item
  on enlève (s'il existe) le couple $\vRet : t_f$ correspondant à la
  valeur de retour de la fonction appelante
\item
  on ajoute les types des arguments $a_i : t_i$
\item
  on ajoute le type de la valeur de retour de la fonction appelée,
  $\vRet : t$
\end{itemize}

Si le corps de la fonction est bien typé sous $Γ'$, alors la fonction est
typable en $(t_1, …, t_n) → t$ sous $Γ$.

\begin{mathpar}
  \disprule{Fun}
\end{mathpar}

Cette règle utilise les notations suivantes :

\begin{align*}
\vec{a}
\eqdef &
(a_1, …, a_n) \textrm{ où } n = |a|
\\
\vec{a} : \vec{t}
\eqdef &
a_1: t_1,…
a_n: t_n \textrm{ où } n = |a|
\end{align*}

% TODO suppression & adjonction aux Γ

\section{Phrases}

L'évaluation d'une expression est le cas le plus simple. En effet, il y a juste
à vérifier que celle-ci est bien typable (avec ce type) dans l'environnement de
départ. L'environnement n'est pas modifié.

\begin{mathpar}
  \disprule{T-Exp}
\end{mathpar}

La déclaration d'une variable globale commence de la même manière, mais on
enrichit l'environnement de cette nouvelle valeur.

\begin{mathpar}
  \disprule{T-Var}
\end{mathpar}

\section{Sûreté du typage}

\subsection{But}

Comme nous l'évoquions au début de ce chapitre, le but du typage est de rejeter
certains programmes afin de ne garder que ceux qui ne provoquent pas un certain
type d'erreurs à l'exécution.

Dans cette section, nous donnons des propriétés que respectent tous les
programmes bien typés. Il est traditionnel de rappeler l'adage de Robin Milner :

\begin{quote}
  Well-typed programs don't go wrong.
\end{quote}

\emph{To go wrong} reste bien sûr à définir ! Cette sûreté du typage repose sur
les deux théorèmes :

\begin{itemize}
\item progrès :
  si un terme est bien typé, il y a toujours une règle
  d'évaluation qui s'applique.
\item
  préservation (ou \emph{subject reduction}) :
  l'évaluation transforme un terme bien typé en un terme du même type.
\end{itemize}

\subsection{Typage des valeurs}

\subsection{Progrès et Préservation}

\paragraph{Progrès :} l'évaluation d'un terme bien typé ne reste pas bloquée;
il y a toujours une règle qui s'applique.

\paragraph{Préservation :} l'évaluation d'un terme bien typé produit un terme
bien typé.

Puisqu'il s'agit de propriétés reliant la syntaxe à la sémantique, deux types
d'environnement sont utilisés en même temps. D'une part, les environnement de
typage $Γ$ pour la syntaxe, et d'autre part les environnements mémoire $m$ pour
la sémantique. Il est nécessaire de définir une relation de compatibilité entre
ces deux mondes, pour exprimer par exemple qu'un état mémoire contient dans la
variable $x$ un entier.

On commence par énoncer quelques lemmes utiles dans la démonstration de ces
théorèmes.

Les règles précédentes ont la particularité suivante : pour chaque forme
syntaxique, il n'y a souvent qu'une règle qui peut s'appliquer. Cela permet de
déduire quelle règle il faut appliquer pour vérifier (ou inférer) le type d'une
expression.

\begin{lemma}[Inversion] \label{lemma:inversion}

  À partir d'un jugement de typage, on peut en déduire des informations sur les
  types de ses sous-expressions.

\begin{itemize}
\item
  Constantes
  \begin{itemize}
    \item si $Γ ⊢ n : t$, alors $t = \tInt$
    \item si $Γ ⊢ d : t$, alors $t = \tFloat$
    \item si $Γ ⊢ \eNull : t$, alors $∃ t', t = t'*$
    \item si $Γ ⊢ \eUnit : t$, alors $t = \tUnit$
  \end{itemize}

\item Références mémoire :
  \begin{itemize}
    \item
      si $Γ ⊢ x : t$, alors $x : t ∈ Γ$
    \item
      si $Γ ⊢ *lv : t$, alors $Γ ⊢ lv : t*$
    \item
      si $Γ ⊢ lv[e] : t$, alors $Γ ⊢ lv : t[]$ et $Γ ⊢ e : \tInt$
    \item
      si $Γ ⊢ lv.l_S : t$, alors $Γ ⊢ lv : S$

  \end{itemize}

\item Opérations :
  \begin{itemize}
    \item si $ Γ ⊢ \opun~e : t $, alors on est dans un des cas suivants :
      \begin{itemize}
        \item
          $\opun ∈ \{+,-,\sim, ! \}$,
          $t = \tInt$,
          $Γ ⊢ e : \tInt$
        \item
          $\opun ∈ \{+.,-.\}$,
          $t = \tFloat$,
          $Γ ⊢ e : \tFloat$
      \end{itemize}
    \item si $ Γ ⊢ e_1~\opbin~e_2 : t $, un des cas suivants se présente :
      \begin{itemize}
        \item
          $\opbin ∈ \opbinintset{}$,
          $Γ ⊢ e_1 : \tInt$,
          $Γ ⊢ e_2 : \tInt$,
          $t = \tInt$
        \item
          $\opbin ∈ \opbinfloatset{}$,
          $Γ ⊢ e_1 : \tFloat$,
          $Γ ⊢ e_2 : \tFloat$,
          $t = \tFloat$
        \item
          $\opbin ∈ \{=,≠\}$,
          $Γ ⊢ e_1 : t'$,
          $Γ ⊢ e_2 : t'$,
          $\textsc{Eq}(t')$,
          $t = \tInt$
        \item
          $\opbin ∈ \{≤,≥,<,>\}$,
          $t = \tInt$,
          $Γ ⊢ e_1 : t'$,
          $Γ ⊢ e_2 : t'$,
          $t' ∈ \{ \tInt, \tFloat \}$
        \item
          $\opbin ∈ \{+_p, -_p\}$,
          $∃t', t = t'*$,
          $Γ ⊢ e_1 : t'*$,
          $Γ ⊢ e_2 : \tInt$
      \end{itemize}
  \end{itemize}
\item
  Appel de fonction : si $Γ ⊢ e (e_1, …, e_n) : t$, il existe $(t_1, …, t_n)$
  tels que

  \[
    \begin{cases}
      Γ ⊢ e : (t_1, …, t_n) → t \\
      ∀ i ∈ [1;n], Γ ⊢ e_i : t_i
    \end{cases}
  \]

\item Fonction : si $Γ ⊢ \mathrm{fun} (a_1, …, a_n) \{i\} : t$, alors il existe
$(t_1, …, t_n)$ et $t'$ tels que $t' = (t_1, …, t_n) → t$.

  % TODO ...
\end{itemize}

\end{lemma}

% TODO finir la preuve

\begin{proof}

  Pour chaque jugement, on considère les règles qui peuvent amener à cette
  conclusion.

\begin{itemize}
\item
  Références mémoire :

  \begin{itemize}

    \item $Γ ⊢ x : t$

      La seule règle de cette forme est \textsc{Lv-Var}. Puisque sa prémisse est
      vraie, on en conclut que $x : t ∈ Γ$.

    \item $Γ ⊢ *φ : t$

      De même, seule la règle \textsc{Lv-Deref} convient. On en conclut que $Γ ⊢ φ : t*$.

    \item $Γ ⊢ φ[] : t$

      Idem avec \textsc{Lv-Index}.

    \item $Γ ⊢ φ.l : t$

      $Γ ⊢ φ : \eStruct{ l: t ; … }$ %TODO sûrement différent sans S

  \end{itemize}

\item
  Appel de fonction : pour en arriver à $Γ ⊢ e (e_1, …, e_n) : t$, seule la
  règle \textsc{Call} s'applique, ce qui permet de conclure.

\item Fonction : la seule règle possible pour conclure une dérivation de

  \[
    Γ ⊢ \mathrm{fun} (a_1, …, a_n) \{i\} : t
  \]
  est \textsc{Fun}.

\end{itemize}
\end{proof}

Il est aussi possible de réaliser l'opération inverse : à partir du type d'une
valeur, on peut déterminer sa forme syntaxique. C'est bien sûr uniquement
possible pour les valeurs, pas pour n'importe quelle expression (par exemple
l'expression $x$ (variable) peut avoir n'importe quel type $t$ dans le contexte
$Γ = x:t$).

\begin{lemma}[Formes canoniques] \label{lemma:canon}

  Il est possible de déterminer la forme syntaxique d'une valeur étant donné son
  type.

  \begin{itemize}
  \item si $Γ ⊢ v : \tInt$, $v = n$.
  \item si $Γ ⊢ v : \tFloat$, $v = d$.
  \item si $Γ ⊢ v : \tUnit$, $v = \eUnit$.
  \item si $Γ ⊢ v : t*$, $v = φ$ ou $v = \eNull$.
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = f$.
  \item si $Γ ⊢ v : t*$, $v = φ$.
  \item si $Γ ⊢ v : t[]$, $v = \eArray{v_1; …; v_n}$.
    %TODO structures
  \item si $Γ ⊢ v : (t_1, …, t_n) → t$, $v = \mathrm{fun}
    (a_1, …, a_n) \{i\}$.
  \end{itemize}

\end{lemma}

Ces lemmes étant établis, on énonce maintenant le théorème de progrès accompagné
d'une notion de compatibilité entre envionnements de typage $Γ$ et états mémoire
$m$.

\begin{definition}[Compatibilité mémoire]

  Soient $Γ$ un environnement de typage et $m = x_1 ↦ v_1, …, x_n ↦ v_n$ un état
  mémoire. On dit que $m$ est compatible avec $Γ$ si

  \[
    ∃ (t_1, …, t_n),
    ∀ i ∈ [1;n],
    \begin{cases} Γ ⊢ x_i : t_i
               \\ Γ ⊢ v_i : t_i
    \end{cases}
  \]

  On note alors $\mcomp{Γ}{m}$.

  % TODO les états mémoires ne sont pas linéaires
  % TODO quid de ce qui n'est pas visible (ie, le tas)

\end{definition}

\begin{definition}[Typage de la mémoire]

\[
  Γ ⊧ m \eqdef ∀ x ∈ \mathrm{Visible}(m). Γ, m ⊧ x
\]

\[
  Γ, m ⊧ x \eqdef ∃ t. Γ, m ⊧ x : t
\]

La définition de $Γ, m ⊧ x : t$ dépend de $v = m[x]_Φ$. On pose $Γ, m ⊧ x : t
\eqdef P(v)$ avec :

\begin{itemize}
  \item $P(c) \eqdef Γ ⊢ c : t$
  \item $P(f) \eqdef Γ ⊢ f : t$
  \item $P(φ) \eqdef ∃t'. t = t'* ∧ Γ, m ⊧ y : t'$ où $y = m[φ]_Φ$
  \item $P(\eArray{v_1;…;v_n}) \eqdef
    ∃ t'. t = t'[~]
        ∧ ∀ i ∈ [1;n]. Γ ⊢ v_i : t'$
  \item $P(\eStruct{l_1:v_1;…;l_n:v_n}) \eqdef
    ∃ (t_1, …, t_n). t = \eStruct{l_1:t_1;…;l_n:t_n}
                   ∧ ∀ i ∈ [1;n]. Γ ⊢ v_i : t_i$
\end{itemize}

\end{definition}

% TODO definit Visible

\begin{theorem}[Progrès]
  \label{thm:progres}

  Supposons que $Γ ⊢ e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai :

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mcomp{Γ}{m'} ∧ \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}

  C'est à dire, soit :

\begin{itemize}
  \item $e$ est complètement évaluée
  \item un pas d'évaluation préservant la compatibilité mémoire est possible
  \item une erreur de division, tableau ou pointeur se produit
\end{itemize}

\end{theorem}

\begin{theorem}[Progrès pour les left-values]
  \label{thm:progres-lv}

  Si $\mmstar{m}{lv}{m'}{v}$, $v$ est de la forme $φ$ (référence mémoire) ou $Ω$
  (erreur).

\end{theorem}

% TODO à prouver et rerédiger

La preuve des
théorèmes~\ref{thm:progres}
et~\ref{thm:progres-lv}
se trouve en annexe~\ref{proof:progres}.

\begin{lemma}[Permutation]
  L'ordre dans lequel les variables apparaissent dans un environnement
  n'influe pas sur la relation de typage.

  Pour toute permutation $σ$ de $[1;n]$, on note $σ(x_1 : t_1, …, x_n : t_n) =
  x_{σ(1)} : t_{σ(1)}, … x_{σ(n)} : t_{σ(n)}$.

  Alors : si $Γ ⊢ e : t$ et $Γ' = σ(Γ)$, alors $Γ' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Affaiblissement]
  De même que l'ordre n'influe pas le typage, on peut aussi ajouter des
  associations supplémentaires dans l'environnement sans modifier les typages
  dans cet environnement.

  Si $Γ ⊢ e : t$ et $x ∉ \mathrm{dom}(Γ)$, alors $Γ, x : t' ⊢ e : t$.
\end{lemma}

\begin{lemma}[Substitution]
  Si dans une expression $e$ il apparait une variable $x$ de type $t'$, le
  typage est préservé lorsqu'on remplace ses occurrences par une expression $e'$
  de même type.

  Si $Γ, x : t' ⊢ e : t$ et $Γ ⊢ e' : t'$, alors $Γ ⊢ e [x/e'] : t$.
\end{lemma}

Ces lemmes permettent de prouver le théorème suivant :

\begin{theorem}[Préservation]
  \label{thm:preservation}

  Si une expression est typable, alors un pas d'évaluation ne modifie pas son
  type :

  Si $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{e'}$, alors $Γ ⊢ e' : t$.

\end{theorem}

La preuve de ce théorème se trouve en annexe~\ref{proof:preservation}.

\section*{TODO}

\begin{itemize}
\item ordre des sections
\item versions $Γ ⊢ i$ des propriétés
\item preuve de progres : état mémoire : doublet/triplet
\item définir les opérations d'ajout/remplacement sur les contextes de typage
\item 2 pointeurs peuvent etre égaux sans comparer les valeurs pointées
\item extension de contextes : :: ou , ?
\end{itemize}

\subsection*{Fonctions}

\begin{itemize}
\item
  page 50 règle CALL une remarque disant que cette règle doit être
  utilisée avec une autre qui va typer le corps de la fonction (mettre
  la ref) parce que sinon ça surprend
\item
  5.5 le fait de choisir une unique variable R t'oblige à ajouter une
  opération de suppression du R de la fonction appelante factice.
  Pourquoi ne pas générer des variables fraîches à partir du nom de la
  fonction + un identifiant unique ?
\item
  lemme 5.1 cas fonction, à quoi ça sert d'introduire la notation t'
  alors qu'il n'apparaît pas dans une règle ?
\end{itemize}

\subsection*{Rq}
(passe Sarah 17/01)

\begin{itemize}
\item
  5.3 left-values la règle LV-VAR suppose que x n'apparaît qu'une fois
  dans $\Gamma$ ou alors toujours accompagné du même type
\item
  p53 le terme de dérivation (première phrase de la preuve) n'a jamais
  été expliqué ?
\item
  lemme 5.1 constantes. Il faut expliquer à quel ensemble n et f
  appartiennent
\item
  lemme 5.2 même remarque que 5.1 concernant n et f (plus confusion f
  float et f fonction)
\item
  lemme 5.3 ça ne marche que si une variable n'apparaît qu'une fois dans
  le contexte ou avec toujours le même type (cf rem ci-dessous sur 5.3)
\item
  il manque les preuves de 5.3 et 5.4
\item
  lemme 5.4 $dom(\Gamma)$ a été défini quelque part ?
\item
  théormèe 5.2 rappeler où a été défini l'évaluation d'une expression et
  dans quel cas elle produit des valeurs
\end{itemize}

\section*{Extrait PLAS}

We add a static type system to \langname. The goal is to devise a tractable
syntactic method to reject a class of buggy programs.

\begin{figure}

  \centering
  {\small{

  \begin{align*}
  \gramdefshort{Types}{t}
      { \tInt,\tFloat,\tUnit        }{Ground types}
      { t[~]                        }{Array}
      { t~q*                        }{Qualified pointer}
      { S                           }{Structure}
      { (t_1, …, t_n) \rightarrow t }{Function}
      {END}
  \\
  \gramdefshort{Qualifiers}{q}
    { \qKernel }{Kernel data (safe)}
    { \qUser   }{User data (unsafe)}
    {END}
  \\
  \gramheadershort{Structure}{S} \\
  &  \{ l_1 : t_1; … ; l_n : t_n \} & \textrm{Simple structure} \\
  \\
  \gramdefshort{Typing environment}{Γ}
      { [~]        }{Empty environment}
      { (a, t)::Γ' }{Extension}
      {END}
\end{align*}}}

  \caption{Types and typing environments}

  \label{fig:les-types}

\end{figure}%
%
Our types (Figure~\ref{fig:les-types}) are all ground types ; no polymorphism is
present. The main distinctiveness is that instead of having a plain pointer type
$t~*$, our one is decorated with a type qualifier $q$. This annotation expresses
who controls the value of the pointer. If the kernel controls the value of the
pointer, then it cannot be abused. On the other hand, one has to be careful
with user-controlled pointers, because the caller can abuse the kernel and
access reserved memory. The only safe case when dereferencing such a pointer is
if its value is outside the kernel's memory.

In order to avoid dangerous cases, we have to dynamically check that the
destination of every user-controlled pointer is in userspace. Kernel pointers
(that is to say, kernel-controlled pointers) can be dereferenced without further
check, but user pointers have to be manipulated with a restricted interface that
will check whether their destination is in userspace.

As mentioned before, this is done using the following constructs:%
{\small
\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}}%
To add qualifiers to a type system, the rules of interest are those that
manipulate pointers: dereferencing, pointer arithmetic and referencing (taking
the address of a left-value).

Dereferencing the easiest one ; our goal is to authorize dereferencing only
\qKernel pointers:

{\small \[ \disprule{Lv-Deref} \]}%

Pointer arithmetic can be done inside a \qUser or \qKernel memory zone. There is
no concern of jumping from userspace to kernelspace, because pointer arithmetic
is checked at runtime: if these operators overflow or are applied to a bad
pointer (such as a pointer to an integer field), $\serr{ptr}$ is raised.

{\small \[ \disprule{Ptr-Arith} \]}%

The reference case is trickier because a type qualifier has to be synthesized.
Because it is created on the kernel stack, it has a \qKernel qualifier in all
cases:
{\small \[
  \disprule{Addr}
\]}%

The $\eTaint{\cdot}$ operator turns a \qUser pointer into a \qKernel pointer.
It is an important rule, because it is the only source of \qUser pointers in the
type system.
%{\small \[ \disprule{Taint} \] }% TODO
The return value of a function is emulated with a virtual left-value $\vRet$.%
{\small \begin{mathpar}
  \disprule{Return}

  \disprule{Fun}
\end{mathpar}}%

Toplevel sentences are typed one after another. Because they can extend an
environment, the general form of toplevel typing is $\typh{Γ}{p}{Γ'}$.

\begin{mathpar}
    \disprule{T-Exp}

    \disprule{T-Var}
\end{mathpar}

The whole set of typing rules can be found in annex in Figures~\ref{fig:typ-exp}
and~\ref{fig:typ-inst}.

\section*{Type Safety}

This type system is sound with respect to the semantics defined in
Section~\ref{sec:eval}; that is, we have the desired property that
\emph{well-typed programs cannot go wrong}.

Let us start by defining a semantic typing relation between typing environments,
memory states, variable names and types.

Variables in memory have store types $τ$, depending only on a memory state $m$.
They are very similar to the previous types $t$, but the arrow function type is
replaced by $\stFun{n}$, denoting a $n$-ary function. This is because at runtime,
no type information for functions is left.

We define a relation $m ⊧ x : τ$ to express that $x$ is semantically typed $τ$
under $m$ (Figure~\ref{fig:st}). Constants are easy to type as there is
enough information to recognize them; functions have a simple dynamic type, only
retaining the arity. For memory references, anything that can be dereferenced to
a $τ$ is a $τ~\qKernel~*$; and user memory references are ``untainted'' to
access the underlying storage.
\begin{figure}[hbt]
  \centering
  \small
\begin{mathpar}
  \irule{S-Int}{ }{m ⊧ n : \tInt}

  \irule{S-Float}{ }{m ⊧ d : \tFloat}

  \irule{S-Unit}{ }{m ⊧ \eUnit : \tUnit}

  \irule{S-Ref} { m ⊧ m [φ]_Φ : τ} { \widehat{\&}~φ : τ~\qKernel~*}

  \irule{S-Null}{ }{m ⊧ \eNull : t~q~*}

  \irule{S-Tainted}
    { m ⊧           φ'  : t~\qKernel~* }
    { m ⊧ \vTainted{φ'} : t~\qUser~* }

  \irule{S-Fun}{ } {m ⊧ \mathrm{fun} (x_1, …, x_n) \{ i \} : \stFun{n}}

  \irule{S-Array}
    { ∀i ∈ [1;n]. m ⊧ v_i : t }
    { m ⊧ \widehat{ [ v_1;…;v_n ] } : t[~] }

  \irule{S-Struct}
    { ∀i ∈ [1;n]. m ⊧ v_i : t_i
   \\ S = \{ l_1:t_1;…;l_n:t_n \}
    }
    { m ⊧ \widehat{ \{ l_1:v_1;…;l_n:v_n \} } : S }
\end{mathpar}

\caption{Semantic typing rules}
\label{fig:st}
\end{figure}%

We also need a $\tComp{\cdot}{\cdot}$ relation to express compatibility between
types of expressions and semantic types (of values): ground types are
compatible with themselves, type constructors are compatible if their components
are compatible, and we add a rule for functions:%
\[ \tComp{\stFun{n}}{(t_1, …, t_n) → t} \]

Then a memory state $m$ is well-typed under a typing environment $Γ$, which we
will write $Γ ⊧ m$, if the semantic types of visible variable coincide with
their static types
\footnote{
  $\mathrm{dom}(Γ)$ returns the set of variables present in
  $Γ$, which also corresponds to visible variables.
}
:%
{ \small \[
  ∀ x ∈ \mathrm{dom}(Γ). ∃ τ,t.
  \begin{cases}
      \tComp{τ}{t} \\
      m ⊧ x : τ \\
      Γ ⊢ x : t
  \end{cases}
\] }%

This proves that no term stays stuck, and that that typing is well-behaved we
respect to the semantics. It means that the type is really a contract between
expressions and functions: if their evaluation converge, then a value of the
inferred type will be produced.

