\epigraph{A friend of mine in a compiler writing class produced a compiler with
         one error message "you lied to me when you told me this was a program".
        }{--- \textup{Pete Fenelon}}

Dans le chapitre~\ref{cha:typbase}, nous avons vu comment ajouter un système de
types forts statiques à un langage impératif (défini dans le
chapitre~\ref{cha:lang}).

Ici, nous étendons l'expressivité de \langname avec un système d'annotations de
"souillure" (\emph{tainting} en anglais). Un cas d'erreur est ajouté, lorsqu'on
tente d'accéder à une valeur souillée. Avec cet ajout, la propriété de progrès
(théorème~\ref{thm:progres}) n'est donc plus valable.

Afin de retrouver cette adéquation entre la sémantique et le systme de typage,
ce dernier est étendu d'un système de \emph{qualificateurs de type} qui
décrivent l'origine des données. Ils permettent de restreindre certaines
opérations sensibles à des expressions dont la valeur est sûre.

La propriété de progrès est alors retrouvée (théorème~\ref{thm:progres-qual}).

\section{Extensions noyau pour \langname}

Jusqu'ici \langname, tel qu'il a été présenté dans le chapitre~\ref{cha:lang}
est un langage de programmation impératif généraliste. Aucune construction en
particulier n'est prévue pour implanter un système d'exploitation.

On ajoute donc la notion de valeur provenant de l'espace utilisateur (cf.
chapitre~\ref{cha:os}) en trois étapes (figure~\ref{fig:qualif-changes}) :

\begin{figure}%{{{

\begin{align*}
\gramdef{Expressions}{e}
  { … }{}
  { \eTaint{e} }{Expression souillée}
  { \uGet{lv}{e}}{ Lecture depuis l'espace utilisateur}
  { \uPut{e}{e}}{ Écriture dans l'espace utilisateur}
  {END}
\\
\gramdef{Contextes}{C}
  { … }{}
  { \eTaint{C}}{}
  {END}
\\
\gramdef{Chemins}{φ}
  { … }{}
  { \vTainted{φ} }{Valeur souillée}
  {END}
\\
\gramdef{Erreurs}{Ω}
  { … }{}
  { \serr{taint} }{Erreur de souillure}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateurs}
\label{fig:qualif-changes}
% TODO définir les états et ms

\end{figure}%}}}

\begin{itemize}
\item
  tout d'abord, on ajoute une expression d'annotation sur les variables que
  celles-ci sont contrôlés par un utilisateur non privilégié, ainsi que des
  opérateurs de copie sûre.
\item
  ensuite, on étend l'ensemble des valeurs possibles pour les pointeurs
  à une valeur $\vTainted{φ}$ signifiant que l'objet pointé se situe en
  espace utilisateur
\item
  enfin, on définit une nouvelle erreur $\serr{taint}$ produite par le
  déréférencement d'un pointeur ayant une telle valeur.
\end{itemize}

Pour adapter l'évaluation, plusieurs cas sont à rajouter. D'une part, la
présence de $\phx{\eTaint}$ dans une instruction consiste à ajouter un
$\phx{\vTainted}$ dans la valeur construite. Ceci ne peut être fait que dans le
cas où la valeur est un chemin $φ$, c'est à dire que la construction
$\phx{\eTaint}$ ne peut se faire que sur une expression de type pointeur.

\begin{mathpar}
  \irule{Expr-Tainted}
    { }
    { \mm{m}{\eTaint{φ}}{m}{\vTainted{φ}} }
\end{mathpar}

D'autre part, une règle accède à la mémoire : \textsc{Exp-Lv}; pour
rappel :

\begin{mathpar}
  \semrule{Exp-Lv}
\end{mathpar}

Puisque la définition des chemins $φ$ a été changée, il est aussi nécessaire de
redéfinir la lentille $Φ$ utilisée ci-dessus (définition~\ref{def:acces-phi}).

On rajoute donc le cas :

\begin{align*}
Φ(\vTainted{φ}) =& \serr{taint}
\end{align*}

Pour accéder à ces valeurs, il faut utiliser les opérateurs $\phxx\uGet$ et 
$\phxx\uPut$.

% TODO leur sémantique

\section{Insuffisance des types simples}

Étant donné \langname augmenté de cette extension sémantique, on peut étendre
trivialement le système de types avec la règle suivante :

\begin{mathpar}
  \irule{Taint-Ignore}
    { Γ ⊢ e : t* }
    { Γ ⊢ \eTaint{e} : t* }
\end{mathpar}

Cette règle est compatible avec l'extension, sauf qu'elle introduit des termes
qui sont bien typables mais dont l'évaluation provoque une erreur autre que
$\serr{div}$, $\serr{array}$ ou $\serr{ptr}$, violant ainsi le
théorème~\ref{thm:progres}.

Par exemple, supposons que $x$ soit une variable globale entière, et posons $e =
* \eTaint {\& x}$.

$e$ est alors bien typée sous $Γ = x : \tInt$ :

\begin{mathpar}
  \irule{Lv-Deref}
    {
      \irule{Taint-Ignore}
        {
          \irule{Lv-Deref}
            {
              \irule{Lv-Var}
                { x:\tInt ∈ Γ }
                { Γ ⊢ x : \tInt }
            }
            { Γ ⊢ \& x : \tInt*}
        }
        { Γ ⊢ \eTaint {\& x} : \tInt*}
    }
    { Γ ⊢ * \eTaint {\& x} : \tInt}
\end{mathpar}

Posons alors $m = ([[x↦0]], [])$ (on a bien $\mcomp{Γ}{m}$). L'évaluation de $e$
sous $m$ provoque une erreur, comme le montre la dérivation suivante.

\begin{mathpar}
\inferrule*
  {
    \irule{Exp-Lv}
      {
        \inferrule*
          { }
          {m[*\vTainted{x}] = \serr{taint}}
      }
      { \mm{m}{* \eTaint {\& x}}{m}{\serr{taint}} }
    \\
    \irule{Eval-Err}
      { }
      {
        \msi{m}{\serr{taint}} → \serr{taint}
      }
  }
  {\msi{m}{* \eTaint {\& x}} → \serr{taint}}
\end{mathpar}

\section{Extensions du système de types}

On présente ici un système de types plus expressif permettant de capturer les
extensions de sémantique. \emph{In fine}, cela permettra de prouver le
théorème~\ref{thm:progres-qual} qui est l'équivalent du
théorème~\ref{thm:progres} mais pour le nouveau jugement de typage.

Définit un nouveau système de types revient à définir un nouveau jugement de
typage $\cdot ⊢_q \cdot : \cdot$, à partir d'un ensemble de règles. Pour la
plupart, les règles seront identiques, donc sauf mention contraire, les règles
portant sur $\cdot ⊢ \cdot : \cdot$ s'appliqueront aussi sur $\cdot ⊢_q \cdot :
\cdot$. Naturellement, la plupart des différences porteront sur le traitement des
pointeurs.

La différence principale est qu'à à chaque pointeur, on ajoute un
\emph{qualificateur} qui représente \emph{qui} contrôle sa valeur
(section~\ref{sec:secu-syscalls}). Les deux qualificateurs sont :

\begin{itemize}
\item
  \qKernel : il s'applique aux pointeurs contrôlés par le noyau. Par exemple,
  prendre l'adresse d'un objet de la pile noyau donne un pointeur noyau.
\item
  \qUser : il s'applique aux pointeurs qui proviennent de l'espace utilisateur.
  Ces pointeurs proviennent toujours d'interfaces particulières, comme les
  appels système ou les paramètres de la fonction \texttt{ioctl}.
\end{itemize}

Cet ajout est précisé dans la figure~\ref{fig:qualif-changes-typ}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Qualificateurs}{q}
  { \qKernel }{Donnée noyau (sûre)}
  { \qUser   }{Donnée utilisateur (non sûre)}
  {END}
\\
\gramdef{Types}{t}
  { … }{}
  { \msout{t *} }{\textrm{Pointeur}}
  { t q* }{Pointeur qualifié}
  {END}
\end{align*}

\caption{Changements liés aux qualificateurs de types}
\label{fig:qualif-changes-typ}
\end{figure}%}}}

Au niveau du système de types, la principale restriction est que seuls les
pointeurs \qKernel peuvent être déréférencés de manière sûre :

\begin{mathpar}
\irule{Lv-Deref-Kernel}{
  Γ ⊢_q e : τ~\textsc{Kernel}*
}{
  Γ ⊢_q *e : τ
}
\end{mathpar}


L'opérateur $\eTaint{\cdot}$ transforme un pointeur selon la règle de souillure
suivante :

% TODO définir les stubs

\begin{mathpar}
\irule{Taint}
  { Γ ⊢_q e : t~q~* }
  { Γ ⊢_q \eTaint{x} : t~\qUser~* }
\end{mathpar}

Les opérateurs $\phxx\uGet$ et $\phxx\uPut$ sont typés de la manière suivante :

\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}

% TODO adresse = kernel

\subsection{Propriété d'isolation mémoire}

Le déréférencement d'un pointeur dont la valeur est contrôlée par l'utilisateur
ne peut se faire qu'à travers une fonction qui vérifie la sûreté de celui-ci.

\begin{theorem}[Progrès pour les types qualifiés]
  \label{thm:progres-qual}

  Supposons que $Γ ⊢_q e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai :

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mcomp{Γ}{m'} ∧ \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}
\end{theorem}

%\begin{proof}

  %% TODO

%\end{proof}

Et nous donnons un équivalent du théorème~\ref{thm:preservation}.

\begin{theorem}[Préservation pour les types qualifiés]

  Si une expression est typable et que son évaluation produit une valeur, alors
  cette valeur est du même type que l'expression.

  Si $Γ ⊢_q e : t$ et $e → v$ % TODO

  alors $Γ ⊢_q v : t$.

\end{theorem}

\begin{center}\rule{3in}{0.4pt}\end{center}

\clearpage

\section{Analyse de terminaison des chaînes C}%{{{

Dans ce chapitre, nous présentons une autre extension au système de types du
chapitre~\ref{cha:typbase}, similaire à celle de la section précédente.
Il s'agit cette fois-ci de détecter les pointeurs sur caractères (\texttt{char
*}) qui sont terminés par un caractère NUL et donc une chaîne C correcte. La
bibliothèque C propose quantité de fonctions manipulant ces chaînes et appeler
une fonction comme \texttt{strcpy} sur un pointeur quelconque est un problème de
sécurité que nous cherchons à détecter.

\subsection{But}

Le langage C ne fournit pas directement de type "chaîne de caractère". C'est au
programmeur de les gérer via des pointeurs sur caractère (\texttt{char *}).

En théorie le programmeur est libre de choisir une représentation : des chaînes
préfixées par la longueur, une structure contenant la taille et un pointeur vers
les données, ou encore une chaîne avec un terminateur comme 0.

Néanmoins c'est ce dernier style qui est le plus idiomatique : par exemple, les
littéraux de chaîne (\texttt{"comme ceci"}) ajoutent un octet nul à la fin. De
plus, le standard décrit dans la bibliothèque d'exécution de nombreuses
fonctions destinées à les manipuler --- c'est le fichier
\texttt{\textless{}string.h\textgreater{}} (\cite{AnsiC} section 7.21).

Ainsi la fonction \texttt{strcpy} a pour protoype :

\begin{Verbatim}
char *strcpy(char *dest, const char *src);
\end{Verbatim}

Elle réalise la copie de la chaîne pointée par \texttt{src} à l'endroit pointé
par \texttt{dest}. Pour détecter la fin de la chaîne, cette fonction parcourt la
mémoire jusqu'à trouver un caractère nul. Une implémentation naïve pourrait être:

\insertcode{strcpy.c}

La copie n'est arrêtée que lorsqu'un 0 est lu. Autrement dit, si quelqu'un
contrôle la valeur pointée par \texttt{src}, il pourra écraser autant de données
qu'il le désire. On est dans le cas d'école du débordement de tampon sur la pile
tel que décrit dans \cite{SmashingTheStack}. Considérons la fonction suivante :

\insertcode{strcpy-caller.c}

Si le pointeur \texttt{src} pointe sur une chaîne de longueur supérieure à 100
(ou une zone mémoire qui n'est pas une chaîne et ne contient pas de 0), les
valeurs placées sur la pile juste avant \texttt{buf} (à une adresse supérieure)
seront écrasées. Avec les conventions d'appel habituelles, il s'agit de
l'adresse de retour de la fonction. Un attaquant pourra donc détourner le flot
d'exécution du programme.

Pour éviter ces cas de fonctions vulnérables, on peut introduire une distinction
entre les pointeurs \texttt{char *} classiques (représentant l'adresse d'un
caractère par exemple) et les pointeurs sur une chaîne terminée par un caractère
nul.

Dans certaines bases de code (la plus célèbre étant celle de Microsoft), une
convention syntaxique est utilisée : les pointeurs vers des chaînes terminées
par 0 ont un nom qui commence par \texttt{sz}, comme \texttt{"szTitle"}. C'est
pourquoi nous appellerons ce qualificateur de type \texttt{sz}.

\subsection{Approche}

Cette propriété est un peu différente de la séparation entre espace utilisateur
et espace noyau modélisée précédemment : autant un pointeur reste contrôlé par
l'utilisateur (ou sûr) toute sa vie, autant le fait d'être terminé par un octet
nul dépend de l'ensemble de l'état mémoire. Il y a deux problèmes principaux à
considérer.

D'une part, l'\emph{aliasing} rend l'analyse difficile : si \texttt{p} et
\texttt{q} pointent tous les deux vers une même zone mémoire, le fait de
modifier l'un peut modifier l'autre. D'autre part, ce n'est pas parce qu'une
fonction maintient l'invariant de terminaison, qu'elle le maintient à chaque
instruction.

On peut résoudre en partie le problème d'\emph{aliasing} en étant très
conservateur, c'est à dire en sous-approximant l'ensemble des chaînes du
programme (on traitera une chaîne légitime comme une chaîne non terminée,
interdisant par excès de zèle les fonctions comme \texttt{strcpy}).

Le second problème est plus délicat puisqu'il casse l'hypothèse habituelle que
chaque variable conserve le même type au long de sa vie. Plusieurs techniques
sont possibles pour contourner ce problème : la première est d'être encore une
fois conservateur et d'interdire ces constructions (on ne pourrait alors
analyser que les programmes ne manipulant les chaînes qu'à travers les fonctions
de la bibliothèque standard). Une autre est d'insérer des annotations permettant
de s'affranchir localement du système de types. Enfin, il est possible
d'utiliser un système de types où les variables ont en plus d'un type, un
automate d'états possible dépendant de la position dans le programme : c'est le
concept de \emph{typestates}\cite{tse12-typestate}.

\subsection{Annotation de \texttt{string.h}}

Une première étape est d'annoter l'ensemble des fonctions manipulant les chaînes
de caractères.

\subsubsection{Fonctions de copie}

\paragraph{memcpy}

\begin{Verbatim}
void *memcpy(void *dest, const void *src, size_t n);
\end{Verbatim}

\paragraph{memmove}

\begin{Verbatim}
void *memmove(void *dest, const void *src, size_t n);
\end{Verbatim}

\paragraph{strcpy}

\begin{Verbatim}
char *strcpy(char *dest, const char *src);
\end{Verbatim}

\paragraph{strncpy}

\begin{Verbatim}
char *strncpy(char *dest, const char *src, size_t n);
\end{Verbatim}

\subsubsection{Fonctions de concaténation}

\paragraph{strcat}
\begin{Verbatim}
char *strcat(char *dest, const char *src);
\end{Verbatim}
\paragraph{strncat}
\begin{Verbatim}
char *strncat(char *dest, const char *src, size_t n);
\end{Verbatim}

\subsubsection{Fonctions de comparaison}

\paragraph{memcmp}
\begin{Verbatim}
int memcmp(const void *s1, const void *s2, size_t n);
\end{Verbatim}
\paragraph{strcmp}
\begin{Verbatim}
int strcmp(const char *s1, const char *s2);
\end{Verbatim}
\paragraph{strncmp}
\begin{Verbatim}
int strncmp(const char *s1, const char *s2, size_t n);
\end{Verbatim}
\paragraph{strcoll}
\begin{Verbatim}
int strcoll(const char *s1, const char *s2);
\end{Verbatim}
\paragraph{strxfrm}
\begin{Verbatim}
size_t strxfrm(char *dest, const char *src, size_t n);
\end{Verbatim}

\subsubsection{Fonctions de recherche}

\paragraph{memchr}
\begin{Verbatim}
void *memchr(const void *s, int c, size_t n);
\end{Verbatim}
\paragraph{strchr}
\begin{Verbatim}
char *strchr(const char *s, int c);
\end{Verbatim}
\paragraph{strcspn}
\begin{Verbatim}
size_t strcspn(const char *s, const char *reject);
\end{Verbatim}
\paragraph{strpbrk}
\begin{Verbatim}
char *strpbrk(const char *s, const char *accept);
\end{Verbatim}
\paragraph{strrchr}
\begin{Verbatim}
char *strrchr(const char *s, int c);
\end{Verbatim}
\paragraph{strspn}
\begin{Verbatim}
size_t strspn(const char *s, const char *accept);
\end{Verbatim}
\paragraph{strstr}
\begin{Verbatim}
char *strstr(const char *haystack, const char *needle);
\end{Verbatim}
\paragraph{strtok}
\begin{Verbatim}
char *strtok(char *str, const char *delim);
\end{Verbatim}

\subsubsection{Fonctions diverses}

\paragraph{memset}
\begin{Verbatim}
void *memset(void *s, int c, size_t n);
\end{Verbatim}
\paragraph{strerror}
\begin{Verbatim}
char *strerror(int errnum);
\end{Verbatim}
\paragraph{strlen}
\begin{Verbatim}
size_t strlen(const char *s);
\end{Verbatim}

\subsection{Typage des primitives}

\subsection{Extensions au système de types}

\subsection{Résultats}%}}}

\section*{TODO}

\begin{itemize}
\item appliquer taint sur des sous-valeurs?
\item vTaint doit se propager aux accès de champ
\item étendre l'état mémoire aux variables utilisateur
\end{itemize}

(passe Sarah)

\begin{itemize}
\item
  6.1.1 français dans ``qui représente qui contrôle sa valeur''
\item
  6.1.1 mettre une ref sur la description du noyau linux
\item
  la traduction de taintage par teintage est incorrecte (et des fois du
  garde la même orthographe que celle anglaise avec le `a') La
  traduction de tainted c'est plutôt sali, pollué. Tu peux aussi garder
  le terme anglais et le mettre en italique
\item
  j'ai arrêté de lire à partir de 6.2 parce que le texte n'est pas
  vraiment clair
\end{itemize}

% TODO le cimetière des règles

%\begin{mathpar}
%\irule{Taint-Erase}
  %{ }
  %{ \mmi{m}{\iTaint{x}}{m}{\iPass} }
%\end{mathpar}

%\begin{mathpar}
%\irule{Taint-Write-Old}
  %{ }
  %{ \mmi{m}{\iTaint{x}}{m[x ← \vTainted{m[x]}]}{\iPass} }
%\end{mathpar}

%\begin{mathpar}
%\irule{Taint-Write}
  %{ }
  %{ \mmi{m}{\iTaint{φ}}{m[φ ← \vTainted{m[φ]}]}{\iPass} }
%\end{mathpar}

% vim: spelllang=fr
