\epigraph{
  A friend of mine in a compiler writing class produced a compiler with
  one error message ``you lied to me when you told me this was a program''.
  }
  {--- \textup{Pete Fenelon}}

Jusqu'ici \langname est un langage impératif généraliste, ne prenant pas en
compte les spécificités de l'adressage utilisé dans les systèmes d'exploitation.

Dans ce chapitre, on commence par l'étendre en ajoutant des constructions
modélisant les variables présentes dans l'espace utilisateur (cf.
chapitre~\ref{cha:os}). Celles-ci restent accessibles, mais nécessitent
d'utiliser un opérateur de déréférencement sûr qui vérifie à l'exécution que
l'invariant suivant est respecté :

\begin{quote}
Les pointeurs dont la valeur est contrôlée par l'utilisateur, pointent vers
l'espace utilisateur.
\end{quote}

Pour prouver que cette approche est bien fondée, on procède en plusieurs étapes.

Tout d'abord, on définit un nouveau type d'erreur $\serr{taint}$, déclenché
lorsqu'un pointeur contrôlé par l'utilisateur et pointant vers le noyau (le cas
que l'on cherche à éviter) est déréférencer\footnote{Il est important de noter
  que ce cas d'erreur est ``virtuel'', la distinction entre pointeur contrôlé
  par l'utilisateur et par le noyau n'étant normalement pas visible à
l'exécution}.

Ensuite, on montre qu'avec cet ajout, si on étend naïvement le système de types
en donnant le même type aux pointeurs contrôlés par l'utilisateur et le noyau,
le théorème de progrès (\ref{thm:progres}) n'est plus valable.

L'étape suivante est d'étendre, à son tour, le système de types de \langname en
distinguant les types des pointeurs contrôlés par l'utilisateur des pointeurs
contrôlés par le noyau. Puisqu'on veut interdire le déréférencement des premiers
par l'opérateur \texttt{*}, on modifie également le typage de celui-ci.

Enfin, une fois ces modifications faites, on prouve enfin que les propriétés de
progrès et de préservation sont rétablies.

\section{Extensions noyau pour \langname}
\label{sec:extensions-noyau}

On ajoute à \langname la notion de valeur provenant de l'espace utilisateur.
Pour marquer la séparation entre les deux espaces d'adressage, on ajoute une
construction $φ \gramisa \vTainted{φ'}$. Le chemin interne $φ'$ correspond à une
variable classique (un pointeur noyau) qui, vu sous la forme $\vTainted{φ'}$,
est un pointeur utilisateur.

En plus du déréférencement par \texttt{*} qui devra donc renvoyer
$\serr{taint}$ pour les valeurs de la forme $\vTainted{φ'}$), il faut aussi
ajouter des constructions de lecture et d'écriture à travers les pointeurs
utilisateurs. Ceci sera fait sous forme de deux fonctions, $\cfuF$ et $\ctuF$.
Celles-ci prennent deux pointeurs en paramètre et renvoient un booléen indiquant
si la copie pu être faite (si le paramètre contrôlé par l'utilisateur pointe en
espace noyau, les fonctions ne font pas la copie et signalent l'erreur).

Illustrons ceci par un exemple. Imaginons un appel système fictif qui renvoie la
version du noyau, en remplissant par pointeur une structure contenant les champs
entiers \texttt{major}, \texttt{minor} et \texttt{patch}. Celui-ci peut être
alors écrit de la manière suivante :

\begin{align*}
  & \mathrm{sys\_getver} = \mathrm{fun}(p) \{                      &             & & \\
  & \indent \uPut{ 3}{p.\texttt{major}_S} ; & \mathrm{où} & & S = \{~& \texttt{major} : \tInt ; \\
  & \indent \uPut{14}{p.\texttt{minor}_S} ; &             & &        & \texttt{minor} : \tInt ; \\
  & \indent \uPut{15}{p.\texttt{patch}_S}   &             & &        & \texttt{patch} : \tInt   \\
  & \}                                      &             & &     \}
\end{align*}

% TODO faire par pointeur

On commence donc par ajouter aux instructions des constructions $\phxx{\uPut}$
et $\phxx{\uGet}$ de copie sûre. Afin de leur donner une sémantique, il faut
étendre l'ensemble des valeurs pointeur $φ$ aux constructions de la forme
$\vTainted{φ'}$. Pour créer des termes s'évaluant en de telles valeurs, il faut
une construction syntaxique $\eTaint{e}$ telle que si $e$ s'évalue en $φ$,
$\eTaint{e}$ s'évalue en $\vTainted{φ}$. Cela correspond à 2 ajouts : d'une
part, un nouveau contexte d'évaluation $\eTaint{\ctxEmpty}$ et une règle
d'évaluation. Enfin, on ajoute une nouvelle erreur $\serr{taint}$ à déclencher
lorsqu'on déréférence directement un pointeur utilisateur. Ces étapes sont
résumées dans la figure~\ref{fig:qualif-changes}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Expressions}{e}
  { … }{}
  { \eTaint{e} }{Expression souillée} % TODO ce serait pas un ajout à lv?
  {END}
\\
\gramdef{Contextes}{C}
  { … }{}
  { \eTaint{C}}{}
  {END}
\\
\gramdef{Chemins}{φ}
  { … }{}
  { \vTainted{φ} }{Valeur souillée}
  {END}
\\
\gramdef{Erreurs}{Ω}
  { … }{}
  { \serr{taint} }{Erreur de souillure}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateurs}
\label{fig:qualif-changes}
% TODO définir les états et ms

\end{figure}%}}}

\section{Extensions sémantiques}

En ce qui concerne l'évaluation des expressions $\phx\eTaint$, on ajoute la
règle suivante :

\begin{mathpar}
  \irule{Expr-Tainted}
    { }
    { \mm{m}{\eTaint{φ}}{m}{\vTainted{φ}} }
\end{mathpar}

Ensuite, il est nécessaire d'adapter les règles d'accès à la mémoire pour
déclencher une erreur $\serr{taint}$ en cas de déréférencement d'un pointeur
utilisateur. Les accès mémoire en lecture proviennent de la règle
\textsc{Exp-Lv} et ceux en lecture, de la règle \textsc{Exp-Set}, rappellées
ici :

\begin{mathpar}
  \semrule{Exp-Lv}

  \semrule{Exp-Set}
\end{mathpar}

Les accès à la mémoire sont en effet faits par le biais de la lentille $Φ$. Il
suffit donc d'adapter la définition~\ref{def:acces-phi} de celle-ci en rajoutant
le cas :

\begin{align*}
Φ(\vTainted{φ}) &= \serr{taint}
\end{align*}

Enfin, il est nécessaire de donner une sémantique aux fonctions $\cfuF$ et
$\ctuF$. L'idée est que celles-ci testent dynamiquement la
*valeur* du paramètre contrôlé par l'utilisateur afin de vérifier que celui-ci
pointe vers l'espace utilisateur (c'est-à-dire, qu'il est da la forme
$\vTainted{φ}$.

Deux cas peuvent se produire. Si ce test est positif, alors la copie est faite
et l'opération de copie retourne la valeur entière $1$. Dans le cas contraire,
aucune copie n'est faite et la valeur $0$ est retournée.

% TODO leur sémantique

\begin{mathpar}
  \irule{User-Get}
    { }
    { \mms{ \uGet{φ}{\vTainted{φ'}} }
          { φ ← φ'}
    }

  \irule{User-Put}
    { }
    { \mms{ \uPut{v}{\vTainted{φ}} }
          {φ ← v}
    }
\end{mathpar}

% TODO vérifier

% TODO et dans le cas d'un chose kernel?

Puisque ces règles ne s'appliquent qu'aux cas où les expressions à gauche et à
droite des opérateurs sont déjà évaluées, il faut également étendre les
contextes d'évaluation (figure~\ref{fig:qualif-changes}). Encore une fois on
évalue d'abord l'argument de gauche, puis l'argument de droite.

\section{Insuffisance des types simples}

Étant donné \langname augmenté de cette extension sémantique, on peut étendre
trivialement le système de types avec la règle suivante :

\begin{mathpar}
  \irule{Taint-Ignore}
    { Γ ⊢ e : t* }
    { Γ ⊢ \eTaint{e} : t* }
\end{mathpar}

Cette règle est compatible avec l'extension, sauf qu'elle introduit des termes
qui sont bien typables mais dont l'évaluation provoque une erreur autre que
$\serr{div}$, $\serr{array}$ ou $\serr{ptr}$, violant ainsi le
théorème~\ref{thm:progres}.

Par exemple, supposons que $x$ soit une variable globale entière, et posons :

\[
\begin{cases}
  e = * \eTaint {\& x} \\
  Γ = x : \tInt \\
  m = ([[x↦0]], [~]) \\
\end{cases}
\]

% TODO notation des littéraux stack frame / mémoire?

Les hypothèses du théorème de progrès sont bien vérifiées, mais cependant la
conclusion n'est pas vraie :

\begin{itemize}
  \item
    On a bien $\mcomp{Γ}{m}$.

    % TODO dérivation?

  \item
    $e$ est bien typée sous $Γ$ :

      \begin{mathpar}
        \irule{Lv-Deref}
          {
            \irule{Taint-Ignore}
              {
                \irule{Lv-Deref}
                  {
                    \irule{Lv-Var}
                      { x:\tInt ∈ Γ }
                      { Γ ⊢ x : \tInt }
                  }
                  { Γ ⊢ \& x : \tInt*}
              }
              { Γ ⊢ \eTaint {\& x} : \tInt*}
          }
          { Γ ⊢ * \eTaint {\& x} : \tInt}
      \end{mathpar}

  \item 
    L'évaluation de $e$ sous $m$ provoque une erreur différente de
    $\serr{div}$, $\serr{array}$, ou $\serr{ptr}$ :

      \begin{mathpar}
      \inferrule*
        {
          \irule{Exp-Lv}
            {
              \inferrule*
                { }
                {m[*\vTainted{x}] = \serr{taint}}
            }
            { \mm{m}{* \eTaint {\& x}}{m}{\serr{taint}} }
          \\
          \irule{Eval-Err}
            { }
            {
              \msi{m}{\serr{taint}} → \serr{taint}
            }
        }
        {\msi{m}{e} → \serr{taint}}
      \end{mathpar}

\end{itemize}

Cela montre que le typage n'apporte plus de garantie de sûreté sur l'exécution :
le système de types naïvement étendu par une règle comme
\textsc{Taint-Ignore} n'est pas en adéquation avec les extensions présentées
dans la section~\ref{sec:extensions-noyau}.

\section{Extensions du système de types}
\label{sec:extension-types}

On présente ici un système de types plus expressif permettant de capturer les
extensions de sémantique. \emph{In fine}, cela permettra de prouver le
théorème~\ref{thm:progres-qual} qui est l'équivalent du
théorème~\ref{thm:progres} mais pour le nouveau jugement de typage.

Définir un nouveau système de types revient à étendre le jugement de typage
$\cdot ⊢ \cdot : \cdot$, en modifiant certaines règles et en en modifiant
d'autres. Naturellement, la plupart des différences porteront sur le traitement
des pointeurs.

\subsection*{Pointeurs utilisateurs}

Le changement clef est l'ajout de \emph{pointeurs utilisateurs}. En plus des
types pointeurs $\ptrK{t}$, on ajoute des types pointeurs $\ptrU{t}$. La
différence entre les deux représente \emph{qui} contrôle leur valeur
(section~\ref{sec:secu-syscalls}).

Les différences sont les suivantes :

\begin{itemize}

\item Les types ``$\ptrK{t}$'' s'appliquent aux pointeurs contrôlés par le
noyau. Par exemple, prendre l'adresse d'un objet de la pile noyau donne un
pointeur noyau.

\item Les types ``$\ptrU{t}$'', quant à eux, s'appliquent aux pointeurs qui
proviennent de l'espace utilisateur. Ces pointeurs proviennent toujours
d'interfaces particulières, comme les appels système ou les paramètres de la
fonction \texttt{ioctl}.

\end{itemize}

Cet ajout est précisé dans la figure~\ref{fig:qualif-changes-typ}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Types}{t}
  { … }{}
  { \ptrU{t} }{Pointeur utilisateur}
  {END}
\end{align*}

\caption{Changements liés aux qualificateurs de types}
\label{fig:qualif-changes-typ}
\end{figure}%}}}

Puisqu'on s'intéresse à la provenance des pointeurs, détaillons les règles qui
créent, manipulent et utilisent des pointeurs.

\subsection*{Sources de pointeurs}

La source principale de pointeurs est l'opérateur $\&$ qui prend l'adresse d'une
variable. Celle-ci est bien entendue contrôlée par le noyau (dans le sens où son
déréférencement est toujours sûr). Cette construction crée donc des pointeurs
noyau :

\begin{mathpar}
  \irule{AddrOf-Kernel}
    { Γ ⊢ lv : t }
    { Γ ⊢ \& lv : \ptrK{t} }
\end{mathpar}

\subsection*{Manipulations de pointeurs}

L'avantage du typage est que celui ci suit le flot de données : si à un endroit
une valeur de type $t$ est affectée à une variable, que le contenu de cette
variable est placé puis retiré d'une structure de données, il conserve ce type
$t$. En particulier un pointeur utilisateur reste un pointeur utilisateur.

Une seule règle concernant les pointeurs les manipule en consommant un pointeur
et en en retournant un, et concerne l'arithmétique des pointeurs. On l'étend aux
pointeurs qualifiés, puisqu'elle est possible quelque soit le qualificateur (et
le préserve) :

\begin{mathpar}
  \irule{Ptr-Arith-User}
     { \opbin ∈ \{ +_p, -_p \} \\
       Γ ⊢ e_1 : \ptrU{t} \\
       Γ ⊢ e_2 : \tInt \\
     }
     { Γ ⊢ e_1~\opbin~e_2 : \ptrU{t} }
\end{mathpar}

\subsection*{Utilisations de pointeurs}

La principale restriction, au cœur de ce chapitre et de cette thèse, est que
seuls les pointeurs noyau peuvent être déréférencés de manière sûre. La règle
suivante remplace donc \textsc{Lv-Deref} :

\begin{mathpar}
\irule{Lv-Deref-Kernel}{
  Γ ⊢ e : \ptrK{t}
}{
  Γ ⊢ *e : t
}
\end{mathpar}

Ainsi, on interdit le déréférencement des expressions de type $\ptrU{t}$ à la
compilation.

% TODO mettre ça dans rules.tex

% TODO définir les stubs

L'opérateur $\eTaint{\cdot}$ transforme un pointeur selon la règle suivante :

\begin{mathpar}
\irule{Taint}
  { Γ ⊢ e : \ptrK{t} }
  { Γ ⊢ \eTaint{e} : \ptrU{t} } % TODO e ou lv?
\end{mathpar}

Les opérateurs $\phxx\uGet$ et $\phxx\uPut$ sont typés de la manière suivante :

\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}

Il est à noter qu'il n'y a pas de sous-typage : les pointeurs noyau ne peuvent
être utilisés qu'en tant que pointeurs noyau, et les pointeurs utilisateurs
qu'en tant que pointeurs utilisateurs.

% TODO check

\section{Sûreté du typage}

\subsection*{Typage sémantique}

La définition du typage sémantique doit aussi être étendue au cas $φ =
\vTainted{φ'}$. Les références mémoires sont ``nettoyées'' pour accéder à la
left-value encapsulée.

\begin{mathpar}
  \irule{S-Tainted}
    { m ⊧           φ'  : \ptrK{t} }
    { m ⊧ \vTainted{φ'} : \ptrU{t} }
\end{mathpar}

\subsection*{Progrès et préservation}

Le déréférencement d'un pointeur dont la valeur est contrôlée par l'utilisateur
ne peut se faire qu'à travers une fonction qui vérifie la sûreté de celui-ci.

\begin{theorem}[Progrès pour les types qualifiés]
  \label{thm:progres-qual}

  Supposons que $Γ ⊢ e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai :

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mcomp{Γ}{m'} ∧ \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}
\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:progres-qualif}.

Et nous donnons un équivalent du théorème~\ref{thm:preservation}.

\begin{theorem}[Préservation pour les types qualifiés]
  \label{thm:preservation-qualif}

  Si une expression est typable et que son évaluation produit une valeur, alors
  cette valeur est du même type que l'expression.

  Si $Γ ⊢ e : t$ et $e → v$ % TODO

  alors $Γ ⊢ v : t$.

\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:preservation-qualif}.

La sûreté du typage étant à nouveau établie, on a montré que les qualificateurs
de types sur les pointeurs suffisent pour avoir une adéquation entre les
extensions de sémantique de la section~\ref{sec:extensions-noyau} et les
extensions du système de type de la section~\ref{sec:extension-types}.

% vim: spelllang=fr
