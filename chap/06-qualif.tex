Nous présentons ici deux extensions du système de types décrit dans le
chapitre~\ref{cha:typbase}. Celles-ci permettent de capturer deux classes
d'erreurs de programmation concernant respectivement les entiers et les
pointeurs. Plus précisément, la première permet de distinguer plusieurs
utilisations de types entiers, selon s'ils sont utilisés comme entiers
arithmétiques ou ensemble de bits; la seconde, dans le contexte de systèmes
d'exploitation, introduit une différence entre les pointeurs dont la valeur est
contrôlée par l'utilisateur et les autres.

\section{Analyse de bitmasks}

\def\tBits{\textsc{Bits}\xspace}
\def\tChar{\textsc{Char}\xspace}

Dans le langage C, les types de données décrivent uniquement l'agencement en
mémoire des valeurs. Elles n'ont pas de portée plus sémantique permettant
d'exprimer ce que celles-ci représentent. Par exemple, dans un programme
manipulant des dates, on sera amené à manipuler des numéros de mois et d'années,
représentés par des types entiers. Le langage C permet de définir des nouveaux
types:

\begin{verbatim}
typedef int month_t;
typedef int year_t;
\end{verbatim}

Cependant, rien ne distingue le nouveau type de l'ancien. Il ne s'agit que d'une
aide à la documentation. Dans cet exemple, \texttt{month\_t} et \texttt{year\_t}
sont tous les deux des nouveaux noms pour le type \texttt{int}, donc ils sont en
fait compatibles. Le compilateur ne peut donc pas détecter qu'on utilise un
numéro de mois là où un numéro d'année était attendu (ou \emph{vice versa}).

Cet idiome est commun en C. On manipule notamment certaines données abstraites
par des clés entières, et un \texttt{typedef} particulier permet de désigner
celles-ci. Par exemple sous Linux, les numéros de processus sont des indices
dans la table de processus interne au noyau, et on y accède par une valeur de
type \texttt{pid\_t}. De même, les utilisateurs sont représentés par un nombre
entier du type \texttt{uid\_t}.

Un autre idiome est répandu: l'utilisation d'entiers comme représentation d'un
ensemble de booléens. En effet, un nombre $a = \sum_{i=0}^{N-1} a_i 2^i$ peut
s'interpréter comme l'ensemble de ses bits égaux à 1: $\{ i ∈ [0;N-1] / a_i = 1
\}$. Un entier de 32 bits peut par exemple représenter une combinaison de 32
options indépendantes.

\begin{figure}
    \insertcode{unix-open.c}
    \caption{Interface permettant d'ouvrir un fichier sous Unix}
    \label{fig:unix-open}
\end{figure}

C'est de cette manière que fonctionne l'interface qui permet d'ouvrir un fichier
sous Unix (figure~\ref{fig:unix-open}). Le paramètre \texttt{flags} est un
entier qui encode les options liées à l'ouverture du fichier. On précise son
mode (lecture, écriture ou les deux) par les bits 1 et 2, s'il faut créer le
fichier ou non s'il n'existe pas par le bit 7, si dans ce cas il doit être
effacé par le bit 8, etc. On obtient le paramètre complet en réalisant un
\enquote{ou} bit à bit entre des constantes. Le paramètre \texttt{mode} (en fait
un \emph{unsigned int}) encode de la même manière les permissions que doit avoir
le fichier créé, le cas échéant.

Ces fonctions retournent un entier, qui est un \emph{descripteur de fichier}. Il
correspond à un indice numérique dans une table interne au processus. Par
exemple, $0$ désigne son entrée standard, $1$ sa sortie standard, et $2$ son
flux d'erreur standard.

On identifie donc au moins trois utilisations du type \texttt{int}:

\begin{itemize}
    \item entier: c'est l'utilisation classique pour représenter des valeurs
        numériques. Toutes les opérations sont possibles.
    \item bitmask: on utilise un entier comme ensemble de bits. Seules les
        opérations bit à bit ont du sens.
    \item entier opaque: on utilise un entier de manière purement abstraite.
        C'est l'exemple des descripteurs de fichier.
\end{itemize}

Ces utilisations du type n'ont rien à voir ; il faudrait donc empêcher
d'utiliser un descripteur de fichier comme un mode, et vice-versa. De même,
aucun opérateur n'a de sens sur les descripteurs de fichier, mais l'opérateur
\texttt{\textbar{}} du \enquote{ou} bit à bit doit rester possible pour les
modes.

On décrit ici une technique de typage pour détecter et interdire ces mauvaises
utilisations en proposant une version \enquote{bien typée} de la fonction
\texttt{open}. Plus précisément, on donne à ses deuxième et troisième arguments
(respectivement \texttt{flags} et \texttt{mode}) le nouveau type \tBits qui
correspond aux entiers utilisés comme bitmasks. Le type de retour n'est pas
modifié (il reste \tInt), mais on décrit comment il est possible de rendre ce
type opaque.

\subsection{Modifications}

\begin{figure}

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \tChar }{Caractère}
  { \tBits }{Entier utilisé comme \emph{bitmask}}
  {END}
\end{align*}

\[
  \irule{Comp-Bits}
    { }
    { \tComp{\tInt}{\tBits} }
\]

\caption{Ajouts liés aux entiers utilisés comme bitmasks}

\label{fig:ajouts-bitmasks}

\end{figure}

\begin{figure}

\begin{align*}
    [~] ⊢ \texttt{O\_RDONLY} &: \tBits \\
    [~] ⊢ \texttt{O\_RDWR}   &: \tBits \\
    [~] ⊢ \texttt{O\_APPEND} &: \tBits \\
    \\
    [~] ⊢ \texttt{open} &: (\tChar~*, \tBits) → \tInt
\end{align*}

\caption{Nouvelles valeurs liées aux bitmasks}
\label{fig:bitmasks-types}

\end{figure}

On commence par ajouter deux types: d'une part \tBits bien sûr, mais également
\tChar qui apparaît dans les chaînes de caractères. On ne spécifie pas plus ce
dernier mais on suppose qu'il existe des littéraux de chaînes qui retournent un
pointeur vers le premier élément d'un tableaux de caractères. Au niveau des
valeurs, les entiers utilisés comme bitmasks sont représentés par des valeurs
entières classiques $\widehat{n}$. En particulier, on n'ajoute pas de nouveau
type sémantique, mais on ajoute une règle de compatibilité entre le type de
valeurs \tInt et le type statique \tBits (figure~\ref{fig:ajouts-bitmasks}). Par
ailleurs, on change le type des \enquote{constructeurs} (\texttt{O\_*}) et du
\enquote{consommateur} \texttt{open} (figure~\ref{fig:bitmasks-types}).

Pour que les opérations bit à bit puissent s'appliquer aux bitmasks, on remplace
aux règles s'appliquant à $\tInt$ les règles suivantes.

\begin{mathpar}
    \irule{Op-Bits}
        { \opbin ∈ \{~|~, ~\&~, ~\opxor~ \}
       \\ Γ ⊢ e_1 : \tBits
       \\ Γ ⊢ e_2 : \tBits
       }{ Γ ⊢ e_1~\opbin~e_2 : \tBits
       }

    \irule{Not-Bits}
        { Γ ⊢ e : \tBits }
        { Γ ⊢ \sim e : \tBits }
\end{mathpar}

Il reste à permettre d'utiliser les bitmasks dans les contextes où on attend un
entier. Par exemple, pour écrire $\iIf{x~\&~\hexa{80}}{…}{…}$ (test du bit
numéro 7). On veut donc exprimer que \enquote{un \tBits est un \tInt}. Cette
relation entre différents types d'entier correspond à du sous-typage. La méthode
classique consiste à introduire une relation explicite $⊆$ et la règle suivante.

\badrulewarn{
    \irule{Sub}
    { Γ ⊢ e : s
        \\ s ⊆ t
    }
    { Γ ⊢ e : t }
}

Au contraire, on ajoute seulement la règle suivante. Elle permet d'utiliser une
expression de type $\tBits$ là où une expression de type $\tInt$ est attendue
\footnote{
    Cela modifie légèrement l'implantation de l'inférence de types. Le type
    d'une expression utilisée comme opérande de l'opérateur $+$ n'est donc pas
    \emph{a priori} de type \tInt, mais \tBits ou \tInt.
}.

\begin{mathpar}
    \irule{Sub-BitsInt}
        { Γ ⊢ e : \tBits }
        { Γ ⊢ e : \tInt }
\end{mathpar}

Ainsi, si $Γ ⊢ e : \tBits$, on a par exemple $Γ ⊢ ~!~e : \tInt$.

% Alternative
%
% ----------------------------------------------
% ! : s'applique à bits ou int mais retourne int
% ----------------------------------------------

\subsection{Exemple: $!~x~\&~y$}

% - !E1 & E2
% + !(E1 & E2)

Les nombreux opérateurs de C (repris en \langname) posent plusieurs problèmes:

\begin{itemize}
\item il sont nombreux et il est facile de confondre $\&\&$ avec $\&$, ou
      $!$ avec $\sim$;
\item il y a un opérateur \enquote{ou exclusif} bit à bit ($\opxor$) mais pas
      d'équivalent logique;
\item la priorité des opérateurs semble parfois arbitraire. Par exemple, les
      opérateurs de décalage sont plus prioritaires que les additions, donc
      $x \ll 2 + 1$ est interprété comme $(x \ll 2) + 1$.
\end{itemize}

Le premier et le dernier point permettent d'expliquer une erreur courante: celle
qui consiste à écrire $!~x~\&~y$ au lieu de $!~(x~\&~y)$.

En effet, la première expression est équivalente à $(!~x)~\&~y$. Comme $!~x$
vaut $0$ ou $1$, l'expression resultante vaut $y~\&~1$ si $x = 0$, ou $0$ sinon.
Il s'agit probablement d'une erreur de programmation. L'alternative $!~(x~\&~y)$
a plus de sens: elle vaut $0$ si $x$ et $y$ ont un bit en commun, $1$ sinon.

\begin{figure}
\begin{mathpar}
    Γ = ([x ↦ \tBits, y ↦ \tBits], [~])

    \irule{Unop-Not}
        {
            \irule{Sub-BitsInt}
                {
                    \irule{Op-Bits}
                        { Γ ⊢ x : \tBits
                       \\ Γ ⊢ y : \tBits
                        }
                        {Γ ⊢ x~\&~y : \tBits}
                }
                {Γ ⊢ x~\&~y : \tInt}
        }
        {Γ ⊢~!~(x~\&~y) : \tInt}
\end{mathpar}

\caption{Dérivation montrant que $!~(x~\&~y)$ est bien typée}
\label{fig:notxy-ok}
\end{figure}

On se propose donc de vérifier que la première n'est pas bien typée alors que la
seconde l'est. Dans les deux cas suivants on se placer dans un environnement $Γ$
comportant deux variables globales $x$ et $y$ de type $\tBits$. Alors $(!~x) \&
y$ n'est pas bien typée. En effet, $Γ ⊢~!~x : \tInt$ et la seule règle qui
s'applique à l'opérateur $\&$ ne peut pas s'appliquer. En revanche la seconde
est bien typée (figure~\ref{fig:notxy-ok}).

%{{{

%\paragraph{Remarque}

%Cette règle pose problème pour l'inférence, car partant d'une expression de la
%forme $e_1~|~e_2$ on ne sait pas quelle règle appliquer: celle qui porte sur
%\tInt ou celle sur \tBits. Concrètement, cela veut dire qu'on ne peut pas
%inférer de type pour la fonction $\eFun{x, y}{\iReturn{x~|~y}}$. En revanche, si
%on annote le type de $x$ ou de $y$, le reste peut être inféré.

%\paragraph{Polymorphisme restreint}

%Aussi appelé \emph{bounded polymorphism}, il permet de contraindre les variables
%de type généralisées. Cela permet de donner à la fonction précédente un type
%comme:

%\[
    %∀a. (a ∈ \{ \tInt, \tBits \}) ⇒ (a, a) → a
%\]

%Cela implique de modifier le système de type pour associer aux expression non
%pas des types, mais des schémas de type (incluant des variables quantifiées). On
%généralise les variables de certaines déclarations (les globales, par exemple),
%et à l'utilisation il faut instancier les schémas, c'est-à-dire substituer aux
%variables quantifiées des paramètres concrets. Ceci présente plusieurs
%désavantages:

%\begin{itemize}
    %\item la présentation du système de types est alourdie;
    %\item l'inférence est plus complexe;
    %\item si on autorise le polymorphisme non restreint (en donnant par exemple
        %à la fonction identité le type $∀a. (a) → a$), il faut à l'exécution
        %représenter les données de manière uniforme, ce qui revient à changer
        %la sémantique du langage.
%\end{itemize}

%\clearpage

%\subsubsection*{Transtypage}

%\begin{align*}
%\gramdef{Expression}{e}
  %{ … }{}
  %{e \angle t}{Transtypage}
  %{END}
%\\
%\\
%\gramdef{Contexte d'évaluation}{C}
  %{ … }{}
  %{ C \angle t}{ }
  %{END}
%\end{align*}

%\begin{mathpar}
    %\irule{E-Coerce}
        %{ }
        %{
            %\mms{(v \angle t)}{v}
        %}

    %\irule{T-Coerce}
        %{ Γ ⊢ e : t
       %\\ \tComp{τ}{t}
       %\\ \tComp{τ}{t'}
        %}
        %{ Γ ⊢ (e \angle t') : t'
        %}
%\end{mathpar}

%% TODO comment adapter FD

%}}}

% TODO Ne marche pas:
%if (!(getuid() & geteuid() == 0)) {
%https://www.securecoding.cert.org/confluence/display/seccode/EXP17-C.+Do+not+perform+bitwise+operations+in+conditional+expressions

\section{Analyse de provenance de pointeurs}

Jusqu'ici \langname{} est un langage impératif généraliste, ne prenant pas en
compte les spécificités de l'adressage utilisé dans les systèmes d'exploitation.

Dans ce chapitre, on commence par l'étendre en ajoutant des constructions
modélisant les variables présentes dans l'espace utilisateur (cf.
chapitre~\ref{cha:os}). Pour accéder à celles-ci, on ajoute un opérateur de
déréférencement sûr qui vérifie à l'exécution que l'invariant suivant est
respecté:

\begin{quote}
Les pointeurs dont la valeur est contrôlée par l'utilisateur pointent vers
l'espace utilisateur.
\end{quote}

La terminologie mérite d'être détaillée:

Un pointeur contrôlé par l'utilisateur, ou \emph{pointeur utilisateur}, est une
référence mémoire dont la valeur est modifiable par le code utilisateur (opposé
au code noyau, que nous analysons ici). Ceci correspond à des données provenant
de l'extérieur du système vérifié. C'est une propriété statique, qui peut être
déterminée à la compilation à partir de considérations syntaxiques. Par exemple,
l'adresse d'une variable locale au sein de code noyau est toujours considérée
comme étant contrôlée par le noyau.

Un pointeur pointant vers l'espace utilisateur fait référence à une variable
allouée en espace utilisateur. Cela veut dire qu'y accéder ne risque pas de
mettre en péril l'isolation du noyau en faisant fuiter des informations
confidentielles ou en déjouant son intégrité. Cette propriété est dynamique: un
pointeur utilisateur peut \emph{a priori} pointer vers l'espace utilisateur, ou
non.

Pour prouver que cette approche est bien fondée, on procède en plusieurs étapes.

Tout d'abord, on définit une nouvelle erreur $\serr{sec}$ (pour
\enquote{sécurité}), déclenchée lorsqu'un pointeur contrôlé par l'utilisateur et
pointant vers le noyau est déréférencé (le cas que l'on cherche à éviter). Il
est important de noter que ce cas d'erreur est \enquote{virtuel}, c'est-à-dire
qu'on l'ajoute à la sémantique pour pouvoir le détecter facilement comme un cas
d'erreur, mais dans une sémantique de plus bas niveau, l'erreur ne serait pas
déclenchée, comme en C. D'un point de vue opérationnel, cela équivaut à ajouter
un test dynamique à chaque déréférencement, ce qui est sûr mais se paye en
performances. Ajouter ce cas d'erreur virtuel dans la sémantique d'évaluation
permet de transformer un problème de sécurité (empêcher les fuites
d'information) en problème de sûreté (empêcher les erreurs à l'exécution).

Ensuite, on montre qu'avec cet ajout, si on étend naïvement le système de types
en donnant le même type aux pointeurs contrôlés par l'utilisateur et le noyau,
le théorème de progrès (\ref{thm:progres}) n'est plus valable. Cela signifie que
le système de type classique présenté dans le chapitre~\ref{cha:typbase} ne
suffit pas à capturer les propriétés de sécurité que nous voulons interdire.

L'étape suivante est d'étendre, à son tour, le système de types de \langname{}
en distinguant les types des pointeurs contrôlés par l'utilisateur des pointeurs
contrôlés par le noyau. Puisqu'on veut interdire le déréférencement des premiers
par l'opérateur \texttt{*}, on modifie également le typage de celui-ci.

Enfin, une fois ces modifications faites, on prouve que les propriétés de
progrès et de préservation sont rétablies.

\subsection{Extensions noyau pour \langname}
\label{sec:extensions-noyau}

On ajoute à \langname{} la notion de valeur provenant de l'espace utilisateur.
Pour marquer la séparation entre les deux espaces d'adressage, on ajoute une
construction $φ \gramisa \vTainted{φ'}$. Le chemin interne $φ'$ désigne une
variable classique (un pointeur noyau) et l'opérateur $\phx\vTainted$ permet de
l'interpréter comme un pointeur vers l'espace utilisateur. En quelque sorte, on
ne classifie pas les valeurs selon la variable pointée mais selon la
construction du pointeur.

Remarquons qu'on n'introduit pas de sous-typage: les pointeurs noyau ne peuvent
être utilisés qu'en tant que pointeurs noyau, et les pointeurs utilisateurs
qu'en tant que pointeurs utilisateurs.

En plus du déréférencement par \texttt{*} (qui devra donc renvoyer
$\serr{sec}$ pour les valeurs de la forme $\vTainted{φ'}$), il faut aussi
ajouter des constructions de lecture et d'écriture à travers les pointeurs
utilisateurs. Ceci sera fait sous forme de deux fonctions, $\cfuF$ et \linebreak
$\ctuF$. Celles-ci prennent deux pointeurs en paramètre et renvoient un booléen
indiquant si la copie a pu être faite (si le paramètre contrôlé par
l'utilisateur pointe en espace noyau, les fonctions ne font pas la copie et
signalent l'erreur).

Illustrons ceci par un exemple. Imaginons un appel système fictif qui renvoie la
version du noyau, en remplissant par pointeur une structure contenant les champs
entiers \texttt{major}, \texttt{minor} et \texttt{patch} (un équivalent dans
Linux est l'appel système \verb!uname()!). Celui-ci peut être alors écrit
comme dans la figure~\ref{fig:ex-sys-getver}. Une fois la structure noyau $v$
remplie, il faut la copier vers l'espace utilisateur. La fonction $\ctuF$ va
réaliser cette copie (de la même manière qu'avec un \verb!memcpy()!), mais
après avoir testé dynamiquement que $p$ pointe en espace utilisateur (dans le
cas contraire, la copie n'est pas faite).

\begin{figure}[h]
\setlength{\parindent}{1cm}
\begin{align*}
  & \mathrm{sys\_getver} = \mathrm{fun}(p) \{ \\
  & \indent \textsc{Decl}~v= \{~\texttt{major} : 3
                              ; \texttt{minor} : 14
                              ; \texttt{patch} : 15~\}~\textsc{in} \\
  & \indent \uPut{p}{\& v} \\
  & \}
\end{align*}

\caption{Implantation d'un appel système qui remplit une structure par pointeur}
\label{fig:ex-sys-getver}
\end{figure}

On peut remarquer que, contrairement aux fonctions présentes dans le noyau
Linux, les fonctions $\cfuF$ et $\ctuF$ n'ont pas de paramètre indiquant la
taille à copier. Cela est dû au fait que le modèle mémoire de \langname{} est de
plus haut niveau. L'information de taille est déjà présente dans chaque valeur.

Une autre remarque à faire est qu'il n'y a pas de manière de copier des données
de l'espace utilisateur vers l'espace utilisateur. Il est nécessaire de passer
par l'espace noyau. La raison est que, puisqu'il faut réaliser deux tests
dynamiques, les erreurs peuvent arriver à ces deux endroits. Plutôt que de
proposer un opérateur qui réalise cette copie, on laisse le programmeur faire
les deux copies manuellement.

On commence donc par ajouter aux instructions des constructions $\phxx{\uPut}$
et $\phxx{\uGet}$ de copie sûre. Afin de leur donner une sémantique, il faut
étendre l'ensemble des valeurs pointeur $φ$ aux constructions de la forme
$\vTainted{φ'}$. Pour créer des termes s'évaluant en de telles valeurs, il faut
une construction syntaxique $\eTaint{e}$ telle que, si $e$ s'évalue en $\wphi{φ}$,
$\eTaint{e}$ s'évalue en $\wphi{\vTainted{φ}$}. Cela correspond à 2 ajouts: un
nouveau contexte d'évaluation $\eTaint{C}$ et une règle d'évaluation.
Enfin, on ajoute une nouvelle erreur $\serr{sec}$ à déclencher lorsqu'on
déréférence directement un pointeur utilisateur. Ces étapes sont résumées dans
la figure~\ref{fig:qualif-changes}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Expressions}{e}
  { … }{}
  { \eTaint{lv} }{Adresse utilisateur}
  { \uGet{e_d}{e_s} }{Lecture depuis l'espace utilisateur}
  { \uPut{e_d}{e_s} }{Écriture vers l'espace utilisateur}
  {END}
\\
\\
\gramdef{Contextes}{C}
  { … }{}
  { \eTaint{C}}{}
  { \uGet{C}{e} }{}
  { \uGet{v}{C} }{}
  { \uPut{C}{e} }{}
  { \uPut{v}{C} }{}
  {END}
\\
\\
\gramdef{Chemins}{φ}
  { … }{}
  { \vTainted{φ} }{Pointeur utilisateur}
  {END}
\\
\\
\gramdef{Erreurs}{Ω}
  { … }{}
  { \serr{sec} }{Erreur de sécurité}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateurs (par rapport à l'interprète du
chapitre~\ref{cha:lang})}

\label{fig:qualif-changes}

\end{figure}%}}}

En résumé, on a deux constructions pour créer des pointeurs à partir d'une
valeur gauche: $\&~\cdot$ crée un pointeur noyau, et $\eTaint{\cdot}$ crée un
pointeur utilisateur. Seule la première est faite pour être utilisée dans le
code à analyser. La seconde sert uniquement à modéliser les points d'entrée du
noyau. Par exemple, la fonction $\mathrm{sys\_getver}$ de la
figure~\ref{fig:ex-sys-getver} peut être appelée par un utilisateur de la
manière suivante:

{
\setlength{\parindent}{1cm}
\begin{align*}
  & \indent \textsc{Decl}~v= \{~\texttt{major} : 0
                              ; \texttt{minor} : 0
                              ; \texttt{patch} : 0~\}~\textsc{in} \\
  & \indent \mathrm{sys\_getver} (\eTaint{v})
\end{align*}
}

\subsection{Extensions sémantiques}

En ce qui concerne l'évaluation des expressions $\phx\eTaint$, on ajoute la
règle suivante:

\[
  \semrule{Phi-User}
\]

Dans $\wphi{(\vTainted{φ})}$, l'opérateur $\phx\wphi$ indique que la valeur
créée est une référence mémoire. Cette référence mémoire, $\vTainted{φ}$, est
contrôlée par l'utilisateur. C'est ce qu'indique le constructeur $\phx\vTainted$

Ensuite, il est nécessaire d'adapter les règles d'accès à la mémoire pour
déclencher une erreur $\serr{sec}$ en cas de déréférencement d'un pointeur
utilisateur. Les accès mémoire en lecture proviennent de la règle
\textsc{Exp-Lv} et ceux en lecture, de la règle \textsc{Exp-Set}, rappellées
ici:

\begin{mathpar}
  \semrule{Exp-Lv}

  \semrule{Exp-Set}
\end{mathpar}

Les accès à la mémoire sont en effet faits par le biais de la lentille $Φ$. Il
suffit donc d'adapter sa définition (page~\pageref{subsec:acces-phi}) de
celle-ci en rajoutant les cas suivant:

\begin{align*}
    \lensGet{Φ}{\vTainted{φ}}    &= \serr{sec} \\
    \lensPut{Φ}{\vTainted{φ}}{v} &= \serr{sec}
\end{align*}

Enfin, il est nécessaire de donner une sémantique aux fonctions $\cfuF$ et
\linebreak $\ctuF$. L'idée est que celles-ci testent dynamiquement la
\emph{valeur} du paramètre \linebreak contrôlé par l'utilisateur afin de
vérifier que celui-ci pointe vers l'espace utilisateur (c'est-à-dire, qu'il est
de la forme $\vTainted{φ}$).

%TODO[PJ]: pourrait être des nop suivant la sémantique statique

Deux cas peuvent se produire. Soit la partie à vérifier a la forme
$\vTainted{φ'}$, soit non (et dans ce cas $∄φ', φ = \vTainted{φ'}$). Dans le
premier cas (règles \textsc{User-*-OK}), alors la copie est faite et l'opération
de copie retourne la valeur entière $0$. Dans le second (règles
\textsc{User-*-Err}), aucune copie n'est faite et la valeur $-1$ est retournée.
Ce comportement est calé celui des fonctions \texttt{copy\_\{from,to\}\_user} du
noyau Linux: en cas de succès elles renvoient $0$, et en cas d'erreur
\texttt{-EFAULT} ($= -14$).

\begin{mathpar}
  \semrule{User-Get-OK}

  \semrule{User-Get-Err}

  \semrule{User-Put-OK}

  \semrule{User-Put-Err}
\end{mathpar}

%TODO[PJ] copy* ne sont pas des fonctions mais des éléments de syntaxe

Ces règles sont à appliquer en priorité de la règle d'appel de fonction
classique, puisque ces fonctions n'ont pas de corps en tant que tel. En effet
celles-ci ne sont pas implantables directement en \langname, puisqu'il n'y a pas
par exemple d'opérateur permettant d'extraire $φ$ depuis une valeur
$\vTainted{φ}$. L'opération en \enquote{boîte noire} de ces deux fonctions
permet d'assurer que l'accès à l'espace utilisateur est toujours couplé à un
test dynamique.

\subsection{Insuffisance des types simples}

Étant donné \langname{} augmenté de cette extension sémantique, on peut étendre
naïvement le système de types avec la règle suivante:

\begin{mathpar}
  \irule{AddrOf-User-Ignore}
    { Γ ⊢ lv : t }
    { Γ ⊢ \eTaint{lv} : t~* }
\end{mathpar}

Cette règle est compatible avec l'extension, sauf qu'elle introduit des termes
qui sont bien typables mais dont l'évaluation provoque une erreur autre que
$\serr{div}$, $\serr{array}$ ou $\serr{ptr}$, violant ainsi le
théorème~\ref{thm:progres}. Posons:

\[
\begin{cases}
  e = * \eTaint{x} \\
  Γ = x : \tInt \\
  m = ([[x↦0]], [~]) \\
\end{cases}
\]

Les hypothèses du théorème de progrès sont bien vérifiées, mais cependant la
conclusion n'est pas vraie:

\begin{itemize}
  \item
    On a bien $\mcomp{Γ}{m}$. En effet:

    \begin{mathpar}
        \irule{M-Push}
            {
                \irule{M-Empty}
                    { }
                    { \mcomp{[~]}{([~], [~])} }
            \\
            [~] ⊧ 0 : \tInt
            \\
            \tComp{\tInt}{\tInt}
            }
            { \mcomp{x:\tInt}{([[x↦0]], [~])} }
    \end{mathpar}

  \item
    $e$ est bien typée sous $Γ$:

      \begin{mathpar}
        \irule{Lv-Deref}
          {
            \irule{AddrOf-User-Ignore}
              {
                \irule{Lv-Deref}
                  {
                    \irule{Lv-Var}
                      { x:\tInt ∈ Γ }
                      { Γ ⊢ x : \tInt }
                  }
                  { Γ ⊢ \& x : \tInt*}
              }
              { Γ ⊢ \eTaint{x} : \tInt*}
          }
          { Γ ⊢ * \eTaint {x} : \tInt}
      \end{mathpar}

  \item
    L'évaluation de $e$ sous $m$ provoque une erreur différente de
    $\serr{div}$, $\serr{array}$, ou $\serr{ptr}$:

      \begin{mathpar}
      \inferrule*
        {
          \irule{Exp-Lv}
            {
              \inferrule*
                { }
                {m[\vTainted{x}]_Φ = \serr{sec}}
            }
            { \mm{m}{* \eTaint {x}}{m}{\serr{sec}} }
          \\
          \irule{Eval-Err}
            { }
            {
              \msi{m}{\serr{sec}} → \serr{sec}
            }
        }
        {\msi{m}{e} → \serr{sec}}
      \end{mathpar}

\end{itemize}

Cela montre que le typage n'apporte plus de garantie de sûreté sur l'exécution:
le système de types naïvement étendu par une règle comme
\textsc{AddrOf-User-Ignore} n'est pas en adéquation avec les extensions présentées
dans la section~\ref{sec:extensions-noyau}. Il faut donc raffiner les règles de
typage pour interdire ce cas.

\subsection{Extensions du système de types}
\label{sec:extension-types}

On présente ici un système de types plus expressif permettant de capturer les
extensions de sémantique. \emph{In fine}, cela permettra de prouver le
théorème~\ref{thm:progres-qual} qui est l'équivalent du
théorème~\ref{thm:progres} mais pour le nouveau jugement de typage.

Définir un nouveau système de types revient à étendre le jugement de typage
$\cdot ⊢ \cdot : \cdot$, en modifiant certaines règles et en en ajoutant
d'autres. Naturellement, la plupart des différences porteront sur le traitement
des pointeurs.

\subsubsection*{Pointeurs utilisateurs}

Le changement clef est l'ajout de \emph{pointeurs utilisateur}. En plus des
types pointeurs habituels $\ptrK{t}$, on ajoute des types pointeurs utilisateur
$\ptrU{t}$. La différence entre les deux représente \emph{qui} contrôle leur
valeur (section~\ref{sec:secu-syscalls}).

Les différences sont les suivantes (figure~\ref{fig:qualif-changes-typ}):

\begin{figure}[b]%{{{

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \ptrU{t} }{Pointeur utilisateur}
  {END}
\\
\\
\gramdef[2.5cm]{Type\\sémantique}{τ}
  { … }{}
  { \ptrU{τ} }{Pointeur utilisateur}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateur (par rapport aux
figures~\ref{fig:les-types} et~\ref{fig:types-semantiques})}

\label{fig:qualif-changes-typ}
\end{figure}%}}}

\begin{itemize}

\item Les types \enquote{$\ptrK{t}$} s'appliquent aux pointeurs contrôlés par le
noyau. Par exemple, prendre l'adresse d'un objet de la pile noyau donne un
pointeur noyau.

\item Les types \enquote{$\ptrU{t}$}, quant à eux, s'appliquent aux pointeurs
qui proviennent de l'espace utilisateur. Ces pointeurs proviennent toujours
d'interfaces particulières, comme les appels système ou les paramètres
passés aux implantations de la fonction \texttt{ioctl}.

\end{itemize}

L'ensemble des notations est résumé dans le tableau suivant:

\begin{center}
\begin{tabular}{ccc}
\toprule
        & Noyau        & Utilisateur \\
\midrule
Syntaxe & $\&~x$       & $\eTaint{x}$ \\
Valeur  & $\wphi{(x)}$ & $\wphi{\vTainted{(x)}}$ \\
Type    & $\ptrK{t}$   & $\ptrU{t}$ \\
Accès   & $*~x$        & copy\_*\_user \\
\bottomrule
\end{tabular}
\end{center}

Puisqu'on s'intéresse à la provenance des pointeurs, détaillons les règles qui
créent, manipulent et utilisent des pointeurs.

\subsubsection*{Sources de pointeurs}

La source principale de pointeurs est l'opérateur $\&$ qui prend l'adresse d'une
variable. Celle-ci est bien entendue contrôlée par le noyau (dans le sens où son
déréférencement est toujours sûr). Cette construction crée donc des pointeurs
noyau:

\begin{mathpar}
  \disprule{AddrOf-Kernel}
\end{mathpar}

\subsubsection*{Manipulations de pointeurs}

L'avantage du typage est que celui-ci suit le flot de données: si à un endroit
une valeur de type $t$ est affectée à une variable, que le contenu de cette
variable est placé puis retiré d'une structure de données, il conserve ce type
$t$. En particulier un pointeur utilisateur reste un pointeur utilisateur.

Une seule règle consomme un pointeur et en retourne un. Elle concerne
l'arithmétique des pointeurs. On ne l'étend pas aux pointeurs utilisateur, car
pour effectuer de l'arithmérique, il faut observer la forme du pointeur
sous-jacent. Si on veut laisser $\phx\vTainted$ opaque, il faut donc interdire
l'arithmétique sur les pointeurs utilisateur.

\subsubsection*{Utilisations de pointeurs}

La principale restriction est que seuls les pointeurs noyau peuvent être
déréférencés de manière sûre. La règle capitale est donc la suivante (déjà
introduite dans le chapitre~\ref{cha:typbase}):

\begin{mathpar}
  \disprule{Lv-Deref}
\end{mathpar}

Ainsi, on interdit le déréférencement des expressions de type $\ptrU{t}$ à la
compilation.

L'opérateur $\eTaint{\cdot}$ transforme un pointeur selon la règle suivante:

\[
    \disprule{AddrOf-User}
\]

Les \enquote{fonctions} $\cfuF$ et $\ctuF$ sont typées de la manière suivante.
Il est à remarquer que ce ne sont pas vraiment des fonctions et qu'elles n'ont
pas un type en $(t_1, t_2) → t$, car il faudrait un type polymorphe pour pouvoir
les appliquer à n'importe quel type de pointeurs. Leur typage est donc plus
proche de celui d'un opérateur.

\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}

\subsection{Sûreté du typage}

\subsubsection*{Typage sémantique}

La définition du typage sémantique doit aussi être étendue au cas $φ =
\vTainted{φ'}$. En essence, \textsc{S-UserPtr} énonce que traverser un
constructeur $\phx\vTainted$ transforme un pointeur en pointeur utilisateur.

\begin{mathpar}
  \irule{S-UserPtr}
      { \semtyp{m}{\wphi{          φ }}{\ptrK{τ}} }
      { \semtyp{m}{\wphi{\vTainted{φ}}}{\ptrU{τ}} }

  \irule{Comp-Ptr}
    { \tComp{τ}{t} }
    { \tComp{\ptrU{τ}}{\ptrU{t}} }
\end{mathpar}

\subsubsection*{Propriétés du typage}

\begin{lemma}[Inversion du typage]
\label{lemma:inv-qualif}

En plus des cas présentés dans le lemme~\ref{lemma:inversion}, les cas suivants
permettent de remonter un jugement de typage.

\begin{itemize}
\item
    Si $Γ ⊢ \eTaint{e} : t$, alors il existe $t'$ tel que
    $t = t'~@$ et $Γ ⊢ e : t'$.
\item
    Si $Γ ⊢ \uGet{e_d}{e_s} : t$, alors
    $t = \tInt$ et il existe $t'$ tel que $Γ ⊢ e_d : t~*$ et
    $Γ ⊢ e_s : t~@$.
\item
    Si $Γ ⊢ \uPut{e_d}{e_s} : t$, alors
    $t = \tInt$ et il existe $t'$ tel que $Γ ⊢ e_d : t~@$ et
    $Γ ⊢ e_s : t~*$.
\end{itemize}
\end{lemma}

\begin{proof}[Démonstration]
Pour chaque forme syntaxique, on liste les règles qui ont comme conclusion
un jugement de typage portant sur celle-ci. Comme aucune autre règle ne
convient, on peut en déduire que c'est l'une de celles-ci qui a été
appliquée, et donc qu'une des prémisses est vraie.
\end{proof}

\subsubsection*{Progrès et préservation}

La propriété que nous cherchons à prouver est que le déréférencement d'un
pointeur dont la valeur est contrôlée par l'utilisateur ne peut se faire qu'à
travers une fonction qui vérifie la sûreté de celui-ci.

En fait il s'agit des théorèmes de sûreté du chapitre précédent.

\begin{theorem}[Progrès pour les extensions noyau]
\label{thm:progres-qual}

Le théorème~\ref{thm:progres} reste valable avec les extensions de ce chapitre.

\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:progres-qualif}.


\begin{theorem}[Préservation pour les extensions noyau]

\label{thm:preservation-qualif}

Le théorème~\ref{thm:preservation} reste valable avec les extensions de ce
chapitre.

\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:preservation-qualif}.

Ces extensions ne modifient pas les théorème de progrès et préservation sur les
phrases (théorèmes~\ref{thm:prog-phr} et~\ref{thm:presa-phr}).

La sûreté du typage étant à nouveau établie, on a montré que l'ajout de types
pointeurs utilisateur suffit pour avoir une adéquation entre les extensions de
sémantique de la section~\ref{sec:extensions-noyau} et les extensions du système
de type de la section~\ref{sec:extension-types}.

\subsection*{Conclusion}

En partant de \langname tel que décrit dans les chapitres~\ref{cha:lang}
et~\ref{cha:typbase}, on décrit une extension de sa syntaxe et de sa sémantique.
Cela permet d'exprimer les pointeurs vers
l'espace utilisateur, qui sont utilisés pour l'implantation d'appels système
(chapitre~\ref{cha:os}).

Une première idée pour le typage de ces nouveaux pointeurs est de leur donner le
même type que les pointeurs classiques. On a montré ensuite que ce typage naïf
ne suffit pas: il permet en effet de faire fuiter de l'information, ce qu'on
note par un cas d'erreur $\serr{sec}$. En termes de systèmes de types, cela
signifie que le théorème de progrès (théorème~\ref{thm:progres},
page~\pageref{thm:progres}) n'est plus vérifié.

Le langage des types est donc enrichi pour séparer les pointeurs utilisateur des
pointeurs noyau: les premiers sont explicitement construits par un ensemble de
sources bien déterminé, et les autres sont créés par exemple en prenant
l'adresse d'une variable. La règle de typage \textsc{Lv-Deref} assure que seuls
les pointeurs noyau peuvent être déréférencés. Pour accéder aux pointeurs
utilisateur, il faut appeler les constructions $\ctuF$ et $\cfuF$, qui sont
typées adéquatement et vérifient dynamiquement que les pointeurs dont la valeur
est contrôlée par l'utilisateur pointent vers l'espace utilisateur.

% vim: spelllang=fr
