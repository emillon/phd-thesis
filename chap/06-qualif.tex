\epigraph{
  A friend of mine in a compiler writing class produced a compiler with
  one error message ``you lied to me when you told me this was a program''.
  }
  {--- \textup{Pete Fenelon}}

Jusqu'ici \langname est un langage impératif généraliste, ne prenant pas en
compte les spécificités de l'adressage utilisé dans les systèmes d'exploitation.

Dans ce chapitre, on commence par l'étendre en ajoutant des constructions
modélisant les variables présentes dans l'espace utilisateur (cf.
chapitre~\ref{cha:os}). Celles-ci restent accessibles, mais nécessitent
d'utiliser un opérateur de déréférencement sûr qui vérifie à l'exécution que
l'invariant suivant est respecté :

\begin{quote}
Les pointeurs dont la valeur est contrôlée par l'utilisateur, pointent vers
l'espace utilisateur.
\end{quote}

Pour prouver que cette approche est bien fondée, on procède en plusieurs étapes.

Tout d'abord, on définit un nouveau type d'erreur $\serr{taint}$, déclenché
lorsqu'un pointeur contrôlé par l'utilisateur et pointant vers le noyau (le cas
que l'on cherche à éviter) est déréférencer\footnote{Il est important de noter
  que ce cas d'erreur est ``virtuel'', la distinction entre pointeur contrôlé
  par l'utilisateur et par le noyau n'étant normalement pas visible à
l'exécution}.

Ensuite, on montre qu'avec cet ajout, si on étend naïvement le système de types
en donnant le même type aux pointeurs contrôlés par l'utilisateur et le noyau,
le théorème de progrès (\ref{thm:progres}) n'est plus valable.

L'étape suivante est d'étendre, à son tour, le système de types de \langname en
distinguant les types des pointeurs contrôlés par l'utilisateur des pointeurs
contrôlés par le noyau. Puisqu'on veut interdire le déréférencement des premiers
par l'opérateur \texttt{*}, on modifie également le typage de celui-ci.

Enfin, une fois ces modifications faites, on prouve enfin que les propriétés de
progrès et de préservation sont rétablies.

\section{Extensions noyau pour \langname}

On ajoute à \langname la notion de valeur provenant de l'espace utilisateur.
Pour marquer la séparation entre les deux espaces d'adressage, on ajoute une
construction $φ \gramisa \vTainted{φ'}$. Le chemin interne $φ'$ correspond à une
variable classique (un pointeur noyau) qui, vu sous la forme $\vTainted{φ'}$,
est un pointeur utilisateur.

En plus du déréférencement par \texttt{*} qui devra donc renvoyer
$\serr{taint}$ pour les valeurs de la forme $\vTainted{φ'}$), il faut aussi
ajouter des constructions de lecture et d'écriture à travers les pointeurs
utilisateurs. On note $\uGet{lv}{e}$ la lecture sûre de $e$ (pointeur
utilisateur) dans $lv$ et $\uPut{e}{e'}$ l'écriture de $e$ dans l'espace pointé
par le pointeur utilisateur $e'$.

% TODO pourquoi pas des expressions ?

Illustrons ceci par un exemple. Imaginons un anière, pour écrire un appel
système fictif qui renvoie la version du noyau, en remplissant par pointeur une
structure contenant les champs entiers \texttt{major}, \texttt{minor} et
\texttt{patch}.

% TODO depend de eFun
% TODO dépend de tStruct

\begin{align*}
  & \mathrm{sys\_getver} = \mathrm{fun}(p) \{                      &             & & \\
  & \indent \uPut{ 3}{p.\texttt{major}_S} ; & \mathrm{où} & & S = \{ & \texttt{major} : \tInt ; \\
  & \indent \uPut{14}{p.\texttt{minor}_S} ; &             & &        & \texttt{minor} : \tInt ; \\
  & \indent \uPut{15}{p.\texttt{patch}_S}   &             & &        & \texttt{patch} : \tInt   \\
  & \}                                      &             & &     \}
\end{align*}

% TODO le champ utilisateur ça passe bien ?

Le but est en

% TODO
\begin{center}\rule{3in}{0.4pt}\end{center}

On procède en trois étapes (figure~\ref{fig:qualif-changes}) :

\begin{figure}%{{{

\begin{align*}
\gramdef{Expressions}{e}
  { … }{}
  { \eTaint{e} }{Expression souillée}
  { \uGet{lv}{e}}{ Lecture depuis l'espace utilisateur}
  { \uPut{e}{e'}}{ Écriture dans l'espace utilisateur}
  {END}
\\
\gramdef{Contextes}{C}
  { … }{}
  { \eTaint{C}}{}
  {END}
\\
\gramdef{Chemins}{φ}
  { … }{}
  { \vTainted{φ} }{Valeur souillée}
  {END}
\\
\gramdef{Erreurs}{Ω}
  { … }{}
  { \serr{taint} }{Erreur de souillure}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateurs}
\label{fig:qualif-changes}
% TODO définir les états et ms

\end{figure}%}}}

\begin{itemize}
\item
  tout d'abord, on ajoute une expression d'annotation sur les variables
  indiquant que celles-ci sont contrôlés par un utilisateur non privilégié,
  ainsi que des opérateurs de copie sûre.
\item
  ensuite, on étend l'ensemble des valeurs possibles pour les pointeurs
  à une valeur $\vTainted{φ}$ signifiant que l'objet pointé se situe en
  % TODO [E] ?
  espace utilisateur
\item
  enfin, on définit une nouvelle erreur $\serr{taint}$ produite par le
  déréférencement d'un pointeur ayant une telle valeur.
\end{itemize}

Pour adapter l'évaluation, plusieurs cas sont à rajouter. D'une part, la
présence de $\phx{\eTaint}$ dans une instruction consiste à ajouter un
$\phx{\vTainted}$ dans la valeur construite. Ceci ne peut être fait que dans le
cas où la valeur est un chemin $φ$, c'est-à-dire que la construction
$\phx{\eTaint}$ ne peut se faire que sur une expression de type pointeur.

% TODO passe globale c'est-a-dire & co (pas de ')

\begin{mathpar}
  \irule{Expr-Tainted}
    { }
    { \mm{m}{\eTaint{φ}}{m}{\vTainted{φ}} }
\end{mathpar}

D'autre part, une règle accède à la mémoire : \textsc{Exp-Lv}; pour
rappel :

\begin{mathpar}
  \semrule{Exp-Lv}
\end{mathpar}

Puisque la définition des chemins $φ$ a été changée, il est aussi nécessaire de
redéfinir la lentille $Φ$ utilisée ci-dessus (définition~\ref{def:acces-phi}).

% TODO [E] à détailler

On rajoute donc le cas :

\begin{align*}
Φ(\vTainted{φ}) =& \serr{taint}
\end{align*}

Pour accéder à ces valeurs, il faut utiliser les opérateurs $\phxx\uGet$ et
$\phxx\uPut$.

% TODO leur sémantique

\section{Insuffisance des types simples}

% TODO[E] c'est ok

Étant donné \langname augmenté de cette extension sémantique, on peut étendre
trivialement le système de types avec la règle suivante :

\begin{mathpar}
  \irule{Taint-Ignore}
    { Γ ⊢ e : t* }
    { Γ ⊢ \eTaint{e} : t* }
\end{mathpar}

Cette règle est compatible avec l'extension, sauf qu'elle introduit des termes
qui sont bien typables mais dont l'évaluation provoque une erreur autre que
$\serr{div}$, $\serr{array}$ ou $\serr{ptr}$, violant ainsi le
théorème~\ref{thm:progres}.

Par exemple, supposons que $x$ soit une variable globale entière, et posons $e =
* \eTaint {\& x}$.

$e$ est alors bien typée sous $Γ = x : \tInt$ :

\begin{mathpar}
  \irule{Lv-Deref}
    {
      \irule{Taint-Ignore}
        {
          \irule{Lv-Deref}
            {
              \irule{Lv-Var}
                { x:\tInt ∈ Γ }
                { Γ ⊢ x : \tInt }
            }
            { Γ ⊢ \& x : \tInt*}
        }
        { Γ ⊢ \eTaint {\& x} : \tInt*}
    }
    { Γ ⊢ * \eTaint {\& x} : \tInt}
\end{mathpar}

Posons alors $m = ([[x↦0]], [])$ (on a bien $\mcomp{Γ}{m}$). L'évaluation de $e$
sous $m$ provoque une erreur, comme le montre la dérivation suivante.

\begin{mathpar}
\inferrule*
  {
    \irule{Exp-Lv}
      {
        \inferrule*
          { }
          {m[*\vTainted{x}] = \serr{taint}}
      }
      { \mm{m}{* \eTaint {\& x}}{m}{\serr{taint}} }
    \\
    \irule{Eval-Err}
      { }
      {
        \msi{m}{\serr{taint}} → \serr{taint}
      }
  }
  {\msi{m}{* \eTaint {\& x}} → \serr{taint}}
\end{mathpar}

\section{Extensions du système de types}

On présente ici un système de types plus expressif permettant de capturer les
extensions de sémantique. \emph{In fine}, cela permettra de prouver le
théorème~\ref{thm:progres-qual} qui est l'équivalent du
théorème~\ref{thm:progres} mais pour le nouveau jugement de typage.

% TODO [E] ??

Définir un nouveau système de types revient à définir un nouveau jugement de
typage $\cdot ⊢_q \cdot : \cdot$, à partir d'un ensemble de règles. Pour la
plupart, les règles seront identiques, donc sauf mention contraire, les règles
portant sur $\cdot ⊢ \cdot : \cdot$ s'appliqueront aussi sur $\cdot ⊢_q \cdot :
\cdot$. Naturellement, la plupart des différences porteront sur le traitement des
pointeurs.

La différence principale est qu'à chaque pointeur, on ajoute un
\emph{qualificateur} qui représente \emph{qui} contrôle sa valeur
(section~\ref{sec:secu-syscalls}). Les deux qualificateurs sont :

\begin{itemize}
\item
  \qKernel : il s'applique aux pointeurs contrôlés par le noyau. Par exemple,
  prendre l'adresse d'un objet de la pile noyau donne un pointeur noyau.
\item
  \qUser : il s'applique aux pointeurs qui proviennent de l'espace utilisateur.
  Ces pointeurs proviennent toujours d'interfaces particulières, comme les
  appels système ou les paramètres de la fonction \texttt{ioctl}.
% TODO [E] tu comptes malloc ? &x ?
\end{itemize}

Cet ajout est précisé dans la figure~\ref{fig:qualif-changes-typ}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Qualificateurs}{q}
  { \qKernel }{Donnée noyau (sûre)}
  { \qUser   }{Donnée utilisateur (non sûre)}
  {END}
\\
\gramdef{Types}{t}
  { … }{}
  { \msout{t~*} }{\textrm{Pointeur}}
  { t~q~* }{Pointeur qualifié}
  {END}
\end{align*}

\caption{Changements liés aux qualificateurs de types}
\label{fig:qualif-changes-typ}
\end{figure}%}}}

Au niveau du système de types, la principale restriction est que seuls les
pointeurs \qKernel peuvent être déréférencés de manière sûre :

\begin{mathpar}
\irule{Lv-Deref-Kernel}{
  Γ ⊢_q e : τ~\textsc{Kernel}*
}{
  Γ ⊢_q *e : τ
}
\end{mathpar}

% TODO [E] et que se passe-t'il quand on a une expression e de type τ K* que
% l'on cherche à déréférencer ?

L'opérateur $\eTaint{\cdot}$ transforme un pointeur selon la règle de souillure
suivante :

% TODO définir les stubs

\begin{mathpar}
\irule{Taint}
  { Γ ⊢_q e : t~q~* }
  { Γ ⊢_q \eTaint{x} : t~\qUser~* }
\end{mathpar}

Les opérateurs $\phxx\uGet$ et $\phxx\uPut$ sont typés de la manière suivante :

\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}

% TODO adresse = kernel

% TODO parler de sous typage

La définition du typage sémantique doit aussi être étendue au cas $φ =
\vTainted{φ'}$. Les références mémoires sont ``nettoyées'' pour accéder à la
left-value encapsulée.

\begin{mathpar}
  \irule{S-Tainted}
    { m ⊧           φ'  : t~\qKernel~* }
    { m ⊧ \vTainted{φ'} : t~\qUser~* }
\end{mathpar}

\wip

\section{Sûreté du typage}

Le déréférencement d'un pointeur dont la valeur est contrôlée par l'utilisateur
ne peut se faire qu'à travers une fonction qui vérifie la sûreté de celui-ci.

\begin{theorem}[Progrès pour les types qualifiés]
  \label{thm:progres-qual}

  Supposons que $Γ ⊢_q e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai :

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mcomp{Γ}{m'} ∧ \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}
\end{theorem}

%\begin{proof}

  %% TODO

%\end{proof}

Et nous donnons un équivalent du théorème~\ref{thm:preservation}.

\begin{theorem}[Préservation pour les types qualifiés]

  Si une expression est typable et que son évaluation produit une valeur, alors
  cette valeur est du même type que l'expression.

  Si $Γ ⊢_q e : t$ et $e → v$ % TODO

  alors $Γ ⊢_q v : t$.

\end{theorem}

% vim: spelllang=fr
