% TODO 8 pages: c'est un peu court pour la partie originale de la thèse

Jusqu'ici \langname{} est un langage impératif généraliste, ne prenant pas en
compte les spécificités de l'adressage utilisé dans les systèmes d'exploitation.

Dans ce chapitre, on commence par l'étendre en ajoutant des constructions
modélisant les variables présentes dans l'espace utilisateur (cf.
chapitre~\ref{cha:os}). Pour accéder à celles-ci, on ajoute un opérateur de
déréférencement sûr qui vérifie à l'exécution que l'invariant suivant est
respecté:

\begin{quote}
Les pointeurs dont la valeur est contrôlée par l'utilisateur, pointent vers
l'espace utilisateur.
\end{quote}

La terminologie mérite d'être détaillée:

Un pointeur contrôlé par l'utilisateur, ou \emph{pointeur utilisateur}, est
référence mémoire dont la valeur est modifiable par le code utilisateur (opposé
au code noyau, que nous analysons ici). Ceci correspond à des données provenant
de l'extérieur du système vérifié. C'est une propriété statique, qui peut être
déterminée à la compilation à partir de considérations syntaxiques. Par exemple,
l'adresse d'une variable locale est toujours considérée comme étant contrôlée
par le noyau.

Un pointeur pointant vers l'espace utilisateur fait référence à une variable
allouée en espace utilisateur. Cela veut dire qu'y accéder ne risque pas de
mettre en péril l'isolation du noyau en faisant fuiter des informations
confidentielles ou en déjouant son intégrité. Cette propriété est dynamique: un
pointeur utilisateur peut \emph{a priori} pointer vers l'espace utilisateur, ou
non.

Pour prouver que cette approche est bien fondée, on procède en plusieurs étapes.

Tout d'abord, on définit une nouvelle erreur $\serr{taint}$, déclenchée
lorsqu'un pointeur contrôlé par l'utilisateur et pointant vers le noyau est
déréférencé (le cas que l'on cherche à éviter)\footnote{Il est important de
noter que ce cas d'erreur est «virtuel», la distinction entre pointeur contrôlé
par l'utilisateur et par le noyau n'étant normalement pas visible à
l'exécution.}. % TODO la footnote tue

Ensuite, on montre qu'avec cet ajout, si on étend naïvement le système de types
en donnant le même type aux pointeurs contrôlés par l'utilisateur et le noyau,
le théorème de progrès (\ref{thm:progres}) n'est plus valable. Cela signifie que
le système de type classique présenté dans le chapitre~\ref{cha:typbase} ne
suffit pas à capturer les propriétés de sécurité que nous voulons interdire.

L'étape suivante est d'étendre, à son tour, le système de types de \langname{}
en distinguant les types des pointeurs contrôlés par l'utilisateur des pointeurs
contrôlés par le noyau. Puisqu'on veut interdire le déréférencement des premiers
par l'opérateur \texttt{*}, on modifie également le typage de celui-ci.

Enfin, une fois ces modifications faites, on prouve que les propriétés de
progrès et de préservation sont rétablies.

\section{Extensions noyau pour \langname}
\label{sec:extensions-noyau}

On ajoute à \langname{} la notion de valeur provenant de l'espace utilisateur.
Pour marquer la séparation entre les deux espaces d'adressage, on ajoute une
construction $φ \gramisa \vTainted{φ'}$. Le chemin interne $φ'$ désigne une
variable classique (un pointeur noyau) et l'opérateur $\phx\vTainted$ permet de
l'interpréter comme un pointeur vers l'espace utilisateur, contrairement à
$\widehat{\&}\cdot$ qui crée des pointeurs vers l'espace noyau. En quelque
sorte, on ne classifie pas les valeurs selon la variable pointée mais selon la
construction du pointeur.

Remarquons qu'on n'introduit pas de sous-typage: les pointeurs noyau ne peuvent
être utilisés qu'en tant que pointeurs noyau, et les pointeurs utilisateurs
qu'en tant que pointeurs utilisateurs.

En plus du déréférencement par \texttt{*} (qui devra donc renvoyer
$\serr{taint}$ pour les valeurs de la forme $\vTainted{φ'}$), il faut aussi
ajouter des constructions de lecture et d'écriture à travers les pointeurs
utilisateurs. Ceci sera fait sous forme de deux fonctions, $\cfuF$ et \linebreak
$\ctuF$. Celles-ci prennent deux pointeurs en paramètre et renvoient un booléen
indiquant si la copie a pu être faite (si le paramètre contrôlé par
l'utilisateur pointe en espace noyau, les fonctions ne font pas la copie et
signalent l'erreur).

Illustrons ceci par un exemple. Imaginons un appel système fictif qui renvoie la
version du noyau, en remplissant par pointeur une structure contenant les champs
entiers \texttt{major}, \texttt{minor} et \texttt{patch} (un équivalent dans
Linux est l'appel système \verb!uname()!). Celui-ci peut être alors écrit
comme dans la figure~\ref{fig:ex-sys-getver}. Une fois la structure noyau $v$
remplie, il faut la copier vers l'espace utilisateur. La fonction $\ctuF$ va
réaliser cette copie (de la même manière qu'avec un \verb!memcpy()!), mais
après avoir testé dynamiquement que $p$ pointe en espace utilisateur (dans le
cas contraire, la copie n'est pas faite).

\begin{figure}[h]
\setlength{\parindent}{1cm}
\begin{align*}
  & \mathrm{sys\_getver} = \mathrm{fun}(p) \{ \\
  & \indent \textsc{Decl}~v= \{~\texttt{major} : 3
                              ; \texttt{minor} : 14
                              ; \texttt{patch} : 15~\}~\textsc{in} \\
  & \indent \uPut{p}{\& v} \\
  & \}
\end{align*}

\caption{Implantation d'un appel système qui remplit une structure par pointeur}
\label{fig:ex-sys-getver}
\end{figure}

On peut remarquer que contrairement aux fonctions présentes dans le noyau Linux,
les fonctions $\cfuF$ et $\ctuF$ n'ont pas de paramètre indiquant la taille à
copier. Cela est dû au fait que le modèle mémoire de \langname{} est plus haut
niveau. L'information de taille est déjà présente dans chaque valeur.

Une autre remarque à faire est qu'il n'y a pas de manière de copier des données
de l'espace utilisateur vers l'espace utilisateur. Il est nécessaire de passer
par l'espace noyau. La raison est que puisqu'il faut réaliser deux tests
dynamiques, les erreurs peuvent arriver à ces deux endroits. Plutôt que de
proposer un opérateur qui réalise cette copie, on laisse le programmeur faire
les deux copies manuellement.

On commence donc par ajouter aux instructions des constructions $\phxx{\uPut}$
et $\phxx{\uGet}$ de copie sûre. Afin de leur donner une sémantique, il faut
étendre l'ensemble des valeurs pointeur $φ$ aux constructions de la forme
$\vTainted{φ'}$. Pour créer des termes s'évaluant en de telles valeurs, il faut
une construction syntaxique $\eTaint{e}$ telle que si $e$ s'évalue en $φ$,
$\eTaint{e}$ s'évalue en $\vTainted{φ}$. Cela correspond à 2 ajouts: une un
nouveau contexte d'évaluation $\eTaint{\ctxEmpty}$ et une règle d'évaluation.
Enfin, on ajoute une nouvelle erreur $\serr{taint}$ à déclencher lorsqu'on
déréférence directement un pointeur utilisateur. Ces étapes sont résumées dans
la figure~\ref{fig:qualif-changes}.

\begin{figure}%{{{

\begin{align*}
\gramdef{Expressions}{e}
  { … }{}
  { \eTaint{lv} }{Adresse utilisateur}
  {END}
\\
\\
\gramdef{Contextes}{C}
  { … }{}
  { \eTaint{C}}{}
  { \uGet{C}{e} }{}
  { \uGet{v}{C} }{}
  { \uPut{C}{e} }{}
  { \uPut{v}{C} }{}
  {END}
\\
\\
\gramdef{Chemins}{φ}
  { … }{}
  { \vTainted{φ} }{Valeur souillée}
  {END}
\\
\\
\gramdef{Erreurs}{Ω}
  { … }{}
  { \serr{taint} }{Erreur de souillure}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateurs (par rapport à l'interprète du
chapitre~\ref{cha:lang})}

\label{fig:qualif-changes}

\end{figure}%}}}

En résumé, on a deux constructions pour créer des pointeurs à partir d'une
left-value : $\&~\cdot$ crée un pointeur noyau, et $\eTaint{\cdot}$ crée un
pointeur utilisateur. Seul la première est fait pour être utilisé dans le code à
analyser. La seconde sert uniquement à modéliser les points d'entrée du noyau.
Par exemple, la fonction $\mathrm{sys\_getver}$ de la
figure~\ref{fig:ex-sys-getver} peut être appelée de la manière suivante:

{
\setlength{\parindent}{1cm}
\begin{align*}
  & \indent \textsc{Decl}~v= \{~\texttt{major} : 0
                              ; \texttt{minor} : 0
                              ; \texttt{patch} : 0~\}~\textsc{in} \\
  & \indent \mathrm{sys\_getver} (\eTaint{v})
\end{align*}
}

\section{Extensions sémantiques}

En ce qui concerne l'évaluation des expressions $\phx\eTaint$, on ajoute la
règle suivante:

\[
  \semrule{Expr-Tainted}
\]

Ensuite, il est nécessaire d'adapter les règles d'accès à la mémoire pour
déclencher une erreur $\serr{taint}$ en cas de déréférencement d'un pointeur
utilisateur. Les accès mémoire en lecture proviennent de la règle
\textsc{Exp-Lv} et ceux en lecture, de la règle \textsc{Exp-Set}, rappellées
ici:

\begin{mathpar}
  \semrule{Exp-Lv}

  \semrule{Exp-Set}
\end{mathpar}

Les accès à la mémoire sont en effet faits par le biais de la lentille $Φ$. Il
suffit donc d'adapter sa définition (page~\pageref{subsec:acces-phi}) de
celle-ci en rajoutant le cas:

\begin{align*}
Φ(\vTainted{φ}) &= \serr{taint}
\end{align*}

Enfin, il est nécessaire de donner une sémantique aux fonctions $\cfuF$ et
\linebreak $\ctuF$. L'idée est que celles-ci testent dynamiquement la
\emph{valeur} du paramètre contrôlé par l'utilisateur afin de vérifier que
celui-ci pointe vers l'espace utilisateur (c'est-à-dire, qu'il est de la forme
$\vTainted{φ}$).

Deux cas peuvent se produire. Soit la partie à vérifier a la forme
$\vTainted{φ'}$, soit non (et dans ce cas $∄φ', φ = \vTainted{φ'}$). Dans le
premier cas (règles \textsc{User-*-OK}), alors la copie est faite et l'opération
de copie retourne la valeur entière $0$. Dans le second (règles
\textsc{User-*-Err}), aucune copie n'est faite et la valeur $-1$ est retournée.
Ce comportement est calé celui des fonctions \texttt{copy\_\{from,to\}\_user} du
noyau Linux: en cas de succès elles renvoient $0$, et en cas d'erreur
\texttt{-EFAULT} ($= -14$).

\begin{mathpar}
  \semrule{User-Get-OK}

  \semrule{User-Get-Err}

  \semrule{User-Put-OK}

  \semrule{User-Put-Err}
\end{mathpar}

Ces règles sont à appliquer en priorité de la règle d'appel de fonction
classique, puisque ces fonctions n'ont pas de corps en tant que tel. En effet
celles ci ne sont pas implantables directement en \langname, puisqu'il n'y a pas
par exemple d'opérateur permettant d'extraire $φ$ depuis une valeur
$\vTainted{φ}$. L'opération en «boîte noire» de ces deux fonctions permet
d'assurer que l'accès à l'espace utilisateur est toujours couplé à un test
dynamique.

\section{Insuffisance des types simples}

Étant donné \langname{} augmenté de cette extension sémantique, on peut étendre
naïvement le système de types avec la règle suivante:

\label{page:rule-taint-ignore}
\begin{mathpar}
  \irule{Taint-Ignore}
    { Γ ⊢ lv : t }
    { Γ ⊢ \eTaint{lv} : t~* }
\end{mathpar}

Cette règle est compatible avec l'extension, sauf qu'elle introduit des termes
qui sont bien typables mais dont l'évaluation provoque une erreur autre que
$\serr{div}$, $\serr{array}$ ou $\serr{ptr}$, violant ainsi le
théorème~\ref{thm:progres}. Posons:

\[
\begin{cases}
  e = * \eTaint{x} \\
  Γ = x : \tInt \\
  m = ([[x↦0]], [~]) \\
\end{cases}
\]

Les hypothèses du théorème de progrès sont bien vérifiées, mais cependant la
conclusion n'est pas vraie:

\begin{itemize}
  \item
    On a bien $\mcomp{Γ}{m}$. En effet:

    \begin{mathpar}
        \irule{M-Push}
            {
                \irule{M-Empty}
                    { }
                    { \mcomp{[~]}{([~], [~])} }
            \\
            [~] ⊧ 0 : \tInt
            \\
            \tComp{\tInt}{\tInt}
            }
            { \mcomp{x:\tInt}{([[x↦0]], [~])} }
    \end{mathpar}

  \item
    $e$ est bien typée sous $Γ$:

      \begin{mathpar}
        \irule{Lv-Deref}
          {
            \irule{Taint-Ignore}
              {
                \irule{Lv-Deref}
                  {
                    \irule{Lv-Var}
                      { x:\tInt ∈ Γ }
                      { Γ ⊢ x : \tInt }
                  }
                  { Γ ⊢ \& x : \tInt*}
              }
              { Γ ⊢ \eTaint{x} : \tInt*}
          }
          { Γ ⊢ * \eTaint {x} : \tInt}
      \end{mathpar}

  \item
    L'évaluation de $e$ sous $m$ provoque une erreur différente de
    $\serr{div}$, $\serr{array}$, ou $\serr{ptr}$:

      \begin{mathpar}
      \inferrule*
        {
          \irule{Exp-Lv}
            {
              \inferrule*
                { }
                {m[*\vTainted{x}] = \serr{taint}}
            }
            { \mm{m}{* \eTaint {x}}{m}{\serr{taint}} }
          \\
          \irule{Eval-Err}
            { }
            {
              \msi{m}{\serr{taint}} → \serr{taint}
            }
        }
        {\msi{m}{e} → \serr{taint}}
      \end{mathpar}

\end{itemize}

Cela montre que le typage n'apporte plus de garantie de sûreté sur l'exécution:
le système de types naïvement étendu par une règle comme
\textsc{Taint-Ignore} n'est pas en adéquation avec les extensions présentées
dans la section~\ref{sec:extensions-noyau}. Il faut donc raffiner les règles de
typage pour interdire ce cas.

\section{Extensions du système de types}
\label{sec:extension-types}

On présente ici un système de types plus expressif permettant de capturer les
extensions de sémantique. \emph{In fine}, cela permettra de prouver le
théorème~\ref{thm:progres-qual} qui est l'équivalent du
théorème~\ref{thm:progres} mais pour le nouveau jugement de typage.

Définir un nouveau système de types revient à étendre le jugement de typage
$\cdot ⊢ \cdot : \cdot$, en modifiant certaines règles et en en ajoutant
d'autres. Naturellement, la plupart des différences porteront sur le traitement
des pointeurs.

\subsection*{Pointeurs utilisateurs}

Le changement clef est l'ajout de \emph{pointeurs utilisateur}. En plus des
types pointeurs (noyau) $\ptrK{t}$, on ajoute des types pointeurs utilisateur
$\ptrU{t}$. La différence entre les deux représente \emph{qui} contrôle leur
valeur (section~\ref{sec:secu-syscalls}).

Les différences sont les suivantes (figure~\ref{fig:qualif-changes-typ}):

\begin{figure}[b]%{{{

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \ptrU{t} }{Pointeur utilisateur}
  {END}
\\
\\
\gramdef[2.5cm]{Type\\sémantique}{τ}
  { … }{}
  { \ptrU{τ} }{Pointeur utilisateur}
  {END}
\end{align*}

\caption{Ajouts liés aux pointeurs utilisateur (par rapport aux
figures~\ref{fig:les-types} et~\ref{fig:types-semantiques})}

\label{fig:qualif-changes-typ}
\end{figure}%}}}

\begin{itemize}

\item Les types «$\ptrK{t}$» s'appliquent aux pointeurs contrôlés par le
noyau. Par exemple, prendre l'adresse d'un objet de la pile noyau donne un
pointeur noyau.

\item Les types «$\ptrU{t}$», quant à eux, s'appliquent aux pointeurs qui
proviennent de l'espace utilisateur. Ces pointeurs proviennent toujours
d'interfaces particulières, comme les appels système ou les paramètres passés
aux implantations de la fonction \texttt{ioctl}.

\end{itemize}

L'ensemble des notations est résumé dans le tableau suivant:

\begin{center}
\begin{tabular}{ccc}
\toprule
        & Noyau      & Utilisateur \\
\midrule
Syntaxe & $\&~x$     & $\eTaint{x}$ \\
Valeur  & $\widehat{\&}~x$ & $\vTainted{x}$ \\
Type    & $\ptrK{t}$ & $\ptrU{t}$ \\
Accès   & $*~x$      & copy\_*\_user \\
\bottomrule
\end{tabular}
\end{center}

Puisqu'on s'intéresse à la provenance des pointeurs, détaillons les règles qui
créent, manipulent et utilisent des pointeurs.

\subsection*{Sources de pointeurs}

La source principale de pointeurs est l'opérateur $\&$ qui prend l'adresse d'une
variable. Celle-ci est bien entendue contrôlée par le noyau (dans le sens où son
déréférencement est toujours sûr). Cette construction crée donc des pointeurs
noyau:

\begin{mathpar}
  \disprule{AddrOf-Kernel}
\end{mathpar}

\subsection*{Manipulations de pointeurs}

L'avantage du typage est que celui-ci suit le flot de données: si à un endroit
une valeur de type $t$ est affectée à une variable, que le contenu de cette
variable est placé puis retiré d'une structure de données, il conserve ce type
$t$. En particulier un pointeur utilisateur reste un pointeur utilisateur.

Une seule règle consomme un pointeur et en retourne un. Elle concerne
l'arithmétique des pointeurs. On l'étend aux pointeurs utilisateur:

\begin{mathpar}
  \disprule{Ptr-Arith-User}
\end{mathpar}

\subsection*{Utilisations de pointeurs}

La principale restriction est que seuls les pointeurs noyau peuvent être
déréférencés de manière sûre. La règle capitale est donc la suivante (déjà
introduite dans le chapitre~\ref{cha:typbase}):

\begin{mathpar}
  \disprule{Lv-Deref}
\end{mathpar}

Ainsi, on interdit le déréférencement des expressions de type $\ptrU{t}$ à la
compilation.

L'opérateur $\eTaint{\cdot}$ transforme un pointeur selon la règle suivante:

\[
    \disprule{Taint}
\]

Les «fonctions» $\cfuF$ et $\ctuF$ sont typées de la manière suivante. Il est
à remarquer que ce ne sont pas vraiment des fonctions et qu'elles n'ont pas un
type en $(t_1, t_2) → t$, car il faudrait un type polymorphe pour pouvoir les
appliquer n'importe quel type de pointeurs. Leur typage est donc plus proche de
celui d'un opérateur.

\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}

\section{Sûreté du typage}

\subsection*{Typage sémantique}

La définition du typage sémantique doit aussi être étendue au cas $φ =
\vTainted{φ'}$.

\begin{mathpar}
  \irule{S-Tainted}
    { \semtyp{m}{          φ' }{τ} }
    { \semtyp{m}{\vTainted{φ'}}{\ptrU{τ}} }

  \irule{Comp-Ptr}
    { \tComp{τ}{t} }
    { \tComp{\ptrU{τ}}{\ptrU{t}} }
\end{mathpar}

\subsection*{Propriétés du typage}

\begin{lemma}[Inversion du typage]
\label{lemma:inv-qualif}

En plus des cas présentés dans le lemme~\ref{lemma:inversion}, les cas suivants
permettent de remonter un jugement de typage.

\begin{itemize}
\item
    Si $Γ ⊢ \uGet{e_d}{e_s} : t$, alors
    $t = \tInt$ et il existe $t'$ tel que $Γ ⊢ φ_d : t~*$ et
    $Γ ⊢ φ_s : t~@$.
\item
    Si $Γ ⊢ \uPut{e_d}{e_s} : t$, alors
    $t = \tInt$ et il existe $t'$ tel que $Γ ⊢ φ_d : t~@$ et
    $Γ ⊢ φ_s : t~*$.
\end{itemize}
\end{lemma}

\begin{proof}[Démonstration]
Pour chaque forme syntaxique, seule une règle permet d'atteindre cette
conclusion.
\end{proof}

\subsection*{Progrès et préservation}

La propriété que nous cherchons à prouver est que le déréférencement d'un
pointeur dont la valeur est contrôlée par l'utilisateur ne peut se faire qu'à
travers une fonction qui vérifie la sûreté de celui-ci.

En fait il s'agit des théorèmes de sûreté du chapitre précédent.

\begin{theorem}[Progrès pour les extensions noyau]
\label{thm:progres-qual}

Le théorème~\ref{thm:progres} reste valable avec les extensions de ce chapitre.

\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:progres-qualif}.


\begin{theorem}[Préservation pour les extensions noyau]

\label{thm:preservation-qualif}

Le théorème~\ref{thm:preservation} reste valable avec les extensions de ce
chapitre.

\end{theorem}

La preuve de ce théorème est en annexe~\ref{proof:preservation-qualif}.

Ces extensions ne modifient pas les théorème de progrès et préservation sur les
phrases (théorèmes~\label{thm:prog-phr} et~\label{thm:presa-phr}).

La sûreté du typage étant à nouveau établie, on a montré que l'ajout de types
pointeurs utilisateur suffit pour avoir une adéquation entre les extensions de
sémantique de la section~\ref{sec:extensions-noyau} et les extensions du système
de type de la section~\ref{sec:extension-types}.

\section*{Conclusion}

On a décrit une simple extension au système de types présenté dans le
% TODO simple parce que le boulot était fait avant
chapitre~\ref{cha:typbase}. Celle-ci permet d'exprimer les pointeurs vers
l'espace utilisateur, qui sont utiles pour l'implantation d'appels système
(chapitre~\ref{cha:os}).

Une première idée pour le typage de ces constructions est de ne pas faire la
distinction entre les pointeurs utilisateur et les pointeurs noyau. Cela revient
à employer la règle \textsc{Taint-Ignore} de la
page~\pageref{page:rule-taint-ignore}.
% TODO que fait-elle
On a montré ensuite que ce typage naïf ne
suffit pas: il permet en effet de faire fuiter de l'information, ce qu'on note
par un cas d'erreur $\serr{taint}$. En termes de systèmes de types, cela
signifie que le théorème de progrès (théorème~\ref{thm:progres},
page~\pageref{thm:progres}) n'est plus vérifié.

Le langage des types est donc enrichi pour séparer les pointeurs utilisateur des
pointeurs noyau: les premiers sont explicitement construits par un ensemble de
sources bien déterminé, et les autres sont créés par exemple en prenant
l'adresse d'une variable. La règle de typage \textsc{Lv-Deref} assure que seuls
les pointeurs noyau peuvent être déréférencés. Pour accéder aux pointeurs
utilisateur, il faut appeller les constructions $\ctuF$ et $\cfuF$ qui sont
typées adéquatement et vérifient dynamiquement que les pointeurs dont la valeur
est contrôlée par l'utilisateur pointent vers l'espace utilisateur.

% TODO taint -> user ptet?

% vim: spelllang=fr
