Après avoir décrit notre solution dans la partie~\ref{part:lang}, nous avons
présenté ici notre démarche expérimentale.

En s'appuyant sur le langage \newspeak, on gagne beaucoup par rapport à d'autres
représentations intermédiaires. Le fait d'avoir un langage avec peu de
constructions permet de ne pas avoir à exprimer plusieurs fois la même règle
(par exemple, une fois sur la boucle ``\emph{for}'' et une autre sur la boucle
``\emph{while}'').

Un des inconvénients est que le modèle mémoire utilisé par \newspeak est assez
différent de celui de \langname (ainsi que décrit dans le
chapitre~\ref{cha:lang}). \newspeak est en effet prévu pour implanter des
analyses précises de valeur reposant sur l'interprétation abstraite, et
nécessite donc un modèle mémoire de plus bas niveau (où on peut créer des
valeurs à partir d'une suite d'octets, par exemple). Il est aussi à noter que
bien que l'évaluation de \langname ait été décrite ici, c'est principalement
dans le but de démontrer des propriétés sémantiques: l'évaluateur n'a pas été
implanté.

Le prototype d'implantation peut évoluer dans deux directions: d'une part, en
continuant à s'appuyer sur \newspeak, on peut réaliser des pré-analyses de
typage qui permettent de guider une analyse plus précise, par exemple en
choisissant un domaine abstrait différent en fonction des types de données
rencontrés. D'autre part, il est possible de faire une implantation plus fidèle
à \langname, qui permette d'ajouter de nouvelles fonctionnalités plus éloignées
de C. Par exemple, un système de régions permettrait de simplifier
l'environnement d'exécution en enlevant l'opération de nettoyage mémoire
$\phx\cCleanup$. Le système de types peut également être enrichi, pour ajouter
par exemple du polymorphisme. Le chapitre~\ref{cha:conclusion} présente quelques
unes de ces extensions possibles.

Le chapitre~\ref{cha:etudedecas} permet de démontrer que notre approche
fonctionne. Le bug \url{http://freedesktop.org} \#29340 est la manifestation
d'un problème de pointeur utilisateur mal utilisé dans le noyau, ainsi que
décrit dans le chapitre~\ref{cha:os}. En lançant notre analyse sur le code
présentant un problème, l'erreur est détectée. Au contraire, en la lançant sur
le code après application du correctif (\emph{commit} \texttt{ad8ab3557}),
aucune erreur n'est trouvée.

Cette expérimentation est pour le moment limitée, mais on peut l'étendre à des
domaines de plus en plus importants dans le noyau Linux: tout d'abord, en
vérifiant les autres \emph{ioctls} de ce pilote, puis l'ensemble des
\emph{ioctls} des modules ayant la même interface, puis d'autres types
d'interfaces qui manipulent des pointeurs utilisateurs: par exemple d'autres
pilotes de périphériques ou des systèmes de fichiers.
