\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}
Pour prouver que $ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$, il suffit de prouver les trois
propriétés caractéristiques.

\paragraph{GetPut}%{{{

{

\def\xa{
  \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    }
  }


\def\xb{
  \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r }
}

\def\xab{ définition de \lensGetX{ℒ} }

\def\xc{
  \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
                    {
                      \lensGet{ℒ_2}
                        {
                          \lensGet{ℒ_1}{r}
                        }
                    }
                    { \lensGet{ℒ_1}
                              {r}
                    }
          }
          {r}
}

\def\xbc{ définition de \lensPutX{ℒ} }

\def\xd{
  \lensPut{ℒ_1}
          {
            \lensGet{ℒ_1}{r}
          }
          {r}
}

\def\xcd{ \textsc{GetPut} sur $ℒ_2$ }

\def\xe{r}

\def\xde{\textsc{GetPut} sur $ℒ_1$}

\begin{conteq}
    \xa{} \\
  = \xb{} & \xab{} \\
  = \xc{} & \xbc{} \\
  = \xd{} & \xcd{} \\
  = \xe{} & \xde{}
\end{conteq}

}

%}}}

\paragraph{PutGet}%{{{

\begin{conteq}
  \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    }
& définition de \lensGetX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    }
& définition de \lensPutX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    }
& \textsc{PutGet} sur $ℒ_1$ \\
= a
& \textsc{PutGet} sur $ℒ_2$ \\
\end{conteq}
%}}}

\paragraph{PutPut}%{{{

\begin{conteq}[onecolumn]
  \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{GetPut} sur $ℒ_1$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{PutPut} sur $ℒ_2$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    }
& \textsc{PutPut} sur $ℒ_1$ \\
= \lensPut{ℒ}{a'}{r}
& définition de $\ggg$ \\
\end{conteq}
%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

(théorème~\ref{thm:progres})

\begin{proof}

On procède par induction sur la dérivation du jugement de typage. Puisque les
jugements $Γ ⊢ i$, $Γ ⊢ e : t$ et $Γ ⊢ lv : t$ sont interdépendants, on traite
tous les cas par récursion mutuelle.

Le squelette de cette preuve est une analyse de cas selon la dernière règle
utilisée. La plupart des cas ont la même forme: , et on utilise l'hypothèse de
récurrence sur les sous-éléments syntaxiques (en appliquant éventuellement le
lemme~\ref{lemma:inversion} d'inversion pour établir qu'ils sont bien typés).
Dans le cas ``valeur'', on appelle une règle qui permet de transformer une
opération syntaxique en opération sémantique (par exemple, on transforme le $+$
unaire en un $\widehat{+}$ sémantique). Dans le cas ``évaluation'', on applique
la règle \textsc{Ctx} avec un contexte particulier qui permet de passer d'un
jugement $\mm{m}{a}{m'}{a'}$ à un jugement $\mm{m}{b}{m'}{b'}$ (où $a$ apparaît
dans $b$). Enfin, dans le cas ``erreur'', on utilise \textsc{Eval-Err} avec ce
même contexte $C$.

Ceci est valable pour la majorité des cas. Il faut faire attention en
particulier aux opérations sémantiques qui peuvent produire des erreurs (comme
la division, ou l'opérateur $\phxx\cLookup$).

% TODO montrer progrès au niveau des phrases?

%\begin{itemize}
%\item $i = \iPass$.
%\item $i = \iReturn{v}$.
%\item $\mm{m}{i}{m'}{i'}$.
%\item $\msi{m}{i} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $e = v$.
%\item $\mm{m}{e}{m'}{e'}$.
%\item $\msi{m}{e} → Ω$.
%\end{itemize}

\paragraph{\textsc{Pass}  :} %{{{
Ce cas est trivial.
% }}}
\paragraph{\textsc{Return}:} %{{{
Partant de $i = \iReturn{e}$, on applique le lemme d'inversion. Il vient :
$∃ t_t, Γ ⊢ e : t_r$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$. Alors $i = \iReturn{v}$, ce qui nous permet de conclure.

\item $\mm{m}{e}{m'}{e'}$.
Alors en appliquant \textsc{Ctx} avec
$C = \iReturn{\ctxEmpty}$, on conclut que
$\mm{m}{\iReturn{e}}{m'}{\iReturn{e'}}$.

\item $\msi{m}{e} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.

\end{itemize}
% }}}
\paragraph{\textsc{Seq}   :} %{{{
Avec $i = i_1;i_2$, on applique l'hypothèse de récurrence à $i_1$.

\begin{itemize}
\item $i_1 = \iPass$. On peut donc appliquer la règle \textsc{Seq} et donc
$\mms{i}{i_2}$.

\item $i_1 = \iReturn{v}$. Alors on peut appliquer la règle \textsc{Return}:
    $\mms{i}{\iReturn{v}}$.

\item $\mm{m}{i_1}{m'}{i_1'}$. Soit $C = \ctxEmpty;i_2$. Par \textsc{Ctx} il
    vient $\mm{m}{i}{m'}{i_1';i_2}$.
    \item $\msi{m}{i_1} → Ω$. Avec ce même $C$ dans \textsc{Eval-Err} on trouve
    $\msi{m}{i} → Ω$.

\end{itemize}
% }}}
\paragraph{\textsc{Exp}   :} %{{{

Ici $i = e$. On peut appliquer l'hypothèse de récurrence à $e$ qui est ``plus
petit'' que $i$ ($i \gramisa e$ introduit un constructeur implicite).

\begin{itemize}
\item $e = v$. Alors on peut appliquer \textsc{Exp}: $\mms{e}{\iPass}$.
\item $\mm{m}{e}{m'}{e'}$. Alors $\mm{m}{i}{m'}{e'}$ (cela revient à appliquer
    \textsc{Ctx} au constructeur implicite mentionné ci-dessus).
\item $\msi{m}{e} → Ω$. C'est-à-dire $\msi{m}{i} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Decl}  :} %{{{

Ici $i = \iDecl{x}{e}{i'}$. On commence par appliquer l'hypothèse de récurrence
à $e$.

\begin{itemize}
\item $e = v$. On applique alors l'hypothèse de récurrence à $i$ sous
    $Γ' = Γ, x:t$ et avec $m' = \cExtend{m}{x}{v}$.

    \begin{itemize}
    \item $i = \iPass$. Dans ce cas la règle \textsc{Decl-Pass} s'applique.

    \item $i = \iReturn{v}$. Idem avec \textsc{Decl-Return}.

    \item $\mm{m'}{i}{m''}{i'}$. Par \textsc{Decl-Ctx} il vient
        $\mm{m}{\iDecl{x}{v}{i}}{m'''}{\iDecl{x}{v'}{i'}}$ où
       $v' = m''[(0, x)]_A$
       et
       $m''' = m'' - x$.

    \item $\msi{m'}{i'} → Ω$. On applique \textsc{Decl-Err}.

    \end{itemize}

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iDecl{x}{\ctxEmpty}$ et on conclut avec
    la règle \textsc{Ctx}.
\item $\msi{m}{e} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}



% }}}
\paragraph{\textsc{If}    :} %{{{
Ici $i = \iIf{e}{i_1}{i_2}$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$.

    Si $v ≠ 0$, on applique \textsc{If-True}. Dans le cas contraire, on
    applique \textsc{If-False}.

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iIf{\ctxEmpty}{i_1}{i_2}$ et on conclut
    avec \textsc{Ctx}.

\item $\msi{m}{e} → Ω$. Avec ce même $C$ et \textsc{Eval-Err}.
\end{itemize}

% }}}
\paragraph{\textsc{While} :} %{{{

Ce cas est direct: la règle \textsc{While} peut toujours s'appliquer.

% }}}
\jolibreak
  \paragraph{\textsc{Cst-Int}:} % {{{
$e$ est alors de la forme $n$, qui est une valeur.

% TODO en fait n → \widehat{n} non? idem pour float null unit
%}}}
  \paragraph{\textsc{Cst-Float}:} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null}:} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit}:}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Fun}:} % {{{

Ce cas est direct: la règle \textsc{Exp-Fun} s'applique.

%}}}
  \paragraph{\textsc{Op-Int}:} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$: alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro ($ \opbin ∈ \{ / ; \% ; /. \} $ et
          $ v_2 = 0 $) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float}:} % {{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Eq}:} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Unop-Plus-Int}:} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$:

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est-à-dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not}:}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Addr}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. Dans le cas où $lv =
φ$, on peut appliquer \textsc{Exp-AddrOf}.

%}}}
\paragraph{\textsc{Set}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$. On applique l'hypothèse de récurrence à $e$.

    \begin{itemize}
    \item $e = v$. Alors on peut appliquer \textsc{Exp-Set}.

    \item $\mm{m}{e}{m'}{e'}$. On conclut avec $C = φ ← \ctxEmpty$.
    \item $\msi{m}{e} → Ω$. Idem.
    \end{itemize}

\item $\mm{m}{lv}{m'}{lv'}$. On conclut avec $C = \ctxEmpty ← e$.
\item $\msi{m}{lv} → Ω$. Idem.

\end{itemize}

%}}}
\paragraph{\textsc{Array}:} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants:

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$.
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$.
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$.
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct}:} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \eStruct{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n}$; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call}:} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \eFun{\vec{a}}{i}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \eFun{\vec{a}}{i}$.

Soient $Γ' = (Γ - \vRet), a_1 : t_1, …, a_n : t_n, \vRet : t$
et
$m_1 = \mathrm{Push} (m_0, (a_1 ↦ v_1, … a_n ↦ v_n))$.

On applique alors l'hypothèse de récurrence à $Γ'$, $m_1$ et $i$ (le lemme
d'inversion garantit que $Γ' ⊢ i$).

\begin{itemize}
\item $i = \iPass$. Alors on peut appliquer \textsc{Exp-Return-Unit}.

\[ \irule{Exp-Return-Unit}
      { m' = \cCleanup{m}}
      { \mm{m}{\eFun{a_1, …, a_n}{\iPass} (v_1, …, v_n)}
           {m'}{\eUnit}
      }
\]

\item $i = \iReturn{v}$. Idem avec \textsc{Exp-Return}.

\[ \irule{Exp-Return}
      { m' = \cCleanup{m}}
      { \mm{m}{\eFun{a_1, …, a_n}{\iReturn{v}} (v_1, …, v_n)}
           {m'}{v}
      }
\]

\item $\mm{m_1}{i}{m_2}{i'}$.

    Alors on peut appliquer \textsc{Exp-Call-Ctx}.

\[
    \irule{Exp-Call-Ctx}
        { m_1 = \mathrm{Push} (m_0, (a_1 ↦ v_1, … a_n ↦ v_n))
       \\ \mm{m_1}{i}{m_2}{i'}
       \\ ∀ i ∈ [1;n], v'_i = m_2[(0, a_i)]_A
       \\ m_3 = \mathrm{Pop} (m_2)
        }
        { \mm{m_0}{\eFun{a_1, …, a_n}{i} (v_1, …, v_n) }
          { m_3 }{\eFun{a_1, …, a_n}{i'} (v'_1, …, v'_n) }
        }
\]

\item $\msi{m}{i} → Ω$. On peut alors appliquer \textsc{Exp-Call-Err}.

\[ \irule{Exp-Call-Err}
    { m' = \mathrm{Push}(m, (a_1 ↦ v_1, …, a_n ↦ v_n))
   \\ \msi{m'}{i} → Ω
    }
    { \msi{m}{\eFun{a_1, …, a_n}{i} (v_1, …, v_n) } → Ω }
\]

\end{itemize}

% TODO remettre ces règles à leur place

%}}}
\jolibreak
\paragraph{\textsc{Lv-Var}:}%{{{

Le but est d'appliquer \textsc{Phi-Var}. La seule condition pour que cela soit
possible est que $\cLookup{x}{m}$ renvoie une adresse et non $\serr{var}$.

Puisque $Γ ⊢ x : t$, on en déduit que $x:t ∈ Γ$ (par le lemme d'inversion), donc
que $x ∈ \cDom{Γ}$. Comme $\mcomp{Γ}{m}$, $x ∈ \{ \cVarname{a} / a ∈
\cVisible{m} \}$, donc $∃ a ∈ \cVisible{m}. x = \cVarname{a}$ et
$\cLookup{x}{m}$ ne renvoie donc pas d'erreur.

%}}}
\paragraph{\textsc{Lv-Deref}:}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ (vue en tant qu'expression).

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que $v = φ$ ou $v = \eNull$.

  Dans le premier cas, la règle \textsc{Phi-Deref} s'applique:
  $\mms{e}{\widehat{*}φ}$.
  Dans le second, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index}:} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \eArray{v_1; …; v_p}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\eArray{v_1; …; v_p}\widehat{[n]}} $.
Deux cas sont à distinguer:
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

% TODO attention à l'off by one

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field}:}%{{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.

\end{itemize}

%}}}
\paragraph{\textsc{Ptr-Arith}:} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le lemme~\ref{lemma:canon}:

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}): si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\end{proof}
% TODO vérifier que tous les contextes sont présents dans la figure
% TODO vérifier que tous les cas sont dans le lemme d'inversion
\section{Préservation}
\label{proof:preservation}

(théorème~\ref{thm:preservation})


\begin{proof}

On procède par induction sur la forme de l'expression $e$.

\paragraph{ Constante }             $c$ % {{{ TODO
On détaille par exemple le cas d'une constante entière.

D'une part, $Γ ⊢ e : t$ donc d'après le lemme~\ref{lemma:canon}, $t = \tInt$.

D'autre part, la seule règle d'évaluation possible est \textsc{Exp-Cst} qui
évalue en une constante entière.

% TODO check si c'est vrai aussi pour Null

% }}}
\paragraph{ Accès mémoire }         $ lv $ % {{{ TODO

% }}}
\paragraph{ Opération unaire }      $ \opun~e $ % {{{ TODO


% }}}
\paragraph{ Opération binaire }     $ e~\opbin~e $ % {{{ TODO

% }}}
\paragraph{ Pointeur }              $ \& lv $ % {{{ TODO

% }}}
\paragraph{ Affectation }           $ lv ← e $ % {{{ TODO

% }}}
\paragraph{ Structure }             $ \eStruct{ l_1 : e_1 ; ; l_n : e_n } $ % {{{ TODO

% }}}
\paragraph{ Tableau }               $ \eArray{e_1 ;…; e_n} $ % {{{ TODO

% }}}
\paragraph{ Fonction }              $ f $ % {{{ TODO

% }}}
\paragraph{ Appel de fonction }     $ e (e_1, …, e_n) $ % {{{ TODO

% }}}

\end{proof}

\section{Progrès pour les types qualifiés}
\label{proof:progres-qualif}

(théorème~\ref{thm:progres-qual})

\begin{proof}

On procède de la même manière que pour le théorème~\ref{thm:progres} (prouvé en
annexe~\ref{proof:progres}). En fait, puisque le schéma de preuve porte sur les
règles de typage, il suffit de traiter les cas supplémentaires.

% TODO qu'est-ce qui empêche *♢x ?

\paragraph{\textsc{Taint} :} % {{{

Alors $e = \eTaint{lv}$. On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors on peut appliquer \textsc{Expr-Tainted}.
\item $\mm{m}{lv}{m'}{lv'}$. On conclut en utilisant \textsc{Ctx} avec $C =
\eTaint{\ctxEmpty}$.
\item $\msi{m}{lv} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.
\end{itemize}

% }}}
\paragraph{\textsc{GetU} :} % {{{ TODO
\[  \disprule{GetU} \]

\[ \semrule{User-Get-OK} \]

\[ \semrule{User-Get-Err} \]
% }}}
\paragraph{\textsc{PutU} :} % {{{ TODO
\[  \disprule{PutU} \]

\[ \semrule{User-Put-OK} \]

\[ \semrule{User-Put-Err} \]
% }}}
\paragraph{\textsc{AddrOf-Kernel} :} % {{{ TODO
\[  \disprule{AddrOf-Kernel} \]

\[  \semrule{Exp-AddrOf} \]
% }}}
\paragraph{\textsc{Lv-Deref-Kernel} :} % {{{ TODO
\[  \disprule{Lv-Deref-Kernel} \]
% }}}
\paragraph{\textsc{Ptr-Arith-User} :} % {{{ TODO
\[  \disprule{Ptr-Arith-User} \]
% }}}

% TODO vérifier que tous les cas de contexte sont là

\end{proof}

\section{Préservation pour les types qualifiés}
\label{proof:preservation-qualif}

(théorème~\ref{thm:preservation-qualif})

% TODO
