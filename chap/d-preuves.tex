\section{Preuve du théorème~\ref{thm:progres}}

\label{proof:progres}

\begin{proof}

  On procède par induction sur la dérivation de $Γ ⊢ e : t$, et plus précisément
  sur la dernière règle utilisée.

  \paragraph{\textsc{Cst-Int} :} % {{{
$e$ est alors de la forme $n$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Float} :} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null} :} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit} :}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Lv-Var} :}%{{{

Puisque $(x, t) ∈ Γ$ $\mcomp{Γ}{m}$, il existe $(x ↦ v) ∈ m$. La règle
d'évaluation \textsc{Phi-Var} s'applique donc.

% TODO prouver le coup du lookup
%}}}
\paragraph{\textsc{Lv-Deref} :}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ (vu en tant qu'expression).

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que $v = φ$ ou $v = \eNull$.

  Dans le premier cas, la règle \textsc{Phi-Deref} s'applique :
  $\mms{e}{\widehat{*}φ}$.
  Dans le second, puisque $\msi{m}{*\eNull} → Ω_{ptr}$, on a
  $\msi{m}{e} → Ω_{ptr}$.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index} :} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \{v_1; …; v_p\}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$. Deux cas sont à distinguer :
si $n ∈ [0;p-1]$, la règle \textsc{Phi-Array} s'applique et
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
% TODO réécrire bien Phi-Array
% TODO attention à l'off by one
Sinon, $\msi{m}{lv[e]} → Ω_{array}$.
% TODO pourquoi ?

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field} :} % TODO
  \paragraph{\textsc{Op-Int} :} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$ : alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro (
          $ \opbin ∈ \{ / ; \% ; /. \} $
          et
          $ v_2 = 0 $
          ) où alors $v_1~\widehat{\opbin}~v_2 = Ω_{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → Ω_{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float} :} % {{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Eq} :} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO expand un peu
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Comparable} :} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO expand un peu
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Unop-Plus-Int} :} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$ :

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est à dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
% TODO écrire la règle
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not} :}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Ptr-Arith} :} % %{{{ TODO

\[ \left( \disprule{Ptr-Arith} \right) \]

%}}}
\paragraph{\textsc{Addr} :} % {{{ TODO

\[ \left( \disprule{Addr} \right) \]

%}}}
\paragraph{\textsc{Set} :} % {{{ TODO

\[ \left( \disprule{Set} \right) \]

%}}}
\paragraph{\textsc{Array} :} % {{{ TODO

\[ \left( \disprule{Array} \right) \]

%}}}
\paragraph{\textsc{Struct} :} % {{{ TODO

\[ \left( \disprule{Struct} \right) \]

%}}}
\paragraph{\textsc{Call} :} % {{{ TODO

\[ \left( \disprule{Call} \right) \]

%}}}
\paragraph{\textsc{Fun} :} % {{{ TODO

\[ \left( \disprule{Fun} \right) \]

%}}}
% TODO vérifier qu'il n'y a pas d'autre règle
% TODO général : que désigne e. Ex avec lv[e]
\end{proof}

\section{Preuve du théorème~\ref{thm:preservation}}
\label{proof:preservation}.

% TODO
