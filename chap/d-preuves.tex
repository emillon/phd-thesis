On présente ici les preuves de certains résultats établis dans le manuscrit: le
caractère bien fondé de la composition de deux lentilles, et les théorèmes de
sûreté du typage.

\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}

On cherche à prouver que si 
$ℒ_1 ∈ \setLens{A}{B}$
et
$ℒ_2 ∈ \setLens{B}{C}$, alors
$ℒ = ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$ ($\ggg$ est la composition de lentilles,
définie page~\pageref{def:lens-comp}).

Il suffit pour cela d'établir les trois propriétés caractéristiques qui
définissent les lentilles: \textsc{PutPut}, \textsc{GetPut} et \textsc{PutGet}.
Cela est essentiellement calculatoire: on utilise la définition de $\ggg$ et les
propriétés caractéristiques sur $ℒ_1$ et $ℒ_2$.

\paragraph{PutPut}%{{{

\begin{conteq}[onecolumn]
  \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{GetPut} sur $ℒ_1$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{PutPut} sur $ℒ_2$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    }
& \textsc{PutPut} sur $ℒ_1$ \\
= \lensPut{ℒ}{a'}{r}
& définition de $\ggg$ \\
\end{conteq}
%}}}

\paragraph{GetPut}%{{{

{

\def\xa{
  \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    }
  }


\def\xb{
  \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r }
}

\def\xab{ définition de \lensGetX{ℒ} }

\def\xc{
  \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
                    {
                      \lensGet{ℒ_2}
                        {
                          \lensGet{ℒ_1}{r}
                        }
                    }
                    { \lensGet{ℒ_1}
                              {r}
                    }
          }
          {r}
}

\def\xbc{ définition de \lensPutX{ℒ} }

\def\xd{
  \lensPut{ℒ_1}
          {
            \lensGet{ℒ_1}{r}
          }
          {r}
}

\def\xcd{ \textsc{GetPut} sur $ℒ_2$ }

\def\xe{r}

\def\xde{\textsc{GetPut} sur $ℒ_1$}

\begin{conteq}
    \xa{} \\
  = \xb{} & \xab{} \\
  = \xc{} & \xbc{} \\
  = \xd{} & \xcd{} \\
  = \xe{} & \xde{}
\end{conteq}

}

%}}}

\paragraph{PutGet}%{{{

\begin{conteq}
  \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    }
& définition de \lensGetX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    }
& définition de \lensPutX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    }
& \textsc{PutGet} sur $ℒ_1$ \\
= a
& \textsc{PutGet} sur $ℒ_2$ \\
\end{conteq}
%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

On rappelle l'énoncé du théorème~\ref{thm:progres}.

\begin{theorem}[Progrès]

Supposons que $Γ ⊢ i$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.

Alors l'un des cas suivants est vrai:
\begin{itemize}
\item $i = \iPass$
\item $∃v, i = \iReturn{v}$
\item $∃ (i', m'), \mm{m}{i}{m'}{i'}$
\item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{i} → Ω$
\end{itemize}

\jolibreak

  Supposons que $Γ ⊢ e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivant est vrai:

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}

\jolibreak

Supposons que $Γ ⊢ lv : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.

Alors l'un des cas suivants est vrai:
\begin{itemize}
\item $∃φ, lv = φ$
\item $∃ (lv', m'), \mm{m}{lv}{m'}{lv'}$
\item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{lv} → Ω$
\end{itemize}

\end{theorem}

C'est-à-dire, soit:

\begin{itemize}
  \item l'entité (instruction, expression ou valeur gauche) est complètement
évaluée.
  \item un pas d'évaluation est possible.
  \item une erreur de division, tableau ou pointeur se produit.
\end{itemize}

\begin{proof}

On procède par induction sur la dérivation du jugement de typage. Puisque les
jugements $Γ ⊢ i$, $Γ ⊢ e : t$ et $Γ ⊢ lv : t$ sont interdépendants, on traite
tous les cas par récursion mutuelle.

Le squelette de cette preuve est une analyse de cas selon la dernière règle
utilisée. La plupart des cas ont la même forme: on utilise l'hypothèse de
récurrence sur les sous-éléments syntaxiques (en appliquant éventuellement le
lemme~\ref{lemma:inversion} d'inversion pour établir qu'ils sont bien typés).
Dans le cas \enquote{valeur}, on appelle une règle qui permet de transformer une
opération syntaxique en opération sémantique (par exemple, on transforme le $+$
unaire en un $\widehat{+}$ sémantique). Dans le cas \enquote{évaluation}, on
applique la règle \textsc{Ctx} avec un contexte particulier qui permet de passer
d'un jugement $\mm{m}{a}{m'}{a'}$ à un jugement $\mm{m}{b}{m'}{b'}$ (où $a$
apparaît dans $b$). Enfin, dans le cas \enquote{erreur}, on utilise
\textsc{Eval-Err} avec ce même contexte $C$.

Ceci est valable pour la majorité des cas. Il faut faire attention en
particulier aux opérations sémantiques qui peuvent produire des erreurs (comme
la division, ou l'opérateur $\phxx\cLookup$).

%\begin{itemize}
%\item $i = \iPass$.
%\item $i = \iReturn{v}$.
%\item $\mm{m}{i}{m'}{i'}$.
%\item $\msi{m}{i} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $e = v$.
%\item $\mm{m}{e}{m'}{e'}$.
%\item $\msi{m}{e} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $lv = φ$.
%\item $\mm{m}{lv}{m'}{lv'}$.
%\item $\msi{m}{lv} → Ω$.
%\end{itemize}

\subsection*{Instructions}

\paragraph{\textsc{Pass}  :} %{{{
Ce cas est immédiat.
% }}}
\paragraph{\textsc{Return}:} %{{{

Partant de $i = \iReturn{e}$, on applique le lemme d'inversion. Il nous donne
l'existence de $t$ tel que $Γ ⊢ e : t$. On applique alors l'hypothèse de
récurrence à $e$.

\begin{itemize}
\item $e = v$. Alors $i = \iReturn{v}$, ce qui nous permet de conclure.

\item $\mm{m}{e}{m'}{e'}$.
Alors en appliquant \textsc{Ctx} avec
$C = \iReturn{\ctxEmpty}$, on conclut que
\linebreak
$\mm{m}{\iReturn{e}}{m'}{\iReturn{e'}}$.

\item $\msi{m}{e} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.

\end{itemize}
% }}}
\paragraph{\textsc{Seq}   :} %{{{
Avec $i = i_1;i_2$, on applique l'hypothèse de récurrence à $i_1$.

\begin{itemize}
\item $i_1 = \iPass$. On peut donc appliquer la règle \textsc{Seq} et donc
$\mms{i}{i_2}$.

\item $i_1 = \iReturn{v}$. Alors on peut appliquer la règle \textsc{Return}:
    $\mms{i}{\iReturn{v}}$.

\item $\mm{m}{i_1}{m'}{i_1'}$. Soit $C = \ctxEmpty;i_2$. Par \textsc{Ctx} il
    vient $\mm{m}{i}{m'}{i_1';i_2}$.
    \item $\msi{m}{i_1} → Ω$. Avec ce même $C$ dans \textsc{Eval-Err} on trouve
    $\msi{m}{i} → Ω$.

\end{itemize}
% }}}
\paragraph{\textsc{Exp}   :} %{{{

Ici $i = e$. On peut appliquer l'hypothèse de récurrence à $e$ qui est
\enquote{plus petit} que $i$ ($i \gramisa e$ introduit un constructeur
implicite).

\begin{itemize}
\item $e = v$. Alors on peut appliquer \textsc{Exp}: $\mms{e}{\iPass}$.
\item $\mm{m}{e}{m'}{e'}$. Alors $\mm{m}{i}{m'}{e'}$ (cela revient à appliquer
    \textsc{Ctx} au constructeur implicite mentionné ci-dessus).
\item $\msi{m}{e} → Ω$. C'est-à-dire $\msi{m}{i} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Decl}  :} %{{{

Ici $i = \iDecl{x}{e}{i'}$. On commence par appliquer l'hypothèse de récurrence
à $e$.

\begin{itemize}
\item $e = v$. On applique alors l'hypothèse de récurrence à $i'$ sous
    $Γ' = \extendLocal{Γ}{x}{t}$ et avec $m' = \cExtend{m}{x}{v}$.

    \begin{itemize}
    \item $i' = \iPass$. Dans ce cas la règle \textsc{Decl-Pass} s'applique.

    \item $i' = \iReturn{v}$. Idem avec \textsc{Decl-Return}.

    \item $\mm{m'}{i'}{m''}{i''}$. On peut alors appliquer la règle
          \textsc{Decl-Ctx}.

    \item $\msi{m'}{i'} → Ω$. On applique \textsc{Decl-Err}.

    \end{itemize}

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iDecl{x}{\ctxEmpty}{i'}$ et on conclut avec
    la règle \textsc{Ctx}.
\item $\msi{m}{e} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}



% }}}
\paragraph{\textsc{If}    :} %{{{
Ici $i = \iIf{e}{i_1}{i_2}$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$.

    Si $v ≠ 0$, on applique \textsc{If-True}. Dans le cas contraire, on
    applique \textsc{If-False}.

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iIf{\ctxEmpty}{i_1}{i_2}$ et on conclut
    avec \textsc{Ctx}.

\item $\msi{m}{e} → Ω$. Avec ce même $C$ et \textsc{Eval-Err}.
\end{itemize}

% }}}
\paragraph{\textsc{While} :} %{{{

Ce cas est direct: on applique la règle d'évaluation \textsc{While}.

% }}}

\subsection*{Expressions}

  \paragraph{\textsc{Cst-Int}:} % {{{
$e$ est alors de la forme $n$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Float}:} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null}:} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit}:}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Fun}:} % {{{

Ce cas est direct: la règle \textsc{Exp-Fun} s'applique.

%}}}
  \paragraph{\textsc{Op-Int}:} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$: alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro ($ \opbin ∈ \{ / ; \% ; /. \} $ et
          $ v_2 = 0 $) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.
          Notons que comme les opérandes sont bien typées, $\serr{typ}$ ne peut pas être levée.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    \linebreak
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float}:} % {{{
Ce cas est similaire à \textsc{Op-Int}.
%}}}
\paragraph{\textsc{Op-Eq}:} %{{{
Ce cas est similaire à \textsc{Op-Int}.
%}}}
\paragraph{\textsc{Unop-Plus-Int}:} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$:

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est-à-dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient \linebreak $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not}:}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Addr}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. Dans le cas où $lv =
φ$, on peut appliquer \textsc{Exp-Addr}.

%}}}
\paragraph{\textsc{Set}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$. On applique l'hypothèse de récurrence à $e$.

    \begin{itemize}
    \item $e = v$. Alors on peut appliquer \textsc{Exp-Set}.

    \item $\mm{m}{e}{m'}{e'}$. On conclut avec $C = φ ← \ctxEmpty$.
    \item $\msi{m}{e} → Ω$. Idem.
    \end{itemize}

\item $\mm{m}{lv}{m'}{lv'}$. On conclut avec $C = \ctxEmpty ← e$.
\item $\msi{m}{lv} → Ω$. Idem.

\end{itemize}

%}}}
\paragraph{\textsc{Array}:} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants:

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$.
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$.
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$.
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct}:} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \eStruct{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n}$; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call}:} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \eFun{\vec{a}}{i}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \eFun{\vec{a}}{i}$.

Soient $Γ' = (Γ_G, [a_1 : t_1, …, a_n : t_n, \vRet : t])$
et
$m_1 = \cPush{m_0}{(a_1 ↦ v_1, … a_n ↦ v_n)}$
où $Γ = (Γ_G, Γ_L)$.

On applique alors l'hypothèse de récurrence à $Γ'$, $m_1$ et $i$ (le lemme
d'inversion garantit que $Γ' ⊢ i$).

\begin{itemize}
\item $i = \iPass$. Ce cas est impossible puisqu'on prend l'hypothèse que les
fonctions se terminent par une instruction $\iReturn{\cdot}$
(page~\pageref{page:return-fonction}).

\item $\mm{m_1}{i}{m_2}{i'}$.

    Alors on peut appliquer \textsc{Exp-Call-Ctx}.

\item $\msi{m}{i} → Ω$. On peut alors appliquer \textsc{Exp-Call-Err}.

\end{itemize}

%}}}

\subsection*{Valeurs gauches}

\paragraph{\textsc{Lv-Var}:}%{{{

Le but est d'appliquer \textsc{Phi-Var}. La seule condition pour que cela soit
possible est que $\cLookup{x}{m}$ renvoie une adresse et non $\serr{var}$.

Puisque $Γ ⊢ x : t$, on peut appliquer le lemme~\ref{lemma:var-typ}: $x$ est
soit une variable locale, soit une globale. Dans ces deux cas, $\cLookup{x}{m}$
renvoie une adresse correcte.

%}}}
\paragraph{\textsc{Lv-Deref}:}%{{{

  Appliquons l'hypothèse de récurrence à $e$ vue en tant qu'expression.

\begin{itemize}
\item
  $e = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que
  $v = \eNull$
  ou
  $v = \widehat{\&}~φ$.

  Dans le premier cas, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

  Dans le second cas, \textsc{Phi-Deref} s'applique.

\item
  $\mm{m}{e}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{e} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index}:} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \eArray{v_1; …; v_p}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\eArray{v_1; …; v_p}\widehat{[n]}} $.
Deux cas sont à distinguer:
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field}:}%{{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.

\end{itemize}

%}}}
\paragraph{\textsc{Ptr-Arith}:} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le lemme~\ref{lemma:canon}:

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}): si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\end{proof}

\section{Préservation}
\label{proof:preservation}

On rappelle l'énoncé du théorème~\ref{thm:preservation}.

\begin{theorem}[Préservation]

Soient $Γ$ un environnement de typage, et $m$ un état mémoire tels que
$\mcomp{Γ}{m}$.

Alors:

\begin{itemize}
\item
    Si $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{φ}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $\semtypphi{m'}{φ}{τ}$ où $\tComp{τ}{t}$.

\item
    Si $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{lv'}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $Γ ⊢ lv' : t$.

\item
    Si $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{v}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $m' ⊧ v : τ$ où $\tComp{τ}{t}$.

\item
    Si $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{e'}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $Γ ⊢ e' : t$.

\item
    Si $Γ ⊢ i$ et $\mm{m}{i}{m'}{i'}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $Γ ⊢ i'$.
\end{itemize}

  Autrement dit, si une construction est typable, alors un pas d'évaluation ne
  modifie pas son type et préserve le typage de la mémoire.

\end{theorem}

\begin{proof}

On procède par induction sur la dérivation de $\mm{m}{\cdot}{m'}{\cdot}$.
Plusieurs remarques sont à faire: d'abord, en ce qui concerne le typage de la
mémoire, il suffit de montrer que $\mcomp{Γ}{m'}$ car cela implique que
$\mcomp{Γ}{\cCleanup{m'}}$. Ensuite, la règle \textsc{Ctx} est traitée à part,
car elle peut être appliquée en contexte d'expression, d'instruction ou de
valeur gauche. Enfin la règle \textsc{Trans} ne pose pas de problème, il suffit
d'appliquer l'hypothèse de récurrence à ses prémisses.

\subsection*{Cas $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{φ}$}

\paragraph{\textsc{Phi-Deref}:} % {{{

On sait que $Γ ⊢ *~v : t$ où $v = \widehat{\&}~φ$.
Par inversion, $Γ ⊢ v : t~*$.
Alors d'après le lemme~\ref{lemma:repr}, il existe
$τ'$ tel que $m ⊧ v : τ'$ et $\tComp{τ'}{t~*}$.
Par inversion de la relation de typage sémantique,
$τ' = τ~*$ où $\tComp{τ}{t}$.
Alors par inversion de \textsc{S-Ptr}, on obtient que
$\semtypphi{m}{φ}{τ}$.

% }}}
\paragraph{\textsc{Phi-Var}, \textsc{Phi-Struct} et \textsc{Phi-Array}:} % {{{

Tout d'abord, la mémoire n'est pas modifiée donc il n'est pas nécessaire de
montrer la compatibilité de $m'$.
Ensuite, les prémisses de ces règles ont la forme $φ$ , donc le
lemme~\ref{lemma:mem-typ} s'applique avec la conclusion correcte.

% }}}

\subsection*{Cas $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{v}$}

\paragraph{\textsc{Exp-Cst}:} % {{{

Toutes les constantes sont des valeurs, donc le lemme~\ref{lemma:repr} peut
s'appliquer : $τ = \cRepr{t}$ convient.

% }}}
\paragraph{\textsc{Exp-Fun}:} % {{{

Idem: le lemme de réprésentabilité nous donne un candidat $τ = \cRepr{t}$
qui convient.

% }}}
\paragraph{\textsc{Exp-Lv}:} % {{{

Puisque $Γ ⊢ φ : t$ et $\mcomp{Γ}{m}$, on a d'après le
lemme~\ref{lemma:mem-typ}: $m ⊧ v : τ$ où $v = m[φ]$ avec $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-UnOp}:} % {{{

Il vient des définitions des différents opérateurs $\widehat{\opun}$ que
$Γ ⊢ \widehat{\opun}~v : τ$ avec $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-BinOp}:} % {{{

Idem avec les définitions des opérateurs $\widehat{\opbin}$.

% }}}
\paragraph{\textsc{Exp-Addr}:} % {{{

On peut appliquer le lemme~\ref{lemma:repr}, qui nous donne un $τ$ qui convient.

% }}}
\paragraph{\textsc{Exp-Set}:} % {{{

Deux propriétés sont à prouver. D'une part, $Γ ⊢ v : t$, et d'autre part,
$\mcomp{Γ}{m'}$ où $m' = m[φ←v]$.
Tout d'abord, le lemme d'inversion appliqué à $Γ ⊢ φ ← v : t$ nous donne que
$Γ ⊢ φ : t$ et $Γ ⊢ v : t$.
Ensuite, comme $Γ ⊢ φ : t$ et $\mcomp{Γ}{m}$, on peut appliquer le
lemme~\ref{lemma:repr}: il existe $τ$ tel que $m ⊧ v : τ$ et $\tComp{τ}{t}$.
On peut donc appliquer le lemme~\ref{lemma:mem-typ}, qui nous permet de conclure
que $\mcomp{Γ}{m'}$.

% }}}
\paragraph{\textsc{Exp-Struct}:} % {{{

Le lemme~\ref{lemma:repr} s'applique à ce cas.

% }}}
\paragraph{\textsc{Exp-Array}:} % {{{

Idem, on conclut grâce au lemme de représentabilité.

% }}}
\paragraph{\textsc{Exp-Call-Return}:} % {{{

Par inversion, il vient que
$Γ ⊢ \eFun{a_1, …, a_n}{i} : (t_1, …, t_n) → t'$
et
$∀ i ∈ [1;n], Γ ⊢ v_i : t_i$.

Posons $Γ' = (Γ_G, [a_1:t_1, …, a_n:t_n, \vRet:t])$ où $Γ = (Γ_G, Γ_L)$. Alors
par inversions successives on obtient que $Γ' ⊢ \iReturn{v}$ et $Γ' ⊢ v : t$.

Si on définit $m'' = \cPush{m}{a_1↦v_1, …, a_n↦v_n}$, alors par \textsc{M-Push}
on obtient que $\mcomp{Γ'}{m''}$. Donc, par le lemme~\ref{lemma:repr}, il existe
$τ$ tel que $m'' ⊧ v : τ$ où $\tComp{τ}{t}$.

Il reste à montrer que $m' ⊧ v' : τ$.

On distingue selon la forme de $v$. On applique un raisonnement similaire à
celui de la preuve du lemme~\ref{lemma:mem-typ}: soit $v$ est une référence au
cadre nettoyé, et dans ce cas $v' = \eNull$ et $τ$ est un type pointeur, soit
$v' = v$. Dans tous les cas on conclut car $m' ⊧ v' : τ$.

% }}}

\subsection*{Cas $Γ ⊢ i$ et $\mm{m}{i}{m'}{i'}$}

\paragraph{\textsc{Seq}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i$.
%}}}
\paragraph{\textsc{Exp}:}%{{{
D'après \textsc{Pass}, $Γ ⊢ \iPass$.
%}}}
\paragraph{\textsc{Decl-Pass}:}%{{{

$Γ ⊢ \iPass$ est immédiat, et $\mcomp{Γ}{m'}$ est établi par \textsc{M-Decl}
suivie de \linebreak \textsc{M-DeclClean}. On a bien $x ∉ Γ$ car les
déclarations de variable ne peuvent pas masquer de variables visibles existantes
(page~\pageref{page:decl-masquage}).

%}}}
\paragraph{\textsc{Decl-Return}:}%{{{

La compatibilité mémoire se démontre de la même manière que pour
\textsc{Decl-Pass}. Il reste à montrer que $Γ ⊢ \iReturn{v''}$, ce qui fait de
manière analogue au cas \textsc{Exp-Call-Return}.

%}}}
\paragraph{\textsc{Decl-Ctx}:}%{{{

On part de $Γ ⊢ \iDecl{x}{v}{i}$.
Par inversion, il existe $t$ tel que
$Γ ⊢ v : t$ et $Γ' ⊢ i$ où $Γ' = \extendLocal{Γ}{x}{t}$.

Comme $\mcomp{Γ}{m}$, le lemme~\ref{lemma:repr} s'applique : il existe
$τ$ tel que $m ⊧ v : τ$ où $\tComp{τ}{t}$.
De plus $x ∉ Γ$ car il n'y a pas de masquage (page~\pageref{page:decl-masquage}).

En appliquant \textsc{M-Decl}, on obtient donc que $\mcomp{Γ'}{m'}$.

On applique alors l'hypothèse d'induction à $\mm{m'}{i}{m''}{i'}$. Il vient que
$Γ' ⊢ i'$ et $\mcomp{Γ'}{m''}$.

On a donc $Γ' ⊢ \iDecl{x}{v'}{i'}$ par \textsc{Decl} et
$\mcomp{Γ}{\cCleanup{m'''}}$ par \textsc{M-DeclClean}.

%}}}
\paragraph{\textsc{If-False}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_f$.
%}}}
\paragraph{\textsc{If-True}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_t$.
%}}}
\paragraph{\textsc{While}:}%{{{

D'après le lemme d'inversion, $Γ ⊢ e : t$ et $Γ ⊢ i$.
Par \textsc{Seq}, on a $Γ ⊢ i ; \iWhile{e}{i}$.
Enfin par \textsc{If} il vient $Γ ⊢ \iThen{e}{i ; \iWhile{e}{i}}$.

%}}}
\paragraph{\textsc{Return}:}%{{{

Par le lemme d'inversion, $Γ ⊢ \iReturn{v}$.
%}}}
\paragraph{\textsc{Exp-Call-Ctx}:}%{{{

On sait que $Γ ⊢ \eFun{a_1, …, a_n}{i} (v_1, …, v_n)$ et
$\mcomp{Γ}{m_0}$. D'après le lemme d'inversion, il existe
$t_1, …, t_n$ tels que $∀i ∈ [1;n], Γ ⊢ v_i : t_i$,
$Γ ⊢ \eFun{a_1, …, a_n}{i} : (t_1, …, t_n) → t$, donc qu'en posant
$Γ' = (Γ_G, [a_1:t_1, …, a_n:t_n, \vRet:t])$ où $Γ = (Γ_G, Γ_L)$ on a $Γ' ⊢ i$.

D'un autre côté, il existe par le lemme~\ref{lemma:repr} des types $τ_i$ tels
que $∀ i ∈ [1;n], m_0 ⊧ v_i : τ_i$ avec $\tComp{τ_i}{t_i}$. En appliquant
\textsc{M-Push}, on a donc $\mcomp{Γ'}{m_1}$.

On peut alors appliquer l'hypothèse d'induction à $\mm{m_1}{i}{m_2}{i'}$: la
conclusion est que $Γ' ⊢ i'$ et $\mcomp{Γ'}{m_2}$. Comme $Γ' ⊢ a_i : t_i$, on
a $∀ i ∈ [1;n], Γ' ⊢ v'_i : t_i$. Donc on a bien
$Γ ⊢ \eFun{a_1, …, a_n}{i'} (v'_1, …, v'_n) : t$.

D'autre part, en appliquant \textsc{M-Pop}, on obtient que
$\mcomp{Γ}{\cCleanup{m_3}}$.

%}}}

\added{Nouveau paragraphe}

\subsection*{À propos de la règle \textsc{Ctx}}

L'application de la règle \textsc{Ctx} nécessite une explication particulière.
En effet, ce cas repose sur un lemme d'inversion des constructions typées sous
un contexte, qui est admis ici.

Par exemple, traitons le cas où le contexte $C$ est tel que son \enquote{trou}
soit une valeur gauche $lv$ et $\ctxSub{C}{lv}$ est une instruction (les autres
cas sont similaires). La règle appliquée est alors de la forme:

\[
    \irule{Ctx}
         { \mm{m}{lv}{m'}{lv'} }
         { \mm{m}{\ctxSub{C}{lv}}{m'}{\ctxSub{C}{lv'}} }
\]

Si $Γ ⊢ \ctxSub{C}{lv}$, on admet qu'il existe $Γ'$ et $t$ tels que:

\begin{itemize}
    \item $Γ' ⊢ lv : t$;
    \item Quelque soit $lv'$,
        si
        $Γ' ⊢ lv' : t$,
        alors
        $Γ ⊢ \ctxSub{C}{lv'}$.
\end{itemize}

Par exemple, pour $C = \ctxEmpty{}[2] = 1$, $Γ' = Γ$ et $t = \tInt[~]$
conviennent.
Pour $C = \iDecl{x}{0}{\ctxEmpty = 3.0}$, on prendra
$Γ' = \extendLocal{Γ}{x}{\tInt} $ et $t = \tFloat$.
Le fait de passer \enquote{sous} une déclaration ajoute une variable locale à
$Γ$, et ainsi l'ensemble des variables de $Γ'$ contient celui de $Γ$.

Pour prouver la préservation dans ce cas, on commence par appliquer l'hypothèse
de récurrence à la prémisse de \textsc{Ctx}, c'est-à-dire $\mm{m}{lv}{m'}{lv'}$.
Il vient que $Γ' ⊢ lv' : t$ et $\mcomp{Γ'}{\cCleanup{m'}}$.

D'après le précédent lemme d'inversion on en déduit que $Γ ⊢ \ctxSub{C}{lv'}$.
De plus $Γ'$ contient plus de variables que $Γ$ donc $\mcomp{Γ}{\cCleanup{m'}}$.

\end{proof}

\section{Progrès pour les extensions noyau}
\label{proof:progres-qualif}

(Théorème~\ref{thm:progres-qual})

\begin{proof}

On procède de la même manière que pour le théorème~\ref{thm:progres} (prouvé en
annexe~\ref{proof:progres}). En fait, puisque le schéma de preuve porte sur les
règles de typage, il suffit de traiter les cas supplémentaires.

\paragraph{\textsc{Addr-User} :} % {{{

Alors $e = \eTaint{lv}$. On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors on peut appliquer \textsc{Phi-User}.
\item $\mm{m}{lv}{m'}{lv'}$. On conclut en utilisant \textsc{Ctx} avec $C =
\eTaint{\ctxEmpty}$.
\item $\msi{m}{lv} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.
\end{itemize}

% }}}
\paragraph{\textsc{GetU} :} % {{{

On applique l'hypothèse de récurrence à $e_d$.

\begin{itemize}
\item $e_d = v_d$. On applique l'hypothèse de récurrence à $e_s$.

\begin{itemize}
\item $e_s = v_s$.

    D'après le lemme~\ref{lemma:canon} adapté aux extensions noyau, $v_s$ a pour
    forme $φ_s$.

    On distingue la forme de $φ_s$:

    \begin{itemize}
        \item $φ_s = \vTainted{φ}$. Alors on applique
        \textsc{User-Get-OK}. Le lemme~\ref{lemma:mem-typ} adapté aux extensions
        noyau assure que les prémisses sont correctes.

        \item $∄~φ, φ_s = \vTainted{φ}$. Alors on applique
        \textsc{User-Get-Err}.
    \end{itemize}

\item $\mm{m}{e_s}{m'}{e_s'}$. Posons $C = \uGet{v_d}{\ctxEmpty}$.
    On conclut avec \textsc{Ctx}.
\item $\msi{m}{e_s} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}

\item $\mm{m}{e_d}{m'}{e_d'}$. On applique \textsc{Ctx} avec
    $C = \uGet{\ctxEmpty}{e_s}$.

\item $\msi{m}{e_d} → Ω$. On utilise \textsc{Eval-Err} avec ce même contexte.

\end{itemize}
% }}}
\paragraph{\textsc{PutU} :} % {{{
Ce cas est similaire au cas \textsc{GetU}, en appliquant les règles
\textsc{User-Put-OK} et \textsc{User-Put-Err}.

% }}}

\deleted{Suppression du cas addr-kernel inutile}

\end{proof}

\section{Préservation pour les extensions noyau}
\label{proof:preservation-qualif}

(Théorème~\ref{thm:preservation-qualif})

De même, il suffit de prouver les cas correspondant aux nouvelles règles.

\paragraph{\textsc{Phi-User}:} % {{{

On applique le lemme de représentation, qu'on a étend avec le cas
\linebreak
$\cRepr{t~@} = \cRepr{\cRepr{t}~@}$.

% }}}
\paragraph{\textsc{User-Get-OK}:} % {{{
Tout d'abord, d'après le lemme~\ref{lemma:inv-qualif}, $t = \tInt$, donc la
préservation du type est établie car $m' ⊧ 0 : \tInt$
La compatibilité mémoire est obtenue en appliquant \textsc{M-Write}.
% }}}
\paragraph{\textsc{User-Get-Err}:} % {{{
La seule partie à prouver est la préservation, qui se fait de la même manière
que dans le cas précédent.
% }}}
\paragraph{\textsc{User-Put-OK}:} % {{{
Idem que dans le cas {\textsc{User-Put-OK}.
% }}}
\paragraph{\textsc{User-Put-Err}:} % {{{
Idem que pour \textsc{User-Get-Err}.
% }}}

% vim: spelllang=fr
