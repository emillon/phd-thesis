\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}
Pour prouver que $ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$, il suffit de prouver les trois
propriétés caractéristiques.

\paragraph{GetPut}%{{{

{

\def\xa{
  \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    }
  }


\def\xb{
  \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r }
}

\def\xab{ définition de \lensGetX{ℒ} }

\def\xc{
  \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
                    {
                      \lensGet{ℒ_2}
                        {
                          \lensGet{ℒ_1}{r}
                        }
                    }
                    { \lensGet{ℒ_1}
                              {r}
                    }
          }
          {r}
}

\def\xbc{ définition de \lensPutX{ℒ} }

\def\xd{
  \lensPut{ℒ_1}
          {
            \lensGet{ℒ_1}{r}
          }
          {r}
}

\def\xcd{ \textsc{GetPut} sur $ℒ_2$ }

\def\xe{r}

\def\xde{\textsc{GetPut} sur $ℒ_1$}

\begin{conteq}
    \xa{} \\
  = \xb{} & \xab{} \\
  = \xc{} & \xbc{} \\
  = \xd{} & \xcd{} \\
  = \xe{} & \xde{}
\end{conteq}

}

%}}}

\paragraph{PutGet}%{{{

\begin{conteq}
  \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    }
& définition de \lensGetX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    }
& définition de \lensPutX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    }
& \textsc{PutGet} sur $ℒ_1$ \\
= a
& \textsc{PutGet} sur $ℒ_2$ \\
\end{conteq}
%}}}

\paragraph{PutPut}%{{{

\begin{conteq}[onecolumn]
  \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{GetPut} sur $ℒ_1$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{PutPut} sur $ℒ_2$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    }
& \textsc{PutPut} sur $ℒ_1$ \\
= \lensPut{ℒ}{a'}{r}
& définition de $\ggg$ \\
\end{conteq}
%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

(Théorème~\ref{thm:progres})

\begin{proof}

On procède par induction sur la dérivation du jugement de typage. Puisque les
jugements $Γ ⊢ i$, $Γ ⊢ e : t$ et $Γ ⊢ lv : t$ sont interdépendants, on traite
tous les cas par récursion mutuelle.

Le squelette de cette preuve est une analyse de cas selon la dernière règle
utilisée. La plupart des cas ont la même forme: on utilise l'hypothèse de
récurrence sur les sous-élements syntaxiques. Dans le cas ``valeur'', on appelle
une règle qui permet de transformer une opération syntaxique en opération
sémantique (par exemple, on transforme le $+$ unaire en un $\widehat{+}$
sémantique). Dans le cas ``évaluation'', on applique la règle \textsc{Ctx} avec
un contexte particulier qui permet de passer d'un jugement $\mm{m}{a}{m'}{a'}$ à
un jugement $\mm{m}{b}{m'}{b'}$ (où $a$ apparaît dans $b$). Enfin, dans le cas
``erreur'', on utilise \textsc{Eval-Err} avec ce même contexte $C$.

Ceci est valable pour la majorités des cas. Il faut faire attention en
particulier aux opérations sémantiques qui peuvent produire des erreurs (comme
la division, ou l'opérateur $\phxx\cLookup$) ou aux opérations qui modifient
l'état mémoire. Dans ce cas, il faut prouver que $\mcomp{Γ}{m}$.

% TODO le plus unaire sémantique sert à rien
% TODO le moins unaire sémantique sert à rien
% TODO la règle Seq sert à rien
% TODO montrer progrès au niveau des phrases?

%\begin{itemize}
%\item $i = \iPass$.
%\item $i = \iReturn{v}$.
%\item $\mm{m}{i}{m'}{i'}$.
%\item $\msi{m}{i} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $e = v$.
%\item $\mm{m}{e}{m'}{e'}$.
%\item $\msi{m}{e} → Ω$.
%\end{itemize}

\paragraph{\textsc{Pass}  :} %{{{
Ce cas est trivial.
% }}}
\paragraph{\textsc{Return}:} %{{{
Partant de $i = \iReturn{e}$, on applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$. Alors $i = \iReturn{v}$, ce qui nous permet de conclure.

\item $\mm{m}{e}{m'}{e'}$.
Alors en appliquant \textsc{Ctx} avec
$C = \iReturn{\ctxEmpty}$, on conclut que
$\mm{m}{\iReturn{e}}{m'}{\iReturn{e'}}$.

\item $\msi{m}{e} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.

\end{itemize}
% }}}
\paragraph{\textsc{Seq}   :} %{{{
Avec $i = i_1;i_2$, on applique l'hypothèse de récurrence à $i_1$.

\begin{itemize}
\item $i_1 = \iPass$. On peut donc appliquer la règle \textsc{Pass} et donc
$\mms{i}{i_2}$.

\item $i_1 = \iReturn{v}$. Alors on peut appliquer la règle \textsc{Return}:
    $\mms{i}{\iReturn{v}}$.

\item $\mm{m}{i_1}{m'}{i_1'}$. Soit $C = \ctxEmpty;i_2$. Par \textsc{Ctx} il
    vient $\mm{m}{i}{m'}{i_1';i_2}$.
    \item $\msi{m}{i_1} → Ω$. Avec ce même $C$ dans \textsc{Eval-Err} on trouve
    $\msi{m}{i} → Ω$.

\end{itemize}
% }}}
\paragraph{\textsc{Exp}   :} %{{{
Ici $i = e$. On peut appliquer l'hypothèse de récurrence à $e$ qui est en
quelque sorte plus petit que $i$ ($i \gramisa e$ introduit un constructeur
implicite).

\begin{itemize}
\item $e = v$. Alors on peut appliquer \textsc{Exp}: $\mms{e}{\iPass}$.
\item $\mm{m}{e}{m'}{e'}$. Alors $\mm{m}{i}{m'}{e'}$ (cela revient à appliquer
    \textsc{Ctx} au constructeur implicite mentionné ci-dessus).
\item $\msi{m}{e} → Ω$. C'est-à-dire $\msi{m}{i} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Decl}  :} %{{{

Ici $i = \iDecl{x}{e}{i'}$. On commence par appliquer l'hypothèse de récurrence
à $e$.

\begin{itemize}
\item $e = v$. On applique alors l'hypothèse de récurrence à $i$.

    \begin{itemize}
    \item $i = \iPass$.

        On pose $Γ' = Γ, x:t$ ($t$ apparaît dans les hypothèses en tant que
        type de $e$) et $m' = \cExtend{m}{x}{v}$.

        Alors $\mcomp{Γ'}{m'}$. % TODO

        On peut donc appliquer l'hypothèse de récurrence à $Γ'$, $m'$, et $i'$.

        \begin{itemize}
        \item $i' = \iPass$. Dans ce cas la règle \textsc{Decl} s'applique.
            Il reste à prouver que $\mcomp{Γ'}{m'''}$ où $m''' =
            \cCleanup{m''-x}$. % TODO

        \item $i' = \iReturn{v}$. Idem avec \textsc{Decl-Return}.

        \item $\mm{m'}{i'}{m''}{i''}$. En posant $C = \iDecl{x}{v}{\ctxEmpty}$, la
            règle \textsc{Ctx} donne 

            $\mm{m'}{\iDecl{x}{v}{i'}}{m''}{\iDecl{x}{v}{i''}}$
            % TODO je suis pas convaincu que c'est un bon cas de contexte

        \item $\msi{m'}{i'} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.
        \end{itemize}

    \item $i = \iReturn{v}$. % TODO ptet ramener au cas au dessus avec Decl-Return
    \item $\mm{m}{i}{m'}{i'}$. % TODO
    \item $\msi{m}{i} → Ω$. % TODO
    \end{itemize}


\item $\mm{m}{e}{m'}{e'}$. % TODO
\item $\msi{m}{e} → Ω$. % TODO
\end{itemize}



% }}}
\paragraph{\textsc{If}    :} %{{{
Ici $i = \iIf{e}{i_1}{i_2}$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$.

    Si $v ≠ 0$, on applique \textsc{If-True}. Dans le cas contraire, on
    applique \textsc{If-False}.

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iIf{\ctxEmpty}{i_1}{i_2}$ et on conclut
    avec \textsc{Ctx}.

\item $\msi{m}{e} → Ω$. Avec ce même $C$ et \textsc{Eval-Err}.
\end{itemize}

% }}}
\paragraph{\textsc{While} :} %{{{

Ce cas est direct: la règle \textsc{While} peut toujours s'appliquer.

% }}}
\jolibreak
  \paragraph{\textsc{Cst-Int}:} % {{{
$e$ est alors de la forme $n$, qui est une valeur.

% TODO en fait n → \widehat{n} non? idem pour float null unit
%}}}
  \paragraph{\textsc{Cst-Float}:} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null}:} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit}:}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Fun}:} % {{{

Ce cas est direct: la règle \textsc{Exp-Fun} s'applique.

%}}}
  \paragraph{\textsc{Op-Int}:} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le Lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$: alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro ($ \opbin ∈ \{ / ; \% ; /. \} $ et
          $ v_2 = 0 $) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float}:} % {{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Eq}:} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Unop-Plus-Int}:} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$:

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est-à-dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not}:}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Addr}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. Dans le cas où $lv =
φ$, on peut appliquer \textsc{Exp-AddrOf}.

%}}}
\paragraph{\textsc{Set}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$. On applique l'hypothèse de récurrence à $e$.

    \begin{itemize}
    \item $e = v$. Alors on peut appliquer \textsc{Exp-Set}. Puisque l'état
        mémoire est modifié en $m' = m{[φ ← v]}_Φ$, il reste à montrer que
        $\mcomp{Γ}{m'}$. % TODO

    \item $\mm{m}{e}{m'}{e'}$. On conclut avec $C = φ ← \ctxEmpty$.
    \item $\msi{m}{e} → Ω$. Idem.
    \end{itemize}

\item $\mm{m}{lv}{m'}{lv'}$. On conclut avec $C = \ctxEmpty ← e$.
\item $\msi{m}{lv} → Ω$. Idem.

\end{itemize}

%}}}
\paragraph{\textsc{Array}:} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants:

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$.
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$.
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$.
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct}:} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \eStruct{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n}$; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call}:} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le Lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \eFun{\vec{a}}{i}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \eFun{\vec{a}}{i}$
:
\textsc{Exp-Call} s'applique alors. Cette règle modifie la mémoire :

\[ \semrule{Exp-Call} \]

Il reste à prouver que $\mcomp{Γ}{m_4}$.

% TODO

%}}}
\jolibreak
\paragraph{\textsc{Lv-Var}:}%{{{


Puisque $(x, t) ∈ Γ$ et $\mcomp{Γ}{m}$,
on peut appliquer le Lemme~\ref{lemma:invsem}. La construction $a =
\cLookup{x}{m}$ correspond bien à une adresse valide et on peut appliquer
\textsc{Phi-Var}.

% TODO mouais
%}}}
\paragraph{\textsc{Lv-Deref}:}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ (vue en tant qu'expression).

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  Lemme~\ref{lemma:canon} que $v = φ$ ou $v = \eNull$.

  Dans le premier cas, la règle \textsc{Phi-Deref} s'applique:
  $\mms{e}{\widehat{*}φ}$.
  Dans le second, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index}:} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du Lemme~\ref{lemma:canon} que
$v = \eArray{v_1; …; v_p}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
Lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\eArray{v_1; …; v_p}\widehat{[n]}} $.
Deux cas sont à distinguer:
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

% TODO attention à l'off by one

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field}:}%{{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.

\end{itemize}

%}}}
\paragraph{\textsc{Ptr-Arith}:} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le Lemme~\ref{lemma:canon}:

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}): si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\end{proof}
% TODO vérifier que tous les contextes sont présents dans la figure
\section{Préservation}
\label{proof:preservation}

(Théorème~\ref{thm:preservation})


\begin{proof}

On procède par induction sur la forme de l'expression $e$.

\paragraph{ Constante }             $c$ % {{{ TODO
On détaille par exemple le cas d'une constante entière.

D'une part, $Γ ⊢ e : t$ donc d'après le Lemme~\ref{lemma:canon}, $t = \tInt$.

D'autre part, la seule règle d'évaluation possible est \textsc{Exp-Cst} qui
évalue en une constante entière.

% TODO check si c'est vrai aussi pour Null
% TODO ajouter un typage des valeurs?

% }}}
\paragraph{ Accès mémoire }         $ lv $ % {{{ TODO

% }}}
\paragraph{ Opération unaire }      $ \opun~e $ % {{{ TODO


% }}}
\paragraph{ Opération binaire }     $ e~\opbin~e $ % {{{ TODO

% }}}
\paragraph{ Pointeur }              $ \& lv $ % {{{ TODO

% }}}
\paragraph{ Affectation }           $ lv ← e $ % {{{ TODO

% }}}
\paragraph{ Structure }             $ \eStruct{ l_1 : e_1 ; ; l_n : e_n } $ % {{{ TODO

% }}}
\paragraph{ Tableau }               $ \eArray{e_1 ;…; e_n} $ % {{{ TODO

% }}}
\paragraph{ Fonction }              $ f $ % {{{ TODO

% }}}
\paragraph{ Appel de fonction }     $ e (e_1, …, e_n) $ % {{{ TODO

% }}}

\end{proof}

\section{Progrès pour les types qualifiés}
\label{proof:progres-qualif}

(Théorème~\ref{thm:progres-qual})

% TODO

\section{Préservation pour les types qualifiés}
\label{proof:preservation-qualif}

(Théorème~\ref{thm:preservation-qualif})

% TODO
