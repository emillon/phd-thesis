\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}
Pour prouver que $ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$, il suffit de prouver les trois
propriétés caractéristiques.

\paragraph{GetPut}%{{{

\begin{align*}
& \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    } \\
= & \{ \textrm{définition de } \lensGetX{ℒ} \} \\
& \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r } \\
= & \{ \textrm{définition de } \lensPutX{ℒ} \} \\
& \lensPut
    {ℒ_1}
    {
      \lensPut
        {ℒ_2}
        {
          \lensGet{ℒ_2}
            {
              \lensGet{ℒ_1}{r}
            }
        }
        { \lensGet
            {ℒ_1}
            {r}
        }
    }
    {r} \\
= & \{ \textrm{\textsc{GetPut} sur $ℒ_2$} \} \\
& \lensPut
    {ℒ_1}
    {
      \lensGet{ℒ_1}{r}
    }
    {r} \\
= & \{ \textrm{\textsc{GetPut} sur $ℒ_1$} \} \\
& r \\
\end{align*}%}}}

\paragraph{PutGet}%{{{

\begin{align*}
& \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= & \{ \textrm{définition de } \lensGetX{ℒ} \} \\
& \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    } \\
= & \{ \textrm{définition de } \lensPutX{ℒ} \} \\
& \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    } \\
= & \{ \textrm{\textsc{PutGet} sur $ℒ_1$} \} \\
& \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    } \\
= & \{ \textrm{\textsc{PutGet} sur $ℒ_2$} \} \\
& a \\
\end{align*}%}}}

\paragraph{PutPut}%{{{

\begin{align*}
& \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= & \{ \textrm{définition de } \lensPutX{ℒ} \} \\
& \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  } \\
= & \{ \textrm{définition de } \lensPutX{ℒ} \} \\
& \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    } \\
= & \{ \textrm{\textsc{GetPut} sur $ℒ_1$} \} \\
& \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    } \\
= & \{ \textrm{\textsc{PutPut} sur $ℒ_2$} \} \\
& \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    } \\
= & \{ \textrm{\textsc{PutPut} sur $ℒ_1$} \} \\
& \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    } \\
= & \{ \textrm{définition de } \ggg \} \\
& \lensPut{ℒ}{a'}{r} \\
\end{align*}%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

On prouve de manière récursive mutuelle les
théorèmes~\ref{thm:progres}
et~\ref{thm:progres-lv}

% TODO mouais, à préciser mieux.

\begin{proof}

  On procède par induction sur la dérivation de $Γ ⊢ e : t$, et plus précisément
  sur la dernière règle utilisée.

  \paragraph{\textsc{Cst-Int} :} % {{{
$e$ est alors de la forme $n$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Float} :} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null} :} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit} :}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Lv-Var} :}%{{{

Puisque $(x, t) ∈ Γ$ $\mcomp{Γ}{m}$, il existe $(x ↦ v) ∈ m$. La règle
d'évaluation \textsc{Phi-Var} s'applique donc.

% TODO prouver le coup du lookup
%}}}
\paragraph{\textsc{Lv-Deref} :}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ (vue en tant qu'expression).

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que $v = φ$ ou $v = \eNull$.

  Dans le premier cas, la règle \textsc{Phi-Deref} s'applique :
  $\mms{e}{\widehat{*}φ}$.
  Dans le second, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index} :} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \{v_1; …; v_p\}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\{v_1; …; v_p\}\widehat{[n]}} $.
Deux cas sont à distinguer :
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

% TODO attention à l'off by one

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field} :}%{{{

On applique l'hypothèse de récurrence du théorème~\ref{thm:progres-lv} à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.
% TODO Ctx-Lv en fait

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.
% TODO Pas une sorte de Err-Lv ?

\end{itemize}

%}}}
  \paragraph{\textsc{Op-Int} :} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$ : alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro (
          $ \opbin ∈ \{ / ; \% ; /. \} $
          et
          $ v_2 = 0 $
          ) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float} :} % {{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Eq} :} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO expand un peu
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Comparable} :} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO expand un peu
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Unop-Plus-Int} :} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$ :

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est à dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
% TODO écrire la règle
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float} :} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not} :}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Ptr-Arith} :} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le lemme~\ref{lemma:canon} :

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}) : si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\paragraph{\textsc{Addr} :} % {{{ TODO

\[ \left( \disprule{Addr} \right) \]

On applique l'hypothèse de récurrence du théorème~\ref{thm:progres-lv} à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. On détaille le cas où
$lv =  φ$.

% TODO même remarques sur les règles que Lv-Field

\[ \left( \semrule{Exp-AddrOf} \right) \]

% TODO expliquer un peu mieux

%}}}
\paragraph{\textsc{Set} :} % {{{ TODO

\[ \left( \disprule{Set} \right) \]

%}}}
\paragraph{\textsc{Array} :} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants :

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$
  .
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$
  .
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$
  .
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct} :} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n\}$ ; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call} :} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \mathrm{fun} (\vec{a}) \{i\}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \mathrm{fun} (\vec{a}) \{i\}$
:
\textsc{Exp-Call} s'applique alors.

% TODO cohérence mémoire

%}}}
\paragraph{\textsc{Fun} :} % {{{

Ce cas est direct : la règle \textsc{Exp-Fun} s'applique.

%}}}
% TODO vérifier qu'il n'y a pas d'autre règle
% TODO général : que désigne e. Ex avec lv[e]
% TODO prouver aussi mcomp
\end{proof}

\section{Preuve du théorème~\ref{thm:preservation}}
\label{proof:preservation}.

% TODO

\section*{TODO}

\begin{itemize}
\item
  titres dans les chapeaux buggés
\end{itemize}
