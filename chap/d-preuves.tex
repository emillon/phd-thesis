\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}
Pour prouver que $ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$, il suffit de prouver les trois
propriétés caractéristiques.

\paragraph{GetPut}%{{{

{

\def\xa{
  \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    }
  }


\def\xb{
  \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r }
}

\def\xab{ définition de \lensGetX{ℒ} }

\def\xc{
  \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
                    {
                      \lensGet{ℒ_2}
                        {
                          \lensGet{ℒ_1}{r}
                        }
                    }
                    { \lensGet{ℒ_1}
                              {r}
                    }
          }
          {r}
}

\def\xbc{ définition de \lensPutX{ℒ} }

\def\xd{
  \lensPut{ℒ_1}
          {
            \lensGet{ℒ_1}{r}
          }
          {r}
}

\def\xcd{ \textsc{GetPut} sur $ℒ_2$ }

\def\xe{r}

\def\xde{\textsc{GetPut} sur $ℒ_1$}

\begin{conteq}
    \xa{} \\
  = \xb{} & \xab{} \\
  = \xc{} & \xbc{} \\
  = \xd{} & \xcd{} \\
  = \xe{} & \xde{}
\end{conteq}

}

%}}}

\paragraph{PutGet}%{{{

\begin{conteq}
  \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    }
& définition de \lensGetX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    }
& définition de \lensPutX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    }
& \textsc{PutGet} sur $ℒ_1$ \\
= a
& \textsc{PutGet} sur $ℒ_2$ \\
\end{conteq}
%}}}

\paragraph{PutPut}%{{{

\begin{conteq}[onecolumn]
  \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{GetPut} sur $ℒ_1$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{PutPut} sur $ℒ_2$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    }
& \textsc{PutPut} sur $ℒ_1$ \\
= \lensPut{ℒ}{a'}{r}
& définition de $\ggg$ \\
\end{conteq}
%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

(théorème~\ref{thm:progres})

\begin{proof}

On procède par induction sur la dérivation du jugement de typage. Puisque les
jugements $Γ ⊢ i$, $Γ ⊢ e : t$ et $Γ ⊢ lv : t$ sont interdépendants, on traite
tous les cas par récursion mutuelle.

Le squelette de cette preuve est une analyse de cas selon la dernière règle
utilisée. La plupart des cas ont la même forme: , et on utilise l'hypothèse de
récurrence sur les sous-éléments syntaxiques (en appliquant éventuellement le
lemme~\ref{lemma:inversion} d'inversion pour établir qu'ils sont bien typés).
Dans le cas ``valeur'', on appelle une règle qui permet de transformer une
opération syntaxique en opération sémantique (par exemple, on transforme le $+$
unaire en un $\widehat{+}$ sémantique). Dans le cas ``évaluation'', on applique
la règle \textsc{Ctx} avec un contexte particulier qui permet de passer d'un
jugement $\mm{m}{a}{m'}{a'}$ à un jugement $\mm{m}{b}{m'}{b'}$ (où $a$ apparaît
dans $b$). Enfin, dans le cas ``erreur'', on utilise \textsc{Eval-Err} avec ce
même contexte $C$.

Ceci est valable pour la majorité des cas. Il faut faire attention en
particulier aux opérations sémantiques qui peuvent produire des erreurs (comme
la division, ou l'opérateur $\phxx\cLookup$).

%\begin{itemize}
%\item $i = \iPass$.
%\item $i = \iReturn{v}$.
%\item $\mm{m}{i}{m'}{i'}$.
%\item $\msi{m}{i} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $e = v$.
%\item $\mm{m}{e}{m'}{e'}$.
%\item $\msi{m}{e} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $lv = φ$.
%\item $\mm{m}{lv}{m'}{lv'}$.
%\item $\msi{m}{lv} → Ω$.
%\end{itemize}

\paragraph{\textsc{Pass}  :} %{{{
Ce cas est trivial.
% }}}
\paragraph{\textsc{Return}:} %{{{
Partant de $i = \iReturn{e}$, on applique le lemme d'inversion. Il vient :
$∃ t_t, Γ ⊢ e : t_r$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$. Alors $i = \iReturn{v}$, ce qui nous permet de conclure.

\item $\mm{m}{e}{m'}{e'}$.
Alors en appliquant \textsc{Ctx} avec
$C = \iReturn{\ctxEmpty}$, on conclut que
$\mm{m}{\iReturn{e}}{m'}{\iReturn{e'}}$.

\item $\msi{m}{e} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.

\end{itemize}
% }}}
\paragraph{\textsc{Seq}   :} %{{{
Avec $i = i_1;i_2$, on applique l'hypothèse de récurrence à $i_1$.

\begin{itemize}
\item $i_1 = \iPass$. On peut donc appliquer la règle \textsc{Seq} et donc
$\mms{i}{i_2}$.

\item $i_1 = \iReturn{v}$. Alors on peut appliquer la règle \textsc{Return}:
    $\mms{i}{\iReturn{v}}$.

\item $\mm{m}{i_1}{m'}{i_1'}$. Soit $C = \ctxEmpty;i_2$. Par \textsc{Ctx} il
    vient $\mm{m}{i}{m'}{i_1';i_2}$.
    \item $\msi{m}{i_1} → Ω$. Avec ce même $C$ dans \textsc{Eval-Err} on trouve
    $\msi{m}{i} → Ω$.

\end{itemize}
% }}}
\paragraph{\textsc{Exp}   :} %{{{

Ici $i = e$. On peut appliquer l'hypothèse de récurrence à $e$ qui est ``plus
petit'' que $i$ ($i \gramisa e$ introduit un constructeur implicite).

\begin{itemize}
\item $e = v$. Alors on peut appliquer \textsc{Exp}: $\mms{e}{\iPass}$.
\item $\mm{m}{e}{m'}{e'}$. Alors $\mm{m}{i}{m'}{e'}$ (cela revient à appliquer
    \textsc{Ctx} au constructeur implicite mentionné ci-dessus).
\item $\msi{m}{e} → Ω$. C'est-à-dire $\msi{m}{i} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Decl}  :} %{{{

Ici $i = \iDecl{x}{e}{i'}$. On commence par appliquer l'hypothèse de récurrence
à $e$.

\begin{itemize}
\item $e = v$. On applique alors l'hypothèse de récurrence à $i$ sous
    $Γ' = Γ, x:t$ et avec $m' = \cExtend{m}{x}{v}$.

    \begin{itemize}
    \item $i = \iPass$. Dans ce cas la règle \textsc{Decl-Pass} s'applique.

    \item $i = \iReturn{v}$. Idem avec \textsc{Decl-Return}.

    \item $\mm{m'}{i}{m''}{i'}$. Par \textsc{Decl-Ctx} il vient
        $\mm{m}{\iDecl{x}{v}{i}}{m'''}{\iDecl{x}{v'}{i'}}$ où
       $v' = m''[(0, x)]_A$
       et
       $m''' = m'' - x$.

    \item $\msi{m'}{i'} → Ω$. On applique \textsc{Decl-Err}.

    \end{itemize}

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iDecl{x}{\ctxEmpty}$ et on conclut avec
    la règle \textsc{Ctx}.
\item $\msi{m}{e} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}



% }}}
\paragraph{\textsc{If}    :} %{{{
Ici $i = \iIf{e}{i_1}{i_2}$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$.

    Si $v ≠ 0$, on applique \textsc{If-True}. Dans le cas contraire, on
    applique \textsc{If-False}.

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iIf{\ctxEmpty}{i_1}{i_2}$ et on conclut
    avec \textsc{Ctx}.

\item $\msi{m}{e} → Ω$. Avec ce même $C$ et \textsc{Eval-Err}.
\end{itemize}

% }}}
\paragraph{\textsc{While} :} %{{{

Ce cas est direct: la règle \textsc{While} peut toujours s'appliquer.

% }}}
\jolibreak
  \paragraph{\textsc{Cst-Int}:} % {{{
$e$ est alors de la forme $n$, qui est une valeur.

% TODO en fait n → \widehat{n} non? idem pour float null unit
%}}}
  \paragraph{\textsc{Cst-Float}:} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null}:} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit}:}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Fun}:} % {{{

Ce cas est direct: la règle \textsc{Exp-Fun} s'applique.

%}}}
  \paragraph{\textsc{Op-Int}:} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$: alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro ($ \opbin ∈ \{ / ; \% ; /. \} $ et
          $ v_2 = 0 $) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float}:} % {{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Op-Eq}:} %{{{
Ce cas est similaire à \textsc{Op-Int}.
% TODO quid du lemme d'inversion (premiere ligne de Op-Int)?
%}}}
\paragraph{\textsc{Unop-Plus-Int}:} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$:

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est-à-dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not}:}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Addr}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. Dans le cas où $lv =
φ$, on peut appliquer \textsc{Exp-AddrOf}.

%}}}
\paragraph{\textsc{Set}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$. On applique l'hypothèse de récurrence à $e$.

    \begin{itemize}
    \item $e = v$. Alors on peut appliquer \textsc{Exp-Set}.

    \item $\mm{m}{e}{m'}{e'}$. On conclut avec $C = φ ← \ctxEmpty$.
    \item $\msi{m}{e} → Ω$. Idem.
    \end{itemize}

\item $\mm{m}{lv}{m'}{lv'}$. On conclut avec $C = \ctxEmpty ← e$.
\item $\msi{m}{lv} → Ω$. Idem.

\end{itemize}

%}}}
\paragraph{\textsc{Array}:} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants:

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$.
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$.
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$.
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct}:} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \eStruct{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n}$; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call}:} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \eFun{\vec{a}}{i}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \eFun{\vec{a}}{i}$.

Soient $Γ' = (Γ - \vRet), a_1 : t_1, …, a_n : t_n, \vRet : t$
et
$m_1 = \mathrm{Push} (m_0, (a_1 ↦ v_1, … a_n ↦ v_n))$.

On applique alors l'hypothèse de récurrence à $Γ'$, $m_1$ et $i$ (le lemme
d'inversion garantit que $Γ' ⊢ i$).

\begin{itemize}
\item $i = \iPass$. Alors on peut appliquer \textsc{Exp-Return-Unit}.

\[ \irule{Exp-Return-Unit}
      { m' = \cCleanup{m}}
      { \mm{m}{\eFun{a_1, …, a_n}{\iPass} (v_1, …, v_n)}
           {m'}{\eUnit}
      }
\]

\item $i = \iReturn{v}$. Idem avec \textsc{Exp-Return}.

\[ \irule{Exp-Return}
      { m' = \cCleanup{m}}
      { \mm{m}{\eFun{a_1, …, a_n}{\iReturn{v}} (v_1, …, v_n)}
           {m'}{v}
      }
\]

\item $\mm{m_1}{i}{m_2}{i'}$.

    Alors on peut appliquer \textsc{Exp-Call-Ctx}.

\[
    \irule{Exp-Call-Ctx}
        { m_1 = \mathrm{Push} (m_0, (a_1 ↦ v_1, … a_n ↦ v_n))
       \\ \mm{m_1}{i}{m_2}{i'}
       \\ ∀ i ∈ [1;n], v'_i = m_2[(0, a_i)]_A
       \\ m_3 = \mathrm{Pop} (m_2)
        }
        { \mm{m_0}{\eFun{a_1, …, a_n}{i} (v_1, …, v_n) }
          { m_3 }{\eFun{a_1, …, a_n}{i'} (v'_1, …, v'_n) }
        }
\]

\item $\msi{m}{i} → Ω$. On peut alors appliquer \textsc{Exp-Call-Err}.

\[ \irule{Exp-Call-Err}
    { m' = \mathrm{Push}(m, (a_1 ↦ v_1, …, a_n ↦ v_n))
   \\ \msi{m'}{i} → Ω
    }
    { \msi{m}{\eFun{a_1, …, a_n}{i} (v_1, …, v_n) } → Ω }
\]

\end{itemize}

% TODO remettre ces règles à leur place

%}}}
\jolibreak
\paragraph{\textsc{Lv-Var}:}%{{{

Le but est d'appliquer \textsc{Phi-Var}. La seule condition pour que cela soit
possible est que $\cLookup{x}{m}$ renvoie une adresse et non $\serr{var}$.

Puisque $Γ ⊢ x : t$, on en déduit que $x:t ∈ Γ$ (par le lemme d'inversion), donc
que $x ∈ \cDom{Γ}$. Comme $\mcomp{Γ}{m}$, $x ∈ \{ \cVarname{a} / a ∈
\cVisible{m} \}$, donc $∃ a ∈ \cVisible{m}. x = \cVarname{a}$ et
$\cLookup{x}{m}$ ne renvoie donc pas d'erreur.

%}}}
\paragraph{\textsc{Lv-Deref}:}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ (vue en tant qu'expression).

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que $v = φ$ ou $v = \eNull$.

  Dans le premier cas, la règle \textsc{Phi-Deref} s'applique:
  $\mms{e}{\widehat{*}φ}$.
  Dans le second, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index}:} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \eArray{v_1; …; v_p}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\eArray{v_1; …; v_p}\widehat{[n]}} $.
Deux cas sont à distinguer:
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

% TODO attention à l'off by one

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field}:}%{{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.

\end{itemize}

%}}}
\paragraph{\textsc{Ptr-Arith}:} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le lemme~\ref{lemma:canon}:

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}): si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\end{proof}
% TODO vérifier que tous les contextes sont présents dans la figure
% TODO vérifier que tous les cas sont dans le lemme d'inversion
\section{Préservation}
\label{proof:preservation}

(théorème~\ref{thm:preservation})


\begin{proof}

On procède par induction sur la dérivation de $\mm{m}{\cdot}{m'}{\cdot}$.

N.B. \textsc{Ctx} apparaît 3 fois.

Cas $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{e'}$.

\paragraph{\textsc{Ctx}:} % {{{
\[
   \irule{Ctx}
     { \mm{m}{e}{m'}{e'} }
     { \mm{m}{\ctxSub{C}{e}}{m'}{\ctxSub{C}{e'}} }
\]

Par le lemme d'inversion, il existe $t'$ tel que $Γ ⊢ e : t'$. % TODO

Comme $\mm{m}{e}{m'}{e'}$, on peut appliquer l'hypothèse de récurrence:
$\mcomp{Γ}{m'}$ et $Γ ⊢ e' : t'$. Il reste à prouver que
$Γ ⊢ \ctxSub{C}{e'} : t$.

On sait que:

\begin{itemize}
\item $Γ ⊢ e : t'$
\item $Γ ⊢ e' : t'$
\item $Γ ⊢ \ctxSub{C}{e} : t$.
\end{itemize}

On cherche à prouver:

\begin{itemize}
\item $Γ ⊢ \ctxSub{C}{e'} : t$.
\end{itemize}

% TODO une sorte de lemme de substitution

% }}}

\jolibreak

Cas $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{v}$.

\paragraph{\textsc{Exp-Cst}:} % {{{
\[ \semrule{Exp-Cst} \]

On distingue selon la forme de $c$.

\begin{itemize}
\item $n$:
d'après le lemme des formes canoniques, $t =\tInt$ ; % TODO
d'autre part, d'après \textsc{S-Int}, $m ⊧ \widehat{n} : \tInt$.
Par \textsc{Comp-Ground} on a $\tComp{\tInt}{\tInt}$, ce qui nous permet de
conclure.

\item $d$:
Idem avec la règle \textsc{S-Float}.

\item $\eUnit$:
Idem avec la règle \textsc{S-Unit}.

\item $\eNull$:
Dans les hypothèses on a $Γ ⊢ \textsc : t$. D'après le lemme des formes
canoniques, % TODO
$∃ t', t = t'~*$.

Soit $τ$ un type sémantique tel que $\tComp{τ}{t}$
(un tel type existe toujours). % TODO
Alors par \textsc{Comp-Ptr}, $\tComp{τ~*}{t~*}$.
En outre, grâce à \textsc{S-Null}, on obtient $m ⊢ \eNull: τ~*$.

\end{itemize}

% }}}
\paragraph{\textsc{Exp-Fun}:} % {{{
\[ \semrule{Exp-Fun} \]

$Γ ⊢ f : t$, donc par le lemme d'inversion on obtient l'existence de $t_1, …,
t_n, t'$ tels que $t = (t_1, …, t_n) → t'$.
D'après \textsc{S-Fun}, $m ⊧ \widehat{f} : \stFun{n}$.
Enfin, \textsc{Comp-Fun} nous permet de conclure car
$\tComp{\stFun{n}}{(t_1, …, t_n) → t'}$.

% }}}
\paragraph{\textsc{Exp-Lv}:} % {{{ TODO
\[ \semrule{Exp-Lv} \]

On a $Γ ⊢ φ : t$, $\mcomp{Γ}{m}$.

On veut $m ⊧ v : τ$ où $v = m[φ]_Φ$ avec $\tComp{τ}{t}$.

On distingue selon la forme de $φ$.

% TODO dans le typage il faut insérer un varname.
% TODO checker le typage de l'appel, y'a un push/pop à gérer

\begin{itemize}
\item $φ = a$ avec $a ∈ \cVisible{m}$:
Puisque $\mcomp{Γ}{m}$, il existe un $τ$ tel que $m ⊧ φ : τ$ et $\mcomp{τ}{t}$.

\item $φ = a$ avec $a ∉ \cVisible{m}$:
% TODO

\item $φ = φ'.l$
D'après, % TODO
$Γ ⊢ φ' : t'$ où $t' = \tStruct{l_1:t_1;…;l_n:t_n}$ où $∃p, l = l_p$.

On applique l'hypothèse de récurrence à $φ'$: $m ⊧ m[φ']_Φ : τ$ avec
$\tComp{τ}{t'}$. $τ$ étant compatible avec un type structure, $τ$ a pour forme
% TODO
$\tStruct{l_1:τ_1;…;l_n:τ_n}$ où $∀i, \tComp{τ_i}{t_i}$

Donc $m ⊧ φ'.l : τ_p$. avec $\tComp{τ_p}{t_p}$.

Or, d'après ...

\item $φ = φ'[n]$
% TODO

\item $φ = *φ'$
% TODO

\end{itemize}

% }}}
\paragraph{\textsc{Exp-UnOp}:} % {{{
\[ \semrule{Exp-UnOp} \]

Il vient des définitions des différents opérateurs$\widehat{\opun}$ que
$Γ ⊢ \widehat{\opun}~v : τ$ avec $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-BinOp}:} % {{{

Idem avec les définitions des opérateurs $\widehat{\opbin}$.

% }}}
\paragraph{\textsc{Exp-AddrOf}:} % {{{
\[ \semrule{Exp-AddrOf} \]

On a: $Γ ⊢ \&~φ : t$.

Par le lemme des formes canoniques, il existe $t'$ tel que $t = t'~*$.
Puisque $\mcomp{Γ}{m}$, on en déduit que
$m ⊧ m[φ]_Φ : τ'$ où $\tComp{τ'}{t'}$. % TODO

Donc d'après \textsc{S-Ref}, $m ⊧ \widehat{\&}~φ : τ'~*$, soit
$m ⊧ \widehat{\&}~φ : τ$.

D'autre part, il vient de \textsc{Comp-Ptr} que $\tComp{τ'~*}{t'~*}$ ,
c'est-à-dire que $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-Set}:} % {{{
\[ \semrule{Exp-Set} \]

Deux propriétés sont à prouver. D'une part, $Γ ⊢ v : t$, et d'autre part,
$\mcomp{Γ}{m[φ←v]}$.

Tout d'abord, le lemme d'inversion appliqué à $Γ ⊢ φ ← v : t$ nous donne que
$Γ ⊢ φ : t$ et $Γ ⊢ v : t$.

Ensuite, comme
$Γ ⊢ φ : t$ et $\mcomp{Γ}{m}$,
il existe $τ$ tel que
$m ⊧ m[φ]_Φ : τ$ et $\tComp{τ}{t}$. % TODO il faut une sorte de lemme de subs

% }}}
\paragraph{\textsc{Exp-Struct}:} % {{{
\[ \semrule{Exp-Struct} \]

Comme $Γ ⊢ \eStruct{l_1:v_1;…;l_n:v_n} : t$, le lemme d'inversion nous dit qu'il
existe $t_1, …, t_n$ tels que $t = \tStruct{l_1:v_1;…;l_n:v_n}$ avec
$∀i, Γ ⊢ v_i : t_i$.

Lemme: Si $Γ ⊢ v : t$ et $\mcomp{Γ}{m}$, alors il existe $τ$ tel que
$m ⊧ v : τ$ et $\tComp{τ}{t}$.
% TODO

Par ce % TODO
lemme, $∀i, ∃τ_i, m ⊧ v_i ∧ \tComp{τ_i}{t_i}$.

En appliquant \textsc{S-Struct}, on trouve
$ m ⊧ \widehat{ \eStruct{l_1:v_1;…;l_n:v_n} }
    :           \tStruct{l_1:τ_1;…;l_n:τ_n} $

D'autre part, de \textsc{Comp-Struct} il vient que
$\tComp{ \tStruct{l_1:τ_1;…;l_n:τ_n} }{t}$.

% }}}
\paragraph{\textsc{Exp-Array}:} % {{{
\[ \semrule{Exp-Array} \]

On applique le lemme d'inversion à $Γ ⊢ \eArray{v_1,…,v_n} : t$ : il existe
$t'$ tel que $t = t'~[]$ et $∀i, Γ ⊢ v_i : t'$.

Par le lemme, % TODO
il existe $τ'$ tel que $∀i, m ⊧ v_i : τ'$ et $\tComp{τ'}{t'}$.

Donc par \textsc{S-Array}, $m ⊧ \widehat{\eArray{v_1,…,v_n}}: τ'~[]$.

De plus d'après \textsc{Comp-Array}, $\tComp{τ'~[]}{t'~[]}$ soit $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-Call}:} % {{{ TODO
\[ \semrule{Exp-Call} \]
% }}}

\jolibreak

Cas $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{lv'}$.

\paragraph{\textsc{Ctx}:} % {{{ TODO
\[
   \irule{Ctx}
     { \mm{m}{lv}{m'}{lv'} }
     { \mm{m}{\ctxSub{C}{lv}}{m'}{\ctxSub{C}{lv'}} }
\]
% }}}
\paragraph{\textsc{Phi-Var}:} % {{{ TODO
\[ \semrule{Phi-Var} \]
% }}}
\paragraph{\textsc{Phi-Deref}:} % {{{ TODO
\[ \semrule{Phi-Deref} \]
% }}}
\paragraph{\textsc{Phi-Struct}:} % {{{ TODO
\[ \semrule{Phi-Struct} \]
% }}}
\paragraph{\textsc{Phi-Array}:} % {{{ TODO
\[ \semrule{Phi-Array} \]
% }}}

\jolibreak

Cas $Γ ⊢ i$ et $\mm{m}{i}{m'}{i'}$.

\paragraph{\textsc{Ctx}:} % {{{ TODO
\[ \semrule{Ctx} \]
% }}}
\paragraph{\textsc{Seq}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i$.
%}}}
\paragraph{\textsc{Exp}:}%{{{
D'après \textsc{Pass}, $Γ ⊢ \iPass$.
%}}}
\paragraph{\textsc{Decl-Pass}:}%{{{ TODO
\[ \semrule{Decl-Pass} \]
%}}}
\paragraph{\textsc{Decl-Return}:}%{{{ TODO
\[ \semrule{Decl-Return} \]
%}}}
\paragraph{\textsc{Decl-Ctx}:}%{{{ TODO
\[ \semrule{Decl-Ctx} \]
%}}}
\paragraph{\textsc{If-False}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_f$.
%}}}
\paragraph{\textsc{If-True}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_t$.
%}}}
\paragraph{\textsc{While}:}%{{{

D'après le lemme d'inversion, $Γ ⊢ e : t$ et $Γ ⊢ i$.
Par \textsc{Seq}, on a $Γ ⊢ i ; \iWhile{e}{i}$.
Enfin par \textsc{If} il vient $Γ ⊢ \iThen{e}{i ; \iWhile{e}{i}}$.

%}}}
\paragraph{\textsc{Return}:}%{{{

Par le lemme d'inversion, $Γ ⊢ \iReturn{v}$.
%}}}

% TODO vérifier que les cas du lemme d'inversion sont bien

\end{proof}

\section{Progrès pour les types qualifiés}
\label{proof:progres-qualif}

(théorème~\ref{thm:progres-qual})

\begin{proof}

On procède de la même manière que pour le théorème~\ref{thm:progres} (prouvé en
annexe~\ref{proof:progres}). En fait, puisque le schéma de preuve porte sur les
règles de typage, il suffit de traiter les cas supplémentaires.

% TODO qu'est-ce qui empêche *♢x ?

\paragraph{\textsc{Taint} :} % {{{

Alors $e = \eTaint{lv}$. On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors on peut appliquer \textsc{Expr-Tainted}.
\item $\mm{m}{lv}{m'}{lv'}$. On conclut en utilisant \textsc{Ctx} avec $C =
\eTaint{\ctxEmpty}$.
\item $\msi{m}{lv} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.
\end{itemize}

% }}}
\paragraph{\textsc{AddrOf-Kernel} :} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors \textsc{Exp-AddrOf} s'applique.

\item $\mm{m}{lv}{m'}{lv'}$. On applique \textsc{Ctx} à $C = \&~\ctxEmpty$.

\item $\msi{m}{lv} → Ω$. Idem avec la règle \textsc{Eval-Err}.

\end{itemize}

% }}}
\paragraph{\textsc{Ptr-Arith-User} :} % {{{

Ce cas est similaire à \textsc{Op-Int}. % TODO détails

% }}}
\paragraph{\textsc{GetU} :} % {{{

On applique l'hypothèse de récurrence à $e_d$.

\begin{itemize}
\item $e_d = v_d$. On applique l'hypothèse de récurrence à $e_s$.

\begin{itemize}
\item $e_s = v_s$. % TODO

    D'après le lemme~\ref{lemma:canon}, % TODO ou une version chapitre 6?
    $v_s$ a pour forme $φ_s$.

    On distingue la forme de $φ_s$:

    \begin{itemize}
        \item $φ_s = \vTainted{φ}$. Alors on applique
        \textsc{User-Get-OK}.
        % TODO encore faut-il que la prémisse soit vraie...
        % trop grand pas

        \item $∄~φ, φ_s = \vTainted{φ}$. Alors idem avec
            \textsc{User-Get-Err}.
    \end{itemize}

\item $\mm{m}{e_s}{m'}{e_s'}$. Posons $C = \uGet{v_d}{\ctxEmpty}$.
    On conclut avec \textsc{Ctx}.
\item $\msi{m}{e_s} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}

\item $\mm{m}{e_d}{m'}{e_d'}$. On applique \textsc{Ctx} avec
    $C = \uGet{\ctxEmpty}{e_s}$.

\item $\msi{m}{e_d} → Ω$. On utilise \textsc{Eval-Err} avec ce même contexte.

\end{itemize}
% }}}
\paragraph{\textsc{PutU} :} % {{{
Ce cas est similaire au cas \textsc{GetU}, en appliquant les règles
\textsc{User-Put-OK} et \textsc{User-Put-Err}.

% }}}

% TODO vérifier que tous les cas de contexte sont là

\end{proof}

\section{Préservation pour les types qualifiés}
\label{proof:preservation-qualif}

(théorème~\ref{thm:preservation-qualif})

% TODO
