\section{Composition de lentilles}

\label{proof:compo-lens}

\begin{proof}
Pour prouver que $ℒ_1 \ggg ℒ_2 ∈ \setLens{A}{C}$, il suffit de prouver les trois
propriétés caractéristiques.

\paragraph{GetPut}%{{{

{

\def\xa{
  \lensPut{ℒ}{
    \lensGet{ℒ}{r}
    }{
      r
    }
  }


\def\xb{
  \lensPut{ℒ}
    {
      \lensGet{ℒ_2}{
        \lensGet{ℒ_1}{r}
      }
    }
    { r }
}

\def\xab{ définition de \lensGetX{ℒ} }

\def\xc{
  \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
                    {
                      \lensGet{ℒ_2}
                        {
                          \lensGet{ℒ_1}{r}
                        }
                    }
                    { \lensGet{ℒ_1}
                              {r}
                    }
          }
          {r}
}

\def\xbc{ définition de \lensPutX{ℒ} }

\def\xd{
  \lensPut{ℒ_1}
          {
            \lensGet{ℒ_1}{r}
          }
          {r}
}

\def\xcd{ \textsc{GetPut} sur $ℒ_2$ }

\def\xe{r}

\def\xde{\textsc{GetPut} sur $ℒ_1$}

\begin{conteq}
    \xa{} \\
  = \xb{} & \xab{} \\
  = \xc{} & \xbc{} \\
  = \xd{} & \xcd{} \\
  = \xe{} & \xde{}
\end{conteq}

}

%}}}

\paragraph{PutGet}%{{{

\begin{conteq}
  \lensGet{ℒ}
    {
      \lensPut{ℒ}
        {a}
        {r}
    } \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ}
            {a}
            {r}
        }
    }
& définition de \lensGetX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensGet{ℒ_1}
        {
          \lensPut{ℒ_1}
            {
              \lensPut{ℒ_2}
                {a}
                { \lensGet{ℒ_1}{r} }
            }
            { r }
        }
    }
& définition de \lensPutX{ℒ} \\
= \lensGet{ℒ_2}
    {
      \lensPut{ℒ_2}
        {a}
        { \lensGet{ℒ_1}{r} }
    }
& \textsc{PutGet} sur $ℒ_1$ \\
= a
& \textsc{PutGet} sur $ℒ_2$ \\
\end{conteq}
%}}}

\paragraph{PutPut}%{{{

\begin{conteq}[onecolumn]
  \lensPut{ℒ}{a'}{
    \lensPut{ℒ}{a}{r}
  } \\
= \lensPut{ℒ}{a'}{
    \lensPut{ℒ_1}
      {
        \lensPut{ℒ_2}
          {a}
          { \lensGet{ℒ_1}{r} }
      }
      { r }
  }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{
            \lensPut{ℒ_1}
              {
                \lensPut{ℒ_2}
                  {a}
                  { \lensGet{ℒ_1}{r} }
              }
              { r }
          }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& définition de \lensPutX{ℒ} \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        {
          \lensPut{ℒ_2}
            {a}
            { \lensGet{ℒ_1}{r} }
        }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{GetPut} sur $ℒ_1$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    {
        \lensPut{ℒ_1}
          {
            \lensPut{ℒ_2}
              {a}
              { \lensGet{ℒ_1}{r} }
          }
          { r }
    }
& \textsc{PutPut} sur $ℒ_2$ \\
= \lensPut{ℒ_1}
    {
      \lensPut{ℒ_2}
        {a'}
        { \lensGet{ℒ_1}{r} }
    }
    { r
    }
& \textsc{PutPut} sur $ℒ_1$ \\
= \lensPut{ℒ}{a'}{r}
& définition de $\ggg$ \\
\end{conteq}
%}}}

\end{proof}

\section{Progrès}
\label{proof:progres}

(théorème~\ref{thm:progres})

\begin{proof}

On procède par induction sur la dérivation du jugement de typage. Puisque les
jugements $Γ ⊢ i$, $Γ ⊢ e : t$ et $Γ ⊢ lv : t$ sont interdépendants, on traite
tous les cas par récursion mutuelle.

Le squelette de cette preuve est une analyse de cas selon la dernière règle
utilisée. La plupart des cas ont la même forme: on utilise l'hypothèse de
récurrence sur les sous-éléments syntaxiques (en appliquant éventuellement le
lemme~\ref{lemma:inversion} d'inversion pour établir qu'ils sont bien typés).
Dans le cas ``valeur'', on appelle une règle qui permet de transformer une
opération syntaxique en opération sémantique (par exemple, on transforme le $+$
unaire en un $\widehat{+}$ sémantique). Dans le cas ``évaluation'', on applique
la règle \textsc{Ctx} avec un contexte particulier qui permet de passer d'un
jugement $\mm{m}{a}{m'}{a'}$ à un jugement $\mm{m}{b}{m'}{b'}$ (où $a$ apparaît
dans $b$). Enfin, dans le cas ``erreur'', on utilise \textsc{Eval-Err} avec ce
même contexte $C$.

Ceci est valable pour la majorité des cas. Il faut faire attention en
particulier aux opérations sémantiques qui peuvent produire des erreurs (comme
la division, ou l'opérateur $\phxx\cLookup$).

%\begin{itemize}
%\item $i = \iPass$.
%\item $i = \iReturn{v}$.
%\item $\mm{m}{i}{m'}{i'}$.
%\item $\msi{m}{i} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $e = v$.
%\item $\mm{m}{e}{m'}{e'}$.
%\item $\msi{m}{e} → Ω$.
%\end{itemize}

%\begin{itemize}
%\item $lv = φ$.
%\item $\mm{m}{lv}{m'}{lv'}$.
%\item $\msi{m}{lv} → Ω$.
%\end{itemize}

\subsection{Instructions}

\paragraph{\textsc{Pass}  :} %{{{
Ce cas est trivial.
% }}}
\paragraph{\textsc{Return}:} %{{{
Partant de $i = \iReturn{e}$, on applique le lemme d'inversion. Il vient :
$∃ t_t, Γ ⊢ e : t_r$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$. Alors $i = \iReturn{v}$, ce qui nous permet de conclure.

\item $\mm{m}{e}{m'}{e'}$.
Alors en appliquant \textsc{Ctx} avec
$C = \iReturn{\ctxEmpty}$, on conclut que
$\mm{m}{\iReturn{e}}{m'}{\iReturn{e'}}$.

\item $\msi{m}{e} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.

\end{itemize}
% }}}
\paragraph{\textsc{Seq}   :} %{{{
Avec $i = i_1;i_2$, on applique l'hypothèse de récurrence à $i_1$.

\begin{itemize}
\item $i_1 = \iPass$. On peut donc appliquer la règle \textsc{Seq} et donc
$\mms{i}{i_2}$.

\item $i_1 = \iReturn{v}$. Alors on peut appliquer la règle \textsc{Return}:
    $\mms{i}{\iReturn{v}}$.

\item $\mm{m}{i_1}{m'}{i_1'}$. Soit $C = \ctxEmpty;i_2$. Par \textsc{Ctx} il
    vient $\mm{m}{i}{m'}{i_1';i_2}$.
    \item $\msi{m}{i_1} → Ω$. Avec ce même $C$ dans \textsc{Eval-Err} on trouve
    $\msi{m}{i} → Ω$.

\end{itemize}
% }}}
\paragraph{\textsc{Exp}   :} %{{{

Ici $i = e$. On peut appliquer l'hypothèse de récurrence à $e$ qui est ``plus
petit'' que $i$ ($i \gramisa e$ introduit un constructeur implicite).

\begin{itemize}
\item $e = v$. Alors on peut appliquer \textsc{Exp}: $\mms{e}{\iPass}$.
\item $\mm{m}{e}{m'}{e'}$. Alors $\mm{m}{i}{m'}{e'}$ (cela revient à appliquer
    \textsc{Ctx} au constructeur implicite mentionné ci-dessus).
\item $\msi{m}{e} → Ω$. C'est-à-dire $\msi{m}{i} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Decl}  :} %{{{

Ici $i = \iDecl{x}{e}{i'}$. On commence par appliquer l'hypothèse de récurrence
à $e$.

\begin{itemize}
\item $e = v$. On applique alors l'hypothèse de récurrence à $i$ sous
    $Γ' = Γ, x:t$ et avec $m' = \cExtend{m}{x}{v}$.

    \begin{itemize}
    \item $i = \iPass$. Dans ce cas la règle \textsc{Decl-Pass} s'applique.

    \item $i = \iReturn{v}$. Idem avec \textsc{Decl-Return}.

    \item $\mm{m'}{i}{m''}{i'}$. Par \textsc{Decl-Ctx} il vient
        $\mm{m}{\iDecl{x}{v}{i}}{m'''}{\iDecl{x}{v'}{i'}}$ où
       $v' = m''[(0, x)]_A$
       et
       $m''' = m'' - x$.

    \item $\msi{m'}{i'} → Ω$. On applique \textsc{Decl-Err}.

    \end{itemize}

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iDecl{x}{\ctxEmpty}{i'}$ et on conclut avec
    la règle \textsc{Ctx}.
\item $\msi{m}{e} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}



% }}}
\paragraph{\textsc{If}    :} %{{{
Ici $i = \iIf{e}{i_1}{i_2}$. On applique l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v$.

    Si $v ≠ 0$, on applique \textsc{If-True}. Dans le cas contraire, on
    applique \textsc{If-False}.

\item $\mm{m}{e}{m'}{e'}$. On pose $C = \iIf{\ctxEmpty}{i_1}{i_2}$ et on conclut
    avec \textsc{Ctx}.

\item $\msi{m}{e} → Ω$. Avec ce même $C$ et \textsc{Eval-Err}.
\end{itemize}

% }}}
\paragraph{\textsc{While} :} %{{{

Ce cas est direct: la règle \textsc{While} peut toujours s'appliquer.

% }}}

\subsection{Expressions}

  \paragraph{\textsc{Cst-Int}:} % {{{
$e$ est alors de la forme $n$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Float}:} % {{{
$e$ est alors de la forme $d$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Null}:} % {{{
$e$ est alors égale à $\eNull$, qui est une valeur.
%}}}
  \paragraph{\textsc{Cst-Unit}:}%{{{
$e$ est alors égale à \eUnit, qui est une valeur.
%}}}
\paragraph{\textsc{Fun}:} % {{{

Ce cas est direct: la règle \textsc{Exp-Fun} s'applique.

%}}}
  \paragraph{\textsc{Op-Int}:} % {{{

  Cela implique que $e = e_1~\opbin~e_2$. Par le lemme~\ref{lemma:inversion}, on
  en déduit que $Γ ⊢ e_1 : \tInt$ et $Γ ⊢ e_2 : \tInt$.

  Appliquons l'hypothèse de récurrence sur $e_1$. Trois cas peuvent se produire.

\begin{itemize}

  \item $e_1 = v_1$. On a alors $\mm{m}{e_1}{m'}{v_1}$ avec $m' = m$.

    On applique l'hypothèse de récurrence à $e_2$.

      \begin{itemize}

        \item $e_2 = v_2$: alors $\mm{m'}{e_2}{m''}{v_2}$ avec $m'' = m$. On
          peut alors appliquer \textsc{Exp-BinOp}, sauf dans le cas d'une
          division par zéro ($ \opbin ∈ \{ / ; \% ; /. \} $ et
          $ v_2 = 0 $) où alors $v_1~\widehat{\opbin}~v_2 = \serr{div}$. Dans ce cas, on a
          alors par \textsc{Exp-Err} $\msi{m}{e} → \serr{div}$.

        \item $∃ (e'_2, m''), \mm{m'}{e_2}{m''}{e'_2}$.

          En appliquant \textsc{Ctx} avec $C = \ctxOp{v_1}{\ctxEmpty}$, on
          en déduit $\mm{m'}{v_1~\opbin~e_2}{m''}{v_1~\opbin~e'_2}$ soit
          $\mm{m}{e}{m''}{v_1~\opbin~e'_2}$.

        \item $\msi{m'}{e_2} → Ω$.
          De \textsc{Eval-Err} avec $C = \ctxOp{v_1}{\ctxEmpty}$
          vient alors $\msi{m}{e} → Ω$.

      \end{itemize}

  \item $∃(e_1', m'), \mm{m}{e_1}{m'}{e'_1}$.
    En appliquant \textsc{Ctx} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on obtient
    $\mm{m}{e_1~\opbin~e_2}{m'}{e'_1~\opbin~e_2}$, ou
    $\mm{m}{e}{m'}{e'_1~\opbin~e_2}$.

  \item $\msi{m}{e_1} → Ω$.
    D'après \textsc{Eval-Err} avec $C = \ctxOp{\ctxEmpty}{e_2}$, on a
    $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Op-Float}:} % {{{
Ce cas est similaire à \textsc{Op-Int}.
%}}}
\paragraph{\textsc{Op-Eq}:} %{{{
Ce cas est similaire à \textsc{Op-Int}.
%}}}
\paragraph{\textsc{Unop-Plus-Int}:} % {{{

Alors $e = +~e_1$. En appliquant l'hypothèse d'induction sur $e_1$:

\begin{itemize}
\item
  soit $e_1 = v_1$. Alors en appliquant \textsc{Exp-UnOp},
  $\mm{m}{+~v_1}{m}{\widehat{+}~v_1}$, c'est-à-dire en posant $v =
  \widehat{+}~v_1$, $\mm{m}{e}{m}{v}$.
\item
  soit $∃ e'_1, m', \mm{m}{e_1}{m'}{e'_1}$. Alors en appliquant \textsc{Ctx}
avec $C = +~\ctxEmpty$, on obtient $\mm{m}{e}{m'}{e'_1}$.
\item
  soit $\msi{m}{e_1} → Ω$.
  De \textsc{Eval-Err} avec $C = +~\ctxEmpty$ il vient$\msi{m}{e} → Ω$.
\end{itemize}

% }}}
\paragraph{\textsc{Unop-Plus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Int}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Minus-Float}:} % {{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
% }}}
\paragraph{\textsc{Unop-Not}:}%{{{
Ce cas est similaire à \textsc{Unop-Plus-Int}.
%}}}
\paragraph{\textsc{Addr}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

Les cas d'évaluation et d'erreur sont traités en appliquant respectivement
\textsc{Ctx} et \textsc{Eval-Err} avec $C = \&\ctxEmpty$. Dans le cas où $lv =
φ$, on peut appliquer \textsc{Exp-AddrOf}.

%}}}
\paragraph{\textsc{Set}:} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$. On applique l'hypothèse de récurrence à $e$.

    \begin{itemize}
    \item $e = v$. Alors on peut appliquer \textsc{Exp-Set}.

    \item $\mm{m}{e}{m'}{e'}$. On conclut avec $C = φ ← \ctxEmpty$.
    \item $\msi{m}{e} → Ω$. Idem.
    \end{itemize}

\item $\mm{m}{lv}{m'}{lv'}$. On conclut avec $C = \ctxEmpty ← e$.
\item $\msi{m}{lv} → Ω$. Idem.

\end{itemize}

%}}}
\paragraph{\textsc{Array}:} % {{{

On va appliquer l'hypothèse de récurrence à $e_1$, puis si $e_1 = v_1$, on
l'applique à $e_2$, etc. Alors on se retrouve dans un des cas suivants:

\begin{itemize}
\item $∃ p ∈ [1;n],e'_p,m: e_1 = v_1, …, e_{p-1} = v_{p-1}, \mm{m}{e_p}{m'}{e'_p}$.
  Alors on peut appliquer \textsc{Ctx} avec
  $C = [v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n]$.
\item $∃ p ∈ [1;n],Ω :     e_1 = v_1, …, e_{p-1} = v_{p-1}, \msi{m}{e_p} → Ω$.
  Dans ce cas \textsc{Eval-Err} est applicable avec ce même $C$.
\item $e_1 = v_1, …, e_n = v_n$.
  Alors on peut appliquer \textsc{Exp-Array} en construisant un tableau.
\end{itemize}

%}}}
\paragraph{\textsc{Struct}:} % {{{

Le schéma de preuve est similaire au cas \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise le contexte
$C = \eStruct{l_1: v_1, …, l_{p-1}: v_{p-1}, \ctxEmpty, l_{p+1}: e_{p+1}, …, l_n:
e_n}$; et dans le cas où toutes les expressions sont évaluées, on applique
\textsc{Exp-Struct}.

%}}}
\paragraph{\textsc{Call}:} % {{{

On commence par appliquer l'hypothèse de récurrence à $e$. Dans le cas d'un pas
d'évaluation ou d'erreur, on applique respectivement \textsc{Ctx} ou
\textsc{Eval-Err} avec $C = \ctxEmpty (e_1, …, e_n)$.
Reste le cas où $e$ est une valeur: d'après le lemme~\ref{lemma:canon}, $e$ est
de la forme $f = \eFun{\vec{a}}{i}$.

Ensuite, appliquons le même schéma que pour \textsc{Array}.
En cas de pas d'évaluation ou d'erreur, on utilise
\textsc{Ctx} ou \textsc{Eval-Err} avec
$C = f (v_1, …, v_{p-1}, \ctxEmpty, e_{p+1}, …, e_n)$.
Le seul cas restant est celui où l'expression considérée a pour forme
$f (v_1, …, v_n)$
avec
$f = \eFun{\vec{a}}{i}$.

Soient $Γ' = (Γ - \vRet), a_1 : t_1, …, a_n : t_n, \vRet : t$
et
$m_1 = \cPush{m_0}{(a_1 ↦ v_1, … a_n ↦ v_n)}$.

On applique alors l'hypothèse de récurrence à $Γ'$, $m_1$ et $i$ (le lemme
d'inversion garantit que $Γ' ⊢ i$).

\begin{itemize}
\item $i = \iPass$. Alors on peut appliquer \textsc{Exp-Call-Return-Unit}.

\item $i = \iReturn{v}$. Idem avec \textsc{Exp-Call-Return}.

\item $\mm{m_1}{i}{m_2}{i'}$.

    Alors on peut appliquer \textsc{Exp-Call-Ctx}.

\item $\msi{m}{i} → Ω$. On peut alors appliquer \textsc{Exp-Call-Err}.

\end{itemize}

%}}}

\subsection{Left-values}

\paragraph{\textsc{Lv-Var}:}%{{{

Le but est d'appliquer \textsc{Phi-Var}. La seule condition pour que cela soit
possible est que $\cLookup{x}{m}$ renvoie une adresse et non $\serr{var}$.

Puisque $Γ ⊢ x : t$, on en déduit que $x:t ∈ Γ$ (par le lemme d'inversion), donc
que $x ∈ \cDom{Γ}$. Comme $\mcomp{Γ}{m}$, $x ∈ \{ \cVarname{a} / a ∈
\cVisible{m} \}$, donc $∃ a ∈ \cVisible{m}. x = \cVarname{a}$ et
$\cLookup{x}{m}$ ne renvoie donc pas d'erreur.

%}}}
\paragraph{\textsc{Lv-Deref}:}%{{{

  Appliquons l'hypothèse de récurrence à $lv$ vue en tant qu'expression.

\begin{itemize}
\item
  $lv = v$. Puisque $Γ ⊢ v : t*$, on déduit du
  lemme~\ref{lemma:canon} que
  $v = \eNull$
  ou
  $v = φ$.

  Dans le premier cas, puisque $\msi{m}{*\eNull} → \serr{ptr}$, on a
  $\msi{m}{e} → \serr{ptr}$.

  Dans le second cas, l'expression à réduire à pour forme $*φ$. Puisque
  $\mcomp{Γ}{m}$, $m[φ]_Φ$ est une valeur $v'$ telle que $m ⊧ v' : τ$ où
  $\tComp{τ}{t~*}$, donc de la forme $v' = \widehat{\&}~φ'$
  (lemme~\ref{lemma:mem-typ}).

  Alors \textsc{Phi-Deref} s'applique.

\item
  $\mm{m}{lv}{m'}{e'}$.
  De \textsc{Ctx} avec $C = *\ctxEmpty$, on obtient
  $\mm{m}{e}{m'}{*e'}$.

\item
  $\msi{m}{lv} → Ω$.
  En appliquant \textsc{Eval-Err} avec $C = *\ctxEmpty$, on obtient
  $\msi{m}{e} → Ω$.

\end{itemize}

% }}}
\paragraph{\textsc{Lv-Index}:} % %{{{

De même, on applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = v$.

Comme $Γ ⊢ v : t[]$, on déduit du lemme~\ref{lemma:canon} que
$v = \eArray{v_1; …; v_p}$.
Appliquons l'hypothèse de récurrence à $e$.

\begin{itemize}
\item $e = v'$. Puisque $Γ ⊢ e : \tInt$, on réapplique le
lemme~\ref{lemma:canon} et $v' = n$.
D'après \textsc{Phi-Array}, $ \mms{lv[e]}{\eArray{v_1; …; v_p}\widehat{[n]}} $.
Deux cas sont à distinguer:
si $n ∈ [0;p-1]$, la partie droite vaut $v_{n+1}$ et donc
$\mm{m}{lv[e]}{m}{v_{n+1}}$.
Sinon elle vaut $\serr{array}$ et $\msi{m}{lv[e]} → \serr{array}$ par \textsc{Exp-Err}.

\item $\mm{m}{e}{m'}{e'}$.
En appliquant \textsc{Ctx} avec $C = v[\ctxEmpty]$, on en déduit
\item $\mm{m}{lv[e]}{m'}{lv[e']}$.

\item $\msi{m}{e} → Ω$.
Avec \textsc{Eval-Err} sous ce même contexte,
$\msi{m}{lv[e]} → Ω$
\end{itemize}

\item $\mm{m}{lv}{m'}{e'}$.
On applique alors \textsc{Ctx} avec $C = \ctxEmpty[e]$, et
$\mm{m}{lv[e]}{m'}{e'[e]}$.

\item $\msi{m}{lv} → Ω$.
Toujours avec $C = \ctxEmpty[e]$, de \textsc{Eval-Err} il vient
$\msi{m}{lv[e]} → Ω$.

\end{itemize}
%}}}
\paragraph{\textsc{Lv-Field}:}%{{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}

\item $lv = φ$
Alors \textsc{Phi-Struct} s'applique. Puisque $(l, t) ∈ S$, l'accès au champ $l$
ne provoque pas d'erreur $\serr{field}$. Donc $\mm{m}{e}{m}{φ[l]}$.

\item $\mm{m}{lv}{m'}{lv'}$
En appliquant \textsc{Ctx} avec $C = \ctxEmpty.l_S$, il vient
$\mm{m}{lv}{m'}{lv'}$.

\item $\msi{m}{lv} → Ω$
En appliquant \textsc{Eval-Err} avec $C = \ctxEmpty.l_S$, on a
$\msi{m}{lv} → Ω$.

\end{itemize}

%}}}
\paragraph{\textsc{Ptr-Arith}:} % %{{{

Le schéma est similaire au cas \textsc{Op-Int}. Le seul cas intéressant arrive
lorsque $e_1$ et $e_2$ sont des valeurs. D'après le lemme~\ref{lemma:canon}:

\begin{itemize}
\item $e_1 = \eNull$ ou $e_1 = φ$
\item $e_2 = n$
\end{itemize}

D'après \textsc{Exp-Binop}, $\mms{e}{e_1~\widehat{\opbin}~n}$.

On se réfère ensuite à la définition de $\widehat{\opbin}$
(page~\pageref{page:def-arith-ptr-error}): si $e_1$ est de la forme $φ[m]$,
alors $e_1~\widehat{\opbin}~n = φ[m+n]$. Donc $\mms{e}{φ[m+n]}$.

Dans les autres cas ($e_1 = \eNull$ ou $e_1 = φ$ avec $φ$ pas de la forme
$φ'[m]$), on a $e_1~\widehat{\opbin}~n = \serr{ptr}$. Donc d'après
\textsc{Exp-Err}, $\msi{m}{e} → \serr{ptr}$.

%}}}
\end{proof}

\section{Préservation}
\label{proof:preservation}

(théorème~\ref{thm:preservation})


\begin{proof}

On procède par induction sur la dérivation de $\mm{m}{\cdot}{m'}{\cdot}$.

N.B. \textsc{Ctx} apparaît 3 fois.

\subsection{Cas $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{e'}$}

\paragraph{\textsc{Ctx}:} % {{{
\[
   \irule{Ctx}
     { \mm{m}{e}{m'}{e'} }
     { \mm{m}{\ctxSub{C}{e}}{m'}{\ctxSub{C}{e'}} }
\]

En appliquant le lemme~\ref{lemma:inv-ctx}, on obtient l'existence de $t'$ tel
que $Γ ⊢ e : t'$ et $\tyctx{Γ}{C}{t'}{t}$.

Comme $\mm{m}{e}{m'}{e'}$, on peut appliquer l'hypothèse de récurrence:
$\mcomp{Γ}{m'}$ et $Γ ⊢ e' : t'$.

Enfin, grâce au lemme~\ref{lemma:typ-ctx}, on sait que
$Γ ⊢ \ctxSub{C}{e'} : t$.
% }}}

\subsection{Cas $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{v}$}

\paragraph{\textsc{Exp-Cst}:} % {{{

Toutes les constantes sont des valeurs, donc le lemme~\ref{lemma:repr} peut
s'appliquer : $τ = \cRepr{t}$ convient.

% }}}
\paragraph{\textsc{Exp-Fun}:} % {{{

Idem: le lemme de réprésentabilité nous donne un candidat $τ = \cRepr{t}$
qui convient.

% }}}
\paragraph{\textsc{Exp-Lv}:} % {{{

Puisque $Γ ⊢ φ : t$ et $\mcomp{Γ}{m}$, on a d'après le
lemme~\ref{lemma:mem-typ}: $m ⊧ v : τ$ où $v = m[φ]_Φ$ avec $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-UnOp}:} % {{{

Il vient des définitions des différents opérateurs$\widehat{\opun}$ que
$Γ ⊢ \widehat{\opun}~v : τ$ avec $\tComp{τ}{t}$.

% }}}
\paragraph{\textsc{Exp-BinOp}:} % {{{

Idem avec les définitions des opérateurs $\widehat{\opbin}$.

% }}}
\paragraph{\textsc{Exp-AddrOf}:} % {{{

On peut appliquer le lemme~\ref{lemma:repr}, qui nous donne un $τ$ qui convient.

% }}}
\paragraph{\textsc{Exp-Set}:} % {{{

Deux propriétés sont à prouver. D'une part, $Γ ⊢ v : t$, et d'autre part,
$\mcomp{Γ}{m'}$ où $m' = m[φ←v]_Φ$.

Tout d'abord, le lemme d'inversion appliqué à $Γ ⊢ φ ← v : t$ nous donne que
$Γ ⊢ φ : t$ et $Γ ⊢ v : t$.

Ensuite, comme $Γ ⊢ φ : t$ et $\mcomp{Γ}{m}$, on peut appliquer le
lemme~\ref{lemma:repr}: il existe $τ$ tel que $m ⊧ v : τ$ et $\tComp{τ}{t}$.

On peut donc appliquer le lemme~\ref{lemma:mem-typ}, qui nous permet de conclure
que $\mcomp{Γ}{m'}$.

% }}}
\paragraph{\textsc{Exp-Struct}:} % {{{

Le lemme~\ref{lemma:repr} s'applique à ce cas.

% }}}
\paragraph{\textsc{Exp-Array}:} % {{{

Idem, on conclut grâce au lemme de représentabilité.

% }}}
\paragraph{\textsc{Exp-Call-Return}:} % {{{

Par inversion, il vient que
$Γ ⊢ \eFun{a_1, …, a_n}{i} : (t_1, …, t_n) → t'$
et
$∀ i ∈ [1;n], Γ ⊢ v_i : t_i$.

Posons $Γ' = Γ - \vRet, a_1:t_1, …, a_n:t_n, \vRet:t$. Alors par inversions
successives on obtient que $Γ' ⊢ \iReturn{v}$ et $Γ' ⊢ v : t$.

Par affaiblissement (lemme~\ref{lemma:affaiblissement})
$Γ ⊢ v : t$. En particulier (par le lemme~\ref{lemma:repr}), il existe
$τ$ tel que $m' ⊧ v : τ$ où $\tComp{τ}{t}$.

% TODO compat
% }}}
\paragraph{\textsc{Exp-Call-Return-Unit}:} % {{{

Idem. En fait dans le cas précédent, le type de $v$ et forcément celui de
$\vRet$ sous $Γ'$ ; comme $\vRet$ n'est alors pas utilisé, son choix est libre
et une dérivation avec $\vRet : \tUnit ∈ Γ'$ est possible.

% TODO compat
% }}}

\subsection{Cas $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{lv'}$}

\paragraph{\textsc{Ctx}:} % {{{
Idem que dans le cas des expressions.
% }}}

\subsection{Cas $Γ ⊢ lv : t$ et $\mm{m}{lv}{m'}{φ}$}

\paragraph{\textsc{Phi-Deref}:} % {{{
Puisque $Γ ⊢ *φ : t$, le lemme d'inversion nous assure que $Γ ⊢ φ : t~*$.
On applique le lemme~\ref{lemma:mem-typ} à $φ$:
il vient que $m ⊧ \widehat{\&}~φ' : τ'$ où $\tComp{τ'}{t~*}$.
Donc par inversion
(seule la règle \textsc{S-Ptr} permet de dériver un tel jugement), on a
$\semtypphi{m}{φ'}{τ}$ où $τ' = τ~*$.
On conclut que $\tComp{τ'}{t}$ en inversant par \textsc{Comp-Ptr}.

% }}}
\paragraph{\textsc{Phi-Var}, \textsc{Phi-Struct} et \textsc{Phi-Array}:} % {{{

Tout d'abord, la mémoire n'est pas modifiée donc il n'est pas nécessaire de
montrer la compatibilité de $m'$.

Ensuite, les prémisses de ces règles ont la forme $φ$ , donc le
lemme~\ref{lemma:mem-typ} s'applique avec la conclusion correcte.

% }}}

\subsection{Cas $Γ ⊢ i$ et $\mm{m}{i}{m'}{i'}$}

\paragraph{\textsc{Ctx}:} % {{{
Idem que dans le cas des expressions.
% }}}
\paragraph{\textsc{Seq}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i$.
%}}}
\paragraph{\textsc{Exp}:}%{{{
D'après \textsc{Pass}, $Γ ⊢ \iPass$.
%}}}
\paragraph{\textsc{Decl-Pass}:}%{{{ TODO
\[ \semrule{Decl-Pass} \]

$Γ ⊢ \iPass$ est immédiat.

Par inversion, on a $Γ, x:t ⊢ Pass$.

On a $Γ ⊧ m$.

On veut $Γ' ⊧ m-x$.
%}}}
\paragraph{\textsc{Decl-Return}:}%{{{ TODO
\[ \semrule{Decl-Return} \]
%}}}
\paragraph{\textsc{Decl-Ctx}:}%{{{ TODO
\[ \semrule{Decl-Ctx} \]
%}}}
\paragraph{\textsc{If-False}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_f$.
%}}}
\paragraph{\textsc{If-True}:}%{{{
D'après le lemme d'inversion, $Γ ⊢ i_t$.
%}}}
\paragraph{\textsc{While}:}%{{{

D'après le lemme d'inversion, $Γ ⊢ e : t$ et $Γ ⊢ i$.
Par \textsc{Seq}, on a $Γ ⊢ i ; \iWhile{e}{i}$.
Enfin par \textsc{If} il vient $Γ ⊢ \iThen{e}{i ; \iWhile{e}{i}}$.

%}}}
\paragraph{\textsc{Return}:}%{{{

Par le lemme d'inversion, $Γ ⊢ \iReturn{v}$.
%}}}
\paragraph{\textsc{Exp-Call-Ctx}:}%{{{ TODO

\[ \semrule{Exp-Call-Ctx} \]

%}}}

\end{proof}

\section{Progrès pour les types qualifiés}
\label{proof:progres-qualif}

(Théorème~\ref{thm:progres-qual})

\begin{proof}

On procède de la même manière que pour le théorème~\ref{thm:progres} (prouvé en
annexe~\ref{proof:progres}). En fait, puisque le schéma de preuve porte sur les
règles de typage, il suffit de traiter les cas supplémentaires.

\paragraph{\textsc{Taint} :} % {{{

Alors $e = \eTaint{lv}$. On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors on peut appliquer \textsc{Expr-Tainted}.
\item $\mm{m}{lv}{m'}{lv'}$. On conclut en utilisant \textsc{Ctx} avec $C =
\eTaint{\ctxEmpty}$.
\item $\msi{m}{lv} → Ω$. On applique \textsc{Eval-Err} avec ce même $C$.
\end{itemize}

% }}}
\paragraph{\textsc{AddrOf-Kernel} :} % {{{

On applique l'hypothèse de récurrence à $lv$.

\begin{itemize}
\item $lv = φ$. Alors \textsc{Exp-AddrOf} s'applique.

\item $\mm{m}{lv}{m'}{lv'}$. On applique \textsc{Ctx} à $C = \&~\ctxEmpty$.

\item $\msi{m}{lv} → Ω$. Idem avec la règle \textsc{Eval-Err}.

\end{itemize}

% }}}
\paragraph{\textsc{Ptr-Arith-User} :} % {{{

Ce cas est similaire à \textsc{Op-Int}.

% }}}
\paragraph{\textsc{GetU} :} % {{{

On applique l'hypothèse de récurrence à $e_d$.

\begin{itemize}
\item $e_d = v_d$. On applique l'hypothèse de récurrence à $e_s$.

\begin{itemize}
\item $e_s = v_s$. % TODO

    D'après le lemme~\ref{lemma:canon}, % TODO ou une version chapitre 6?
    $v_s$ a pour forme $φ_s$.

    On distingue la forme de $φ_s$:

    \begin{itemize}
        \item $φ_s = \vTainted{φ}$. Alors on applique
        \textsc{User-Get-OK}.
        % TODO encore faut-il que la prémisse soit vraie...
        % trop grand pas

        \item $∄~φ, φ_s = \vTainted{φ}$. Alors idem avec
            \textsc{User-Get-Err}.
    \end{itemize}

\item $\mm{m}{e_s}{m'}{e_s'}$. Posons $C = \uGet{v_d}{\ctxEmpty}$.
    On conclut avec \textsc{Ctx}.
\item $\msi{m}{e_s} → Ω$. Idem avec \textsc{Eval-Err}.
\end{itemize}

\item $\mm{m}{e_d}{m'}{e_d'}$. On applique \textsc{Ctx} avec
    $C = \uGet{\ctxEmpty}{e_s}$.

\item $\msi{m}{e_d} → Ω$. On utilise \textsc{Eval-Err} avec ce même contexte.

\end{itemize}
% }}}
\paragraph{\textsc{PutU} :} % {{{
Ce cas est similaire au cas \textsc{GetU}, en appliquant les règles
\textsc{User-Put-OK} et \textsc{User-Put-Err}.

% }}}

\end{proof}

\section{Préservation pour les types qualifiés}
\label{proof:preservation-qualif}

(Théorème~\ref{thm:preservation-qualif})

De même, il suffit de prouver les cas correspondant aux nouvelles règles.

\paragraph{\textsc{Expr-Tainted}:} % {{{

On applique le lemme de représentation. % TODO

% }}}
\paragraph{\textsc{User-Get-OK}:} % {{{ TODO
\[ \semrule{User-Get-OK} \]
% }}}
\paragraph{\textsc{User-Get-Err}:} % {{{
On a $Γ ⊢ \uGet{φ_d}{φ} : t$. D'après le lemme~\ref{lemma:inv-qualif},
$t = \tInt$, ce qui nous permet de conclure car $m ⊧ -1 : \tInt$.
% }}}
\paragraph{\textsc{User-Put-OK}:} % {{{ TODO
\[ \semrule{User-Put-OK} \]
% }}}
\paragraph{\textsc{User-Put-Err}:}
Idem que pour \textsc{User-Get-Err}.
% }}}
