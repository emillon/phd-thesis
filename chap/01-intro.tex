De plus en plus, les logiciels sont présents partout. Le plus petit appareil
électrique contient maintenant des composants matériels programmables
nécessitant des logiciels.

% TODO faire une intro "la vie est numérique" avec du Berry @ CdF

Autant certains de ces systèmes embarqués ont un rôle très délimité et ne
comportent que peu de code, certains comportent des millions de lignes de code.
% TODO [E] md
En 2013, on pense bien sûr aux téléphones portables dont la fonctionnalité et la
complexité les rapprochent des ordinateurs de bureau. . Par exemple, le système
Android de Google est basé sur le noyau Linux, destiné à la base aux
micro-ordinateurs.

Le noyau de système d'exploitation est chargé de faire l'intermédiaire entre le
matériel (processeur, mémoire, périphériques, …) et les applications exécutées
sur celui-ci (par exemple un navigateur internet, une calculatrice ou un carnet
d'adresses). Il doit aussi garantir la sécurité et l'isolation de celles-ci.

En tant que tiers de confiance, le noyau a un certain nombre de responsabilités
et est le seul à avoir accès à certaines informations sensibles. Il est capital
de s'assurer qu'il est bien le seul à pouvoir y accéder. En particulier, il faut
pouvoir vérifier que les requêtes faites par l'utilisateur au noyau ne peuvent
pas détourner ce dernier et lui faire fuiter des informations confidentielles.

Le problème est que comme tous les logiciels, les noyaux de système
d'exploitation sont écrits par des humains, qui ne sont pas parfaits. Loin de
là: on estime qu'avant relecture, 1000 lignes de code contiennent entre 5 et 100
erreurs de programmation en moyenne.
% TODO sourcer
Les activités de relecture et de
débogage ont beau prendre la majeure partie du temps de développement, elles ne
laissent pas un logiciel de qualité parfaite à la sortie. En effet,
même avec des tests les plus exhaustifs il n'est pas possible de simuler le code
d'une manière qui recouvre tous les cas d'utilisation et permette de s'assurer
de sa correction.

% TODO [E] Attention au politiquement correct
De plus, les tests ne permettent que de s'assurer qu'une erreur est présente.
S'assurer qu'un programme est correct est particulièrement délicat, et ne peut
pas être fait automatiquement dans le cas général.

Le typage statique permet d'associer à chaque fragment d'un programme, une
étiquette décrivant quel genre de valeur sera produite par son évaluation. Cette
analyse, faite à la compilation, permet de rejeter les programmes incorrects du
point de vue de cette catégorisation.

\section{Rôle d'un système d'exploitation}

On décrit ici la fonction générale d'un système d'exploitation. Ce sujet est
détaillé en profondeur, y compris avec des cas d'étude, dans~\cite{tanenbaum}.

Un ordinateur est constitué de nombreux composants matériels : microprocesseur,
mémoire, et divers périphériques. Pourtant, au niveau de l'utilisateur, des
dizaines de logiciels permettent d'effectuer toutes sortes de calculs et de
communications. Le système d'exploitation permet de faire l'interface entre ces
niveaux d'abstraction.

Au cours de l'histoire des systèmes informatiques, la manière de les programmer
a beaucoup évolué. Au départ, les programmeurs avaient accès au matériel dans
son intégralité : toute la mémoire pouvait être accédée, toutes les instructions
pouvaient être utilisées.

Néanmoins c'est un peu restrictif, puisque cela ne permet qu'à une personne
d'interagir avec le système. Dans la seconde moitié des années 60, sont apparus
les premiers systèmes ``à temps partagé'', permettant à plusieurs utilisateurs
de travailler en même temps.

Permettre l'exécution de plusieurs programmes en même temps est une idée
révolutionnaire, mais elle n'est pas sans difficultés techniques : en effet les
ressources de la machine doivent être aussi partagées entre les utilisateurs et
les programmes. Par exemple, plusieurs programmes vont utiliser le processeur
les uns à la suite des autres ; et chaque programme aura à sa disposition une
partie de la mémoire principale, ou du disque dur.

Si deux programmes (ou plus) s'exécutent de manière concurrente sur le même
matériel, il faut s'assurer que l'un ne puisse pas écrire dans la mémoire de
l'autre, ou que les deux n'utilisent pas la carte réseau en même temps. Ce sont
des rôles du système d'exploitation.

Ainsi, au lieu d'accéder directement au matériel via des instructions de bas
niveau, les programmes communiquent avec le noyau, qui centralise donc les
appels au matériel, et abstrait certaines opérations.

Par exemple, comparons ce qui se passe concrètement lors de la copie de données
depuis un cédérom ou une mémorette USB.

\begin{itemize}

  \item Dans le cas du cédérom, il faut interroger le bus SATA, interroger le
    lecteur sur la présence d'un disque dans le lecteur, activer le moteur,
    calculer le numéro de trame des données sur le disque, demander la lecture,
    puis déclencher une
    copie de la mémoire.

  \item Avec une mémorette USB, il faut interroger le bus USB, rechercher le bon
    numéro de périphérique, le bon numéro de canal dans celui-ci, lui appliquer
    une commande de lecture au bon numéro de bloc, puis copier la mémoire.

\end{itemize}

Ces deux opérations, bien qu'elles aient le même but (copier de la mémoire
depuis un périphérique amovible), ne sont pas effectuées de la même manière.
C'est pourquoi le système d'exploitation fournit les notions de fichier,
lecteur, etc : le programmeur n'a plus qu'à utiliser des commandes de haut
niveau (``monter un lecteur'', ``ouvrir un fichier'', ``lire dans un fichier'')
et selon le type de lecteur, le système d'exploitation effectuera les actions
appropriées.

En résumé, un système d'exploitation est l'intermédiaire entre le logiciel et
le matériel, et en particulier assure les rôles suivants :

% TODO À affiner ou supprimer

\begin{itemize}
\item
  Gestion des processus : un système d'exploitation peut permettre
  d'exécuter plusieurs programmes à la fois. Il faut alors orchestrer
  ces différents processus et les séparer en terme de temps et de
  ressources partagées.
\item
  Gestion de la mémoire : chaque processus, en plus du noyau, doit
  disposer d'un espace mémoire différent. C'est-à-dire qu'un processus
  ne doit pas pouvoir interférer avec un autre.
\item
  Gestion des fichiers : les processus peuvent accéder à une hiérarchie de
  fichiers, indépendamment de la manière d'y accéder.
\item
  Gestion des périphériques : le noyau étant le seul code ayant des privilèges,
  c'est lui qui doit communiquer avec les périphériques matériels.
\item
  Abstractions : le noyau fournit aux programmes une interface unifiée,
  permettant de stocker des informations de la même manière sur un
  disque dur ou une clef USB (alors que l'accès se déroulera de manière
  très différente en pratique).
\end{itemize}


\section{Noyaux de systèmes d'exploitation}

Les programmes qui composent un système d'exploitation sont exécutés avec un
niveau de privilège différent, correspondant à un jeu d'instructions plus ou
moins important. Cette vérification est faite directement pas le processeur,
d'une manière matérielle. En plus de cette distinction, les programmes ont une
vue différente de la mémoire. Si un programme utilisateur avait accès aux
structures de données internes du noyau, il pourrait obtenir des informations
auquel il n'a pas normalement accès, ou obtenir des privilège supplémentaires
(par exemple en obtenant les privilèges de l'administrateur sur la machine).

C'est pourquoi les noyaux stockent leur code et données dans un endroit en
mémoire qui n'est pas accessible aux programmes utilisateur. Sur un système
Intel 32 bits, cela correspond aux adresses supérieures à \texttt{0xc0000000},
ou 3 Gio.

% TODO trad

Because user-mode programs cannot run low-level instructions, they cannot do
anything interesting on their own. They have to use the kernel's facilities to
perform input/output or manipulate the operating system's abstractions (such as
creating a new process). To this end, they can communicate with the kernel
via the narrow interface of \emph{system calls}.

For example, every time a user process calls the \texttt{read()} function, an
architecture-specific mechanism invokes the kernel-mode function
\texttt{sys\_read()}. The user passes a file descriptor, a pointer and an amount
of bytes to fill and the kernel will actually perform input/output and copy the
resulting bytes on the user's buffer.

But if the user supplies a pointer whose value is in the kernel's reserved area,
this zone will be overwritten, potentially leading to a security breach. In a
sense, the kernel has been abused because it accessed the memory with its own
privileges instead of the originator's. This is known as the \emph{confused
deputy problem}\cite{hardy88confused}.

When implementing a system call, it is thus necessary to forbid direct
dereference of a pointer whose value can be controlled by the user. In case of a
system call with a pointer argument, one has to dynamically verify that the
address provided by the user lies within the process's memory space.

The object of this work is to detect the places where it is necessary to insert
dynamic checks. To this end, we augment the type system of a subset of the C
programming language with \emph{type qualifiers}: instead of having a single
pointer type, we add syntactic rules to distinguish between safe pointers that
can be dereferenced with the \texttt{*}, \texttt{->} and \texttt{[]} operators ;
and unsafe pointers that have to go through a special API provided by the
kernel, consisting most notably of the two functions \texttt{copy\_from\_user}
and \texttt{copy\_to\_user}.

\section{Systèmes de types}

\section{Langages d'implantation}

\section{Langages d'analyse}

Le langage C \cite{KandR,AnsiC} a été conçu pour être une sorte d'assembleur
portable, permettant décrire du code indépendamment de l'architecture sur
laquelle il sera compilé. Historiquement, c'est il a permis de créer Unix, et
ainsi de nombreux logiciels bas niveau sont écrits en C. En particulier, il
existe des compilateurs de C vers les différents langages machine pour à peu
près toutes les architectures.

\begin{figure}
  \centering

  \input{fig/middle-end.tex}

  \caption{Décomposition d'un compilateur : front-ends, middle-end, back-ends}
  \label{fig:middle-end}
\end{figure}

Lors de l'écriture d'un compilateur, on a besoin d'un langage intermédiaire qui
fasse l'intermédiaire entre \emph{front-end} et \emph{back-end}
(figure~\ref{fig:middle-end}). Depuis ce langage on doit pouvoir exprimer des
transformations intermédiaires sur cette représentation (analyses sémantiques,
optimisations, etc), mais aussi compiler ce langage vers un langage machine.

L'idée de prendre C comme langage intermédiaire est très séduisante, mais
malheureusement sa sémantique est trop complexe et trop peu spécifiée. Il est
donc judicieux d'utiliser un langage plus simple à cet effet. Dans de nombreux
projets, des sous-ensembles de C ont été définis pour aller dans ce sens.

Les premiers candidats sont bien entendu les représentations intermédiaires
utilisées dans les compilateurs C. Elles ont l'avantage d'accepter en plus du C
standard, les diverses extensions (GNU, Microsoft, Plan9) utilisées par la
plupart des logiciels. En particulier, le noyau Linux repose fortement sur les
extensions GNU.

\paragraph{GCC} utilise une représentation interne nommée
GIMPLE\cite{gcc-gimple}. Il s'agit d'une structure d'arbre écrite en C, reposant
sur de nombreuses macros afin de cacher les détails d'implémentation pouvant
varier entre deux versions de GCC. Cette représentation étant réputée difficile
à manipuler, le projet MELT\cite{gcc-melt} permet de générer une passe de
compilation à partir d'un dialecte de Lisp.

\paragraph{LLVM}\cite{llvm-pres} est un compilateur développé par la communauté
puis sponsorisé Apple. À la différence de GCC, sa base de code est écrite en
C++. Il utilise une représentation intermédiaire qui peut être manipulée soit
sous forme d'une structure de données C++, soit d'un fichier de code-octet
compact, soit sous forme textuelle.

\paragraph{Objective Caml}\link{ocamlManual} utilise pour sa génération de code
une représentation interne nommée Cmm, disponible dans les sources du
compilateur sous le chemin \texttt{asmcomp/cmm.mli} (il s'agit donc d'une
structure de données OCaml). Ce langage a l'avantage d'être très restreint, mais
malheureusement il n'existe pas directement de traducteur permettant de compiler
C vers Cmm.

\paragraph{C-~-}\cite{spjcmm} \link{cmm}, dont le nom est inspiré du précédent,
est un projet qui visait à unifier les langages intermédiaires utilisés par les
compilateurs. L'idée est que si un front-end peut émettre du C-~- (sous forme de
texte), il est possible d'obtenir du code machine efficace. Le compilateur
Haskell GHC utilise une représentation intermédiaire très similaire à C-~-.

Comme le problème de construire une représentation intermédiaire adaptée à une
analyse statique n'est pas nouveau, plusieurs projets ont déjà essayé d'y
apporter une solution. Puisque qu'ils sont développés en parallèle des
compilateurs, le support des extensions est en général moins important dans ces
langages.

\paragraph{CIL}\cite{NeculaCil} \link{kerneisCil} est une représentation en
OCaml d'un programme C, développée depuis 2002. Grâce à un mécanisme de
greffons, elle permet de prototyper rapidement des analyses statiques de
programmes.

\paragraph{Compcert} est un projet qui vise à produire un compilateur certifié
pour C. C'est à dire que le fait que les transformations conservent la
sémantique est prouvé. Il utilise de nombreux langages intermédiaires, dont CIL.
Pour le front-end, le langage se nomme Clight\cite{cfront}. Les passes de
middle-end, quant à elles, utilisent Cminor\cite{cminorSL}.

\paragraph{Newspeak}\cite{newspeak} est un langage intermédiaire développé par
EADS Innovation Works, et qui est spécialisé dans l'analyse de valeurs par
interprétation abstraite. Il sera décrit plus en détails dans la
section~\ref{sec:npk}.

\section{Plan de la thèse}

Cette thèse comporte trois parties.

\paragraph{La partie~\ref{part:ctx}} présente le contexte de ces travaux. Le
fonctionnement général d'un système d'exploitation y est détaillé, et les
problèmes de manipulation de pointeurs contrôlés par l'utilisateur y sont
introduits. On fait ensuite un tour d'horizon des techniques existantes
permettant de traiter ce problème.

\paragraph{La partie~\ref{part:lang}} décrit notre solution : \langname, un
langage impératif. On y décrit sa syntaxe, sa sémantique ainsi qu'un système de
types statiques. On l'étend ensuite pour capturer les problèmes d'adressage
mémoire présents dans les systèmes d'exploitation en ajoutant des pointeurs
contrôlés par l'utilisateur. Le système de types est également étendu. Pour
chacune de ces variantes, on établit la propriété de sûreté de typage reliant la
sémantique dynamique aux types statiques.

\paragraph{La partie~\ref{part:xp}} documente la démarche expérimentale associée
à ces travaux. L'implantation du système de types est décrite, afin que la
manière de transformer automatiquement du code C en \langname. Un cas d'étude
est déroulé, consistant d'un bug ayant touché le noyau Linux. Il est démontré
que le système de type capture précisément ce genre d'erreur de programmation.
Enfin, les possibilités d'extension tant théoriques qu'expérimentales sont
présentées.

%  - omniprésence
%  - complexité
%  - vérification
%  - taux de bugs après relecture
%  - vérification automatique obligatoire
%  - historique des techniques
%  - analyse non intrusive
%  - méthodes de développement du noyau
%  - syntaxe, sémantique, typage

% vim: spelllang=fr
