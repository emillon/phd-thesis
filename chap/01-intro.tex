Communication,
audiovisuel,
transports,
médecine :
tout ces domaines se sont transformés dans les dernières décennies,
en particulier grâce à la révolution numérique.
En effet le plus petit appareil électrique contient maintenant des composants
matériels programmables.

% TODO faire une intro "la vie est numérique" avec du Berry @ CdF

En 2013, on pense bien sûr aux téléphones portables dont la fonctionnalité et la
complexité les rapprochent des ordinateurs de bureau. Par exemple, le système
d'exploitation Android de Google est basé sur le noyau Linux, destiné à la base
aux micro-ordinateurs.

Le noyau d'un système d'exploitation est chargé de faire l'intermédiaire entre
le matériel (processeur, mémoire, périphériques, …) et les applications
exécutées sur celui-ci (par exemple un navigateur web, une calculatrice ou un
carnet d'adresses). Il doit aussi garantir la sécurité et l'isolation de
celles-ci.

En tant qu'intermédiaire de confiance, le noyau a un certain nombre de
responsabilités et est le seul à avoir accès à certaines informations sensibles.
Il est capital de s'assurer qu'il est bien le seul à pouvoir y accéder. En
particulier, il faut pouvoir vérifier que les requêtes faites par l'utilisateur
au noyau ne peuvent pas détourner ce dernier et lui faire fuiter des
informations confidentielles.

Le problème est que comme tous les logiciels, les noyaux de système
d'exploitation sont écrits par des humains, qui ne sont pas parfaits. Loin de
là: on estime qu'avant relecture, 1000 lignes de code contiennent entre 5 et 100
erreurs de programmation en moyenne.
% TODO sourcer
Les activités de relecture et de
débogage ont beau prendre la majeure partie du temps de développement, il est
facile de laisser passer des défauts de programmation.

Une technique efficace est de réaliser des tests, c'est-à-dire exécuter le code
du programme sous un environnement contrôlé. On peut alors détecter des
comportements non désirés. Mais même avec des tests les plus exhaustifs il n'est
pas possible de couvrir tous les cas d'utilisation.

Parmi les techniques communes pour éliminer les ``bugs'', on peut ajouter à un
langage de programmation un \emph{système de types statiques}.

Celui-ci permet d'associer à chaque fragment d'un programme, une étiquette
décrivant quel genre de valeur sera produite par son évaluation. Cette analyse,
faite à la compilation, permet de rejeter les programmes incorrects du point de
vue de cette catégorisation.

Le but de cet thèse est de montrer que le typage statique peut être utilisé pour
détecter et interdire certains bugs présents dans les noyaux de systèmes
d'exploitation.

\section{Rôle d'un système d'exploitation}

On décrit ici la fonction générale d'un système d'exploitation. Ce sujet est
détaillé en profondeur, y compris avec des cas d'étude, dans~\cite{tanenbaum}.

Un ordinateur est constitué de nombreux composants matériels : microprocesseur,
mémoire, et divers périphériques. Pourtant, au niveau de l'utilisateur, des
dizaines de logiciels permettent d'effectuer toutes sortes de calculs et de
communications. Le système d'exploitation permet de faire l'interface entre ces
niveaux d'abstraction.

Au cours de l'histoire des systèmes informatiques, la manière de les programmer
a beaucoup évolué. Au départ, les programmeurs avaient accès au matériel dans
son intégralité : toute la mémoire pouvait être accédée, toutes les instructions
pouvaient être utilisées.

Néanmoins c'est un peu restrictif, puisque cela ne permet qu'à une personne
d'interagir avec le système. Dans la seconde moitié des années 60, sont apparus
les premiers systèmes ``à temps partagé'', permettant à plusieurs utilisateurs
de travailler en même temps.

Permettre l'exécution de plusieurs programmes en même temps est une idée
révolutionnaire, mais elle n'est pas sans difficultés techniques : en effet les
ressources de la machine doivent être aussi partagées entre les utilisateurs et
les programmes. Par exemple, plusieurs programmes vont utiliser le processeur
les uns à la suite des autres ; et chaque programme aura à sa disposition une
partie de la mémoire principale, ou du disque dur.

Si deux programmes (ou plus) s'exécutent de manière concurrente sur le même
matériel, il faut s'assurer que l'un ne puisse pas écrire dans la mémoire de
l'autre, ou que les deux n'utilisent pas la carte réseau en même temps. Ce sont
des rôles du système d'exploitation.

Ainsi, au lieu d'accéder directement au matériel via des instructions de bas
niveau, les programmes communiquent avec le noyau, qui centralise donc les
appels au matériel, et abstrait certaines opérations.

Par exemple, comparons ce qui se passe concrètement lors de la copie de données
depuis un cédérom ou une mémorette USB.

\begin{itemize}

  \item Dans le cas du cédérom, il faut interroger le bus SATA, interroger le
    lecteur sur la présence d'un disque dans le lecteur, activer le moteur,
    calculer le numéro de trame des données sur le disque, demander la lecture,
    puis déclencher une
    copie de la mémoire.

  \item Avec une mémorette USB, il faut interroger le bus USB, rechercher le bon
    numéro de périphérique, le bon numéro de canal dans celui-ci, lui appliquer
    une commande de lecture au bon numéro de bloc, puis copier la mémoire.

\end{itemize}

Ces deux opérations, bien qu'elles aient le même but (copier de la mémoire
depuis un périphérique amovible), ne sont pas effectuées de la même manière.
C'est pourquoi le système d'exploitation fournit les notions de fichier,
lecteur, etc : le programmeur n'a plus qu'à utiliser des commandes de haut
niveau (``monter un lecteur'', ``ouvrir un fichier'', ``lire dans un fichier'')
et selon le type de lecteur, le système d'exploitation effectuera les actions
appropriées.

En résumé, un système d'exploitation est l'intermédiaire entre le logiciel et
le matériel, et en particulier assure les rôles suivants :

% TODO À affiner ou supprimer

\paragraph{Gestion des processus}

Un système d'exploitation peut permettre d'exécuter plusieurs programmes à la
fois. Il faut alors orchestrer ces différents processus et les séparer en terme
de temps et de ressources partagées.

\paragraph{Gestion de la mémoire}

Chaque processus, en plus du noyau, doit disposer d'un espace mémoire différent.
C'est-à-dire qu'un processus ne doit pas pouvoir interférer avec un autre.

\paragraph{Gestion des fichiers}

Les processus peuvent accéder à une hiérarchie de fichiers, indépendamment de la
manière d'y accéder.

\paragraph{Gestion des périphériques}

Le noyau étant le seul code ayant des privilèges, c'est lui qui doit communiquer
avec les périphériques matériels.

\paragraph{Abstractions}

Le noyau fournit aux programmes une interface unifiée, permettant de stocker des
informations de la même manière sur un disque dur ou une clef USB (alors que
l'accès se déroulera de manière très différente en pratique).

\section{Noyaux de systèmes d'exploitation}

% TODO [E] ??? privilèges ?

Les programmes qui composent un système d'exploitation sont exécutés avec un
niveau de privilège différent, correspondant à un jeu d'instructions plus ou
moins important. Cette vérification est faite directement pas le processeur,
d'une manière matérielle. En plus de cette distinction, les programmes ont une
vue différente de la mémoire. Si un programme utilisateur avait accès aux
structures de données internes du noyau, il pourrait obtenir des informations
auquel il n'a pas normalement accès, ou obtenir des privilège supplémentaires
(par exemple en obtenant les privilèges de l'administrateur sur la machine).

C'est pourquoi les noyaux stockent leur code et données dans un endroit en
mémoire qui n'est pas accessible aux programmes utilisateur. Sur un système
Intel 32 bits, cela correspond aux adresses supérieures à \texttt{0xc0000000},
ou 3 Gio.

% TODO trad

Because user-mode programs cannot run low-level instructions, they cannot do
anything interesting on their own. They have to use the kernel's facilities to
perform input/output or manipulate the operating system's abstractions (such as
creating a new process). To this end, they can communicate with the kernel
via the narrow interface of \emph{system calls}.

For example, every time a user process calls the \texttt{read()} function, an
architecture-specific mechanism invokes the kernel-mode function
\texttt{sys\_read()}. The user passes a file descriptor, a pointer and an amount
of bytes to fill and the kernel will actually perform input/output and copy the
resulting bytes on the user's buffer.

But if the user supplies a pointer whose value is in the kernel's reserved area,
this zone will be overwritten, potentially leading to a security breach. In a
sense, the kernel has been abused because it accessed the memory with its own
privileges instead of the originator's. This is known as the \emph{confused
deputy problem}\cite{hardy88confused}.

When implementing a system call, it is thus necessary to forbid direct
dereference of a pointer whose value can be controlled by the user. In case of a
system call with a pointer argument, one has to dynamically verify that the
address provided by the user lies within the process's memory space.

% TODO [E] est-ce ici que tu veux le placer ? rien ne t'empêche de le dire
% plusieurs fois

The object of this work is to detect the places where it is necessary to insert
dynamic checks. To this end, we augment the type system of a subset of the C
programming language with \emph{type qualifiers}: instead of having a single
pointer type, we add syntactic rules to distinguish between safe pointers that
can be dereferenced with the \texttt{*}, \texttt{->} and \texttt{[]} operators ;
and unsafe pointers that have to go through a special API provided by the
kernel, consisting most notably of the two functions \texttt{copy\_from\_user}
and \texttt{copy\_to\_user}.

\section{Systèmes de types}

La plupart des langages de programmation incorporent la notion de type, qui
permet de détecter ou d'empêcher de manipuler des données incompatibles entre
elles.

Nous avons vu dans le chapitre~\ref{cha:os} qu'au niveau du langage machine, les
seules données qu'un ordinateur manipule sont des nombres. Selon les opérations
effectuées, ils seront interprétés comme des entiers, des adresses mémoires, ou
des caractères. Pourtant il est clair que certaines opérations n'ont pas de
sens: par exemple, ajouter deux adresses, ou déréférencer le résultat d'une
division sont des comportements qu'on voudrait pouvoir empêcher.

En un mot, le but du typage est de classifier les objets et de restreindre les
opérations possibles selon la classe d'un objet : ``ne pas ajouter des pommes et
des oranges''. Le modèle qui permet cette classification est appelé
\emph{système de types} et est en général constitué d'un ensemble de
\emph{règles de typage}, comme ``un entier plus un entier égale un entier''.

Il y a deux grandes familles de systèmes de types, selon quand se fait la
vérification de types. On peut en effet l'effectuer au moment de l'exécution, ou
au contraire prévenir les erreurs à l'exécution en la faisant au moment de la
compilation (ou avant l'interprétation).

\paragraph{Typage dynamique :} dans ce cas, chaque valeur manipulée par le
programme est décorée d'une étiquette définissant comment interpréter la valeur
en question. Les règles de typage sont alors réalisées à l'exécution. Par
exemple, l'opérateur "$+$" vérifie que ces deux opérandes ont une étiquette
"entier", et construit alors une valeur obtenue en faisant l'addition des deux
valeurs, avec une étiquette "entier". Symboliquement :

\begin{verbatim}
fonction addition(x, y) {
  if ( (etiquette_type(x) != type_entier)
    || (etiquette_type(y) != type_entier)
    ) {
      erreur ("L'addition est seulement définie pour deux entiers")
  } else {
    vx = valeur(x)
    vy = valeur(y)
    v = addition_machine(vx, vy)
    return Valeur(valeur=v, type=type_entier)
  }
}
\end{verbatim}

Le langage Python~\link{python} utilise cette stratégie, qui est illustrée dans
la session interactive de la figure~\ref{fig:typage-dynamique}.

\begin{figure}
  \insertcode{typage-dynamique.pycon}
  \caption{Session Python présentant le typage dynamique}
  \label{fig:typage-dynamique}
\end{figure}

L'analyse de taintage consiste à ajouter des étiquettes au données décrivant
leur provenance, de manière à ce que chaque accès dangereux soit vérifié à
l'exécution. Cela se marie bien avec les langages typés dynamiquement, comme le
montre l'exemple célèbre du mode ``souillé'' (\emph{tainted}) de
Perl~\cite{perlCamelBook}. Il est aussi possible, mais plus délicat, d'appliquer
cette technique à des langages compilés~\cite{clause-etal-issta07,oakland10}.
% TODO [E]: à préciser

\paragraph{Typage statique :} dans ce cas on fait les vérifications à la
compilation. En quelque sorte, l'approche dynamique est pessimiste, puisqu'elle
demande de traiter très souvent le cas où les types ne sont pas corrects.
Intuitivement, dans le cas où toutes les fonctions se comportent bien, faire la
vérification est inutile. Pour vérifier ceci, on donne à chaque fonction un
contrat comme "si deux entiers sont passés, le fonction renverra un entier sans
provoquer d'erreur". Cet ensemble de contrats peut être vérifié statiquement par
le compilateur, à l'aide d'un système de types statique.

% TODO [E]: division par zéro

Ainsi la fonction "$+$" est typée \texttt{(int * int)} $→$ \texttt{int}. Les
règles permettant de vérifier le typage sont par exemple les suivantes :

\begin{itemize}
\item
  une constante entière est toujours de type \texttt{int}.
\item
  si $f$ a pour type $(t_1, …, t_n) → t$, et que chaque $e_i$ a pour type $t_i$
  ($i ∈ [1;n]$), alors $f(e_1, …, e_n)$ a pour type $t$.
\item
  si en considérant que chaque $e_i$ a pour type $t_i$ ($i ∈ [1;n]$),
  on arrive à typer le corps de $f$ et que sa valeur de retour a alors
  pour type $t$,
  alors $f$ a pour type $(t_1, …, t_n) → t$.
\end{itemize}

Cet ensemble de règles, une fois formalisé et implanté, est en général assez
efficace pour vérifier la correction d'un programme.
% TODO [E] ?

\paragraph{Typage fort ou faible :}

Si un système de types statique permet d'éliminer totalement la nécessité de
réaliser des tests de typage, on dit qu'il est \emph{fort}. Mais ce n'est que
rarement le cas. En effet, il peut y avoir des constructions au sein du langage
qui permettent de contourner le système de types, comme un opérateur de
transtypage\ref{fig:javacast}. À l'exécution, une erreur de types est levée :

\begin{figure}
  \insertcode{cast.java}
  \caption{Transtypage en Java}
  \label{fig:javacast}
\end{figure}

\begin{Verbatim}
Exception in thread "main" java.lang.ClassCastException:
    java.lang.Integer cannot be cast to java.lang.Float
        at Cast.main(Cast.java:5)
\end{Verbatim}

\paragraph{Polymorphisme :} parfois, il est trop restrictif de donner un unique
contrat à une fonction. Quel doit être le type d'une fonction ajoutant un
élément à une liste ?

En première approximation, on peut imaginer fournir une version du code par type
de données à manipuler. C'est la solution retenue par les premières versions du
langage Pascal, ce qui rendait très difficile l'écriture de
bibliothèques\cite{PascalNoEscape}.

Une amélioration peut être de générer à la compilation une fonction qui aurait
le même code mais des annotations de typage différentes : on obtient alors
plusieurs copies de la fonction qui sont chacunes spécialisées pour un type en
particulier. C'est la solution retenue par le langage C++ et son système de
\emph{templates}.

En fait, si à l'exécution toutes les données sont représentées de manière
uniforme, il n'est pas nécessaire de créer plusieurs copies de la fonction.

\begin{figure}
  \insertcode{listappend.ml}
  \caption{Fonction de concaténation de listes en OCaml.}
  \label{fig:listappend}
\end{figure}

Par exemple, la fonction de la figure~\ref{fig:listappend} n'opère que sur la
structure du type liste (en utilisant ses constructeurs \texttt{{[}{]}} et
\listcons ainsi que le filtrage) : les éléments de \texttt{lx} et \texttt{ly} ne
sont pas manipulés à part pour les transférer dans le résultat.

% TODO [E] tu parles uniquement du polymorphisme paramétrique : attention il y a
% la classe de polymorphisme et son implantation qui peuvent diverger

Elle peut donc être typée avec n'importe quelle type 
$a~\textrm{list} → a~\textrm{list} → a~\textrm{list}$. Pour introduire cette
généricité, on modifie le système de types pour transformer :

\[ ∀ a. \textrm{append} :
   a~\textrm{list} → a~\textrm{list} → a~\textrm{list}
\]

en :

\[ \textrm{append} : ∀ a.
   a~\textrm{list} → a~\textrm{list} → a~\textrm{list}
\]

% TODO [E] que veux tu dire ?

% TODO [E] où la variable de types peut prendre n'importe quelle valeur de type

Au lieu d'associer à chaque expression un type, dans certains cas on lui associe
un schéma de types, instanciable en un type concret. En quelque sorte, on
déplace la vérification du site d'appel au site de définition. Cette technique a
été décrite en premier dans~\cite{Milner78}.
Un tour d'horizon de différents types statiques, avec en particulier du
polymorphisme, on pourra se référer à~\cite{TAPL}.

\paragraph{Expressivité :} les systèmes de types les plus simples expriment des
contrats esssentiellement liés à la sûreté d'exécution, pour ne pas utiliser des
valeurs de types incompatibles entre eux. Mais il est possible d'étendre le
langage avec des annotations plus riches : par exemple en vérifiant statiquement
que des listes ne sont pas vides\cite{lightweight-static-capabilities}, ou dans
le domaine de la sécurité, d'empêcher des fuites d'information~\cite{LZ06a}.

\paragraph{Qualificateurs de types :} Dans le cas particulier des vulnérabilités
liées à une mauvaise utilisation de la mémoire, les développeurs du noyau Linux
ont ajouté un système d'annotations au code source. Un pointeur peut être décoré
d'une annotation \texttt{\_\_kernel} ou \texttt{\_\_user} selon s'il est sûr ou
pas. Celle-ci sont ignorées par le compilateur, mais un outil d'analyse statique
ad-hoc nommé Sparse~\link{sparse}~\cite{TorvaldsSparse} % TODO citer un seul
peut être utilisé pour détecter les cas les plus simples d'erreurs.
Il demande aussi au programmeur d'ajouter beaucoup d'annotations dans le
programme. % TODO quantifier

Ce système d'annotations sur les types a été formalisé sous le nom de
\emph{qualificateurs de types} : chaque type peut être décoré d'un ensemble de
qualificateurs (à la manière de \texttt{const}), et des règles de typage
permettent d'établir des propriétés sur le programme. Ces analyses ont été
implantée dans l'outil CQual~\cite{toplas-quals}. Ce système peut servir à
inférer les annotations \texttt{const}~\cite{pldi99}, à l'analyse de souillure
pour les chaîne de format~\cite{usenix01} % TODO citer Newsham sur le format ?
et des propriétés dépendantes du flot de contrôle, comme des invariants sur les
verrous~\cite{pldi02}, à rapprocher du concept de \emph{typestates}
~\cite{tse12-typestate}. Il a également été appliqué à la classe de
vulnérabilités sur les pointeurs utilisateurs dont il est ici
l'objet~\cite{cquk-usenix04}. Puisqu'elle consiste à ajouter un qualificateur à
chaque étage de type, cette approche est plus générique mais plus complexe que
la nôtre. % TODO bof

% TODO [E] préciser pourquoi

\section{Langages d'implantation}

% TODO C

Le langage C~\cite{KandR} présente des difficultés pour être analysé
automatiquement.

\begin{itemize}
\item les nombres flottants
(types \texttt{float}, \texttt{double} et \texttt{long double}) ont une
sémantique particulière, et il n'est pas correct d'approcher leur sémantique
par une sémantique dans $ℝ$. Afin d'être correct, il faut établir des domaines
spécifiques au flottant, comme~\cite{floatpoly}. Un tour d'horizon des
difficultés liées aux flottants est effectué dans~\cite{floatpitfalls}.

\item les pointeurs sur fonction
rendent floue la limite qui est habituellement présente entre instructions et
données. En leur présence il est impossible de faire une analyse de flot de
contrôle indépendante du flot de données. Pour pouvoir les traiter, il faut que
le domaine abstrait en question soit assez précis pour qu'un pointeur abstrait
se concrétise en un ensemble réduit de fonctions. Dans le cas où le domaine ne
peut pas borner l'ensemble des fonctions possibles et renvoie $\top$, l'analyse
ne peut pas continuer.

\item l'allocation dynamique
de données, présente dans le langage C par le biais des fonctions
\texttt{malloc} et \texttt{free}, modifie le modèle mémoire
nécessaire. Sans celle-ci, l'ensemble des zones mémoire possibles peut être
décrit statiquement : ce sont les noms de variable. Ce qu'introduit
\texttt{malloc} au langage, c'est une zone mémoire qui n'a pas de nom, et sur
laquelle on n'a qu'un pointeur.

% TODO, bof + expand

\item le transtypage (\emph{casts}) entre entiers et pointeurs
est particulièrement délicat à traiter. Dans les modèles abstraits, les
pointeurs sur données ou sur fonctions n'ont pas de représentation numérique,
seulement une représentation symbolique. Même dans l'exécution concrète, la
représentation numérique d'un pointeur est lié à de nombreux choix faits par
l'environnement d'exécution (comme la randomisation de l'espace d'adressage) qui
ne peuvent pas facilement être modélisés.

\end{itemize}

% TODO Ada

% TODO ASM

% TODO Rust

\section{Langages d'analyse}

Le langage C \cite{KandR,AnsiC} a été conçu pour être une sorte d'assembleur
portable, permettant décrire du code indépendamment de l'architecture sur
laquelle il sera compilé. Historiquement, c'est il a permis de créer Unix, et
ainsi de nombreux logiciels bas niveau sont écrits en C. En particulier, il
existe des compilateurs de C vers les différents langages machine pour à peu
près toutes les architectures.

\begin{figure}
  \centering

  \input{fig/middle-end.tex}

  \caption{Décomposition d'un compilateur : front-ends, middle-end, back-ends}
  \label{fig:middle-end}
\end{figure}

Lors de l'écriture d'un compilateur, on a besoin d'un langage intermédiaire qui
fasse l'intermédiaire entre \emph{front-end} et \emph{back-end}
(figure~\ref{fig:middle-end}). Depuis ce langage on doit pouvoir exprimer des
transformations intermédiaires sur cette représentation (analyses sémantiques,
optimisations, etc), mais aussi compiler ce langage vers un langage machine.

L'idée de prendre C comme langage intermédiaire est très séduisante, mais
malheureusement sa sémantique est trop complexe et trop peu spécifiée. Il est
donc judicieux d'utiliser un langage plus simple à cet effet. Dans de nombreux
projets, des sous-ensembles de C ont été définis pour aller dans ce sens.

Les premiers candidats sont bien entendu les représentations intermédiaires
utilisées dans les compilateurs C. Elles ont l'avantage d'accepter en plus du C
standard, les diverses extensions (GNU, Microsoft, Plan9) utilisées par la
plupart des logiciels. En particulier, le noyau Linux repose fortement sur les
extensions GNU.

\paragraph{GCC} utilise une représentation interne nommée
GIMPLE\cite{gcc-gimple}. Il s'agit d'une structure d'arbre écrite en C, reposant
sur de nombreuses macros afin de cacher les détails d'implémentation pouvant
varier entre deux versions de GCC. Cette représentation étant réputée difficile
à manipuler, le projet MELT\cite{gcc-melt} permet de générer une passe de
compilation à partir d'un dialecte de Lisp.

\paragraph{LLVM}\cite{llvm-pres} est un compilateur développé par la communauté
puis sponsorisé Apple. À la différence de GCC, sa base de code est écrite en
C++. Il utilise une représentation intermédiaire qui peut être manipulée soit
sous forme d'une structure de données C++, soit d'un fichier de code-octet
compact, soit sous forme textuelle.

\paragraph{Objective Caml}\link{ocamlManual} utilise pour sa génération de code
une représentation interne nommée Cmm, disponible dans les sources du
compilateur sous le chemin \texttt{asmcomp/cmm.mli} (il s'agit donc d'une
structure de données OCaml). Ce langage a l'avantage d'être très restreint, mais
malheureusement il n'existe pas directement de traducteur permettant de compiler
C vers Cmm.

\paragraph{C-~-}\cite{spjcmm} \link{cmm}, dont le nom est inspiré du précédent,
est un projet qui visait à unifier les langages intermédiaires utilisés par les
compilateurs. L'idée est que si un front-end peut émettre du C-~- (sous forme de
texte), il est possible d'obtenir du code machine efficace. Le compilateur
Haskell GHC utilise une représentation intermédiaire très similaire à C-~-.

Comme le problème de construire une représentation intermédiaire adaptée à une
analyse statique n'est pas nouveau, plusieurs projets ont déjà essayé d'y
apporter une solution. Puisque qu'ils sont développés en parallèle des
compilateurs, le support des extensions est en général moins important dans ces
langages.

\paragraph{CIL}\cite{NeculaCil} \link{kerneisCil} est une représentation en
OCaml d'un programme C, développée depuis 2002. Grâce à un mécanisme de
greffons, elle permet de prototyper rapidement des analyses statiques de
programmes.

\paragraph{Compcert} est un projet qui vise à produire un compilateur certifié
pour C. C'est à dire que le fait que les transformations conservent la
sémantique est prouvé. Il utilise de nombreux langages intermédiaires, dont CIL.
Pour le front-end, le langage se nomme Clight\cite{cfront}. Les passes de
middle-end, quant à elles, utilisent Cminor\cite{cminorSL}.

\paragraph{Newspeak}\cite{newspeak} est un langage intermédiaire développé par
EADS Innovation Works, et qui est spécialisé dans l'analyse de valeurs par
interprétation abstraite. Il sera décrit plus en détails dans la
section~\ref{sec:npk}.

\section{Plan de la thèse}

Cette thèse comporte trois parties.

\paragraph{La partie~\ref{part:ctx}} présente le contexte de ces travaux. Le
fonctionnement général d'un système d'exploitation y est détaillé, et les
problèmes de manipulation de pointeurs contrôlés par l'utilisateur y sont
introduits. On fait ensuite un tour d'horizon des techniques existantes
permettant de traiter ce problème.

% TODO [E] + proposition

\paragraph{La partie~\ref{part:lang}} décrit notre solution : \langname, un
langage impératif. On y décrit sa syntaxe, sa sémantique ainsi qu'un système de
types statiques. On l'étend ensuite pour capturer les problèmes d'adressage
mémoire présents dans les systèmes d'exploitation en ajoutant des pointeurs
contrôlés par l'utilisateur. Le système de types est également étendu. Pour
chacune de ces variantes, on établit la propriété de sûreté de typage reliant la
sémantique dynamique aux types statiques.

% TODO [E] dire un mot de Newspeak dès l'intro ou l'état de l'art

\paragraph{La partie~\ref{part:xp}} documente la démarche expérimentale associée
à ces travaux. L'implantation du système de types est décrite, afin que la
manière de transformer automatiquement du code C en \langname. Un cas d'étude
est déroulé, consistant d'un bug ayant touché le noyau Linux. Il est démontré
que le système de type capture précisément ce genre d'erreur de programmation.
Enfin, les possibilités d'extension tant théoriques qu'expérimentales sont
présentées.

%  - omniprésence
%  - complexité
%  - vérification
%  - taux de bugs après relecture
%  - vérification automatique obligatoire
%  - historique des techniques
%  - analyse non intrusive
%  - méthodes de développement du noyau
%  - syntaxe, sémantique, typage

% TODO [E] dire au début que c'est tendance Unix si c'est bien le cas

% TODO [E] + besoins EADS

% vim: spelllang=fr
