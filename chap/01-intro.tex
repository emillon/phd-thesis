Communication,
audiovisuel,
transports,
médecine :
tout ces domaines se sont transformés dans les dernières décennies,
en particulier grâce à la révolution numérique.
En effet le plus petit appareil électrique contient maintenant des composants
matériels programmables.

% TODO faire une intro "la vie est numérique" avec du Berry @ CdF

En 2013, on pense bien sûr aux téléphones portables dont la fonctionnalité et la
complexité les rapprochent des ordinateurs de bureau. Par exemple, le système
d'exploitation Android de Google est basé sur le noyau Linux, destiné à la base
aux micro-ordinateurs.

Le noyau d'un système d'exploitation est chargé de faire l'intermédiaire entre
le matériel (processeur, mémoire, périphériques, …) et les applications
exécutées sur celui-ci (par exemple un navigateur web, une calculatrice ou un
carnet d'adresses). Il doit aussi garantir la sécurité de celles-ci.

En tant qu'intermédiaire de confiance, le noyau a un certain nombre de
responsabilités et est le seul à avoir accès à certaines informations sensibles.
Il est capital de s'assurer qu'il est bien le seul à pouvoir y accéder. En
particulier, il faut pouvoir vérifier que les requêtes faites par l'utilisateur
au noyau ne peuvent pas volontairement ou involontairement détourner ce dernier
et lui faire fuiter des informations confidentielles.

Le problème est que comme tous les logiciels, les noyaux de système
d'exploitation sont écrits par des humains, qui ne sont pas parfaits. Loin de
là: on estime qu'avant relecture, 1000 lignes de code contiennent entre 5 et 100
erreurs de programmation en moyenne.
% TODO sourcer
Les activités de relecture et de
débogage ont beau prendre la majeure partie du temps de développement, il est
facile de laisser passer des défauts de programmation.

Une technique efficace est de réaliser des tests, c'est-à-dire exécuter le
programme sous un environnement contrôlé. On peut alors détecter des
comportements non désirés. Mais même avec des tests les plus exhaustifs il n'est
pas possible de couvrir tous les cas d'utilisation.

Une autre approche est d'analyser le code source du programme avant de
l'exécuter et de refuser de lancer les programmes qui contiennent des erreurs,
quitte à limiter la possibilité d'en écrire certains. C'est l'analyse statique
de programmes.

Une des techniques d'analyse statique les plus répandues est le typage statique,
qui consiste à associer à chaque morceau de programme, une étiquette
décrivant quel genre de valeur sera produite par son évaluation. Par exemple, si
$n$ est le nom d'une variable entière, alors $n + 2$ produira toujours une
valeur entière.

Pour garantir l'isolation d'un noyau de système d'exploitation, un des points
cruciaux est de restreindre la manière dont sont traitées les informations
provenant des programmes utilisateur. Le but de cet thèse est de montrer que le
typage statique peut être utilisé pour détecter et interdire ces manipulations
dangereuses.

\section{Rôle d'un système d'exploitation}

Un ordinateur est constitué de nombreux composants matériels : microprocesseur,
mémoire, et divers périphériques. Pourtant, au niveau de l'utilisateur, des
dizaines de logiciels permettent d'effectuer toutes sortes de calculs et de
communications. Le système d'exploitation permet de faire l'interface entre ces
niveaux d'abstraction.

Au cours de l'histoire des systèmes informatiques, la manière de les programmer
a beaucoup évolué. Au départ, les programmeurs avaient accès au matériel dans
son intégralité : toute la mémoire pouvait être accédée, toutes les instructions
pouvaient être utilisées.

Néanmoins c'est un peu restrictif, puisque cela ne permet qu'à une personne
d'interagir avec le système. Dans la seconde moitié des années 60, sont apparus
les premiers systèmes ``à temps partagé'', permettant à plusieurs utilisateurs
de travailler en même temps.

Permettre l'exécution de plusieurs programmes en même temps est une idée
révolutionnaire, mais elle n'est pas sans difficultés techniques : en effet les
ressources de la machine doivent être aussi partagées entre les utilisateurs et
les programmes. Par exemple, plusieurs programmes vont utiliser le processeur
les uns à la suite des autres ; et chaque programme aura à sa disposition une
partie de la mémoire principale, ou du disque dur.

Si deux programmes (ou plus) s'exécutent de manière concurrente sur le même
matériel, il faut s'assurer que l'un ne puisse pas écrire dans la mémoire de
l'autre, ou que les deux n'utilisent pas la carte réseau en même temps. Ce sont
des rôles du système d'exploitation.

Ainsi, au lieu d'accéder directement au matériel via des instructions de bas
niveau, les programmes communiquent avec le noyau, qui centralise donc les
appels au matériel, et abstrait certaines opérations.

Par exemple, comparons ce qui se passe concrètement lors de la copie de données
depuis un cédérom ou une mémorette USB.

\begin{itemize}

  \item Dans le cas du cédérom, il faut interroger le bus SATA, interroger le
    lecteur sur la présence d'un disque dans le lecteur, activer le moteur,
    calculer le numéro de trame des données sur le disque, demander la lecture,
    puis déclencher une
    copie de la mémoire.

  \item Avec une mémorette USB, il faut interroger le bus USB, rechercher le bon
    numéro de périphérique, le bon numéro de canal dans celui-ci, lui appliquer
    une commande de lecture au bon numéro de bloc, puis copier la mémoire.

\end{itemize}

Ces deux opérations, bien qu'elles aient le même but (copier de la mémoire
depuis un périphérique amovible), ne sont pas effectuées de la même manière.
C'est pourquoi le système d'exploitation fournit les notions de fichier,
lecteur, etc : le programmeur n'a plus qu'à utiliser des commandes de haut
niveau (``monter un lecteur'', ``ouvrir un fichier'', ``lire dans un fichier'')
et selon le type de lecteur, le système d'exploitation effectuera les actions
appropriées.

En résumé, un système d'exploitation est l'intermédiaire entre le logiciel et le
matériel, et particulier est responsable de la gestion de la mémoire, des
périphériques et des processus. Les détails d'implantation ne sont pas présentés
à l'utilisateur ; à la place il manipule des abstractions, comme la notion de
fichier. Pour plus détails sur ce sujet, y compris avec des cas d'étude,
dans~\cite{tanenbaum}.

\section{Séparation entre noyau et espace utilisateur}

Le noyau n'est pas le seul programme exécuté par le processeur : d'autres
programmes peuvent être aussi être lancés. Ce sont ceux-ci qui sont d'ailleurs
visibles pour l'utilisateur.

Puisque le noyau est garant du bon fonctionnement du système, il ne doit pas
pouvoir être manipulé directement par l'utilisateur ou les programmes exécutés.
Ainsi, il est nécessaire de mettre en place des protections entre les espaces
noyau et utilisateur.

Au niveau matériel, on utilise la notion de \emph{niveaux de privilèges} pour
déterminer s'il est possible d'exécuter une instruction.

D'une part, le processeur contient un niveau de privilège intrinsèque. D'autre
part, chaque zone mémoire contenant du code ou des données possède également un
niveau de privilège minimum nécessaire. L'exécution d'une instruction est alors
possible si et seulement si le niveau de privilège du processeur est supérieur à
celui de l'instruction et des opérandes mémoires qui y sont présentes
\footnote{
  Ici ``supérieur'' est synonyme de ``plus privilégié''. Dans l'implantation
  d'Intel présentée dans le chapitre~\ref{cha:os}, les niveaux sont numérotés de
  0 à 3 où le niveau 0 est le plus privilégié.
}.

Ainsi, pour une instruction manipulant des données en mémoire, les accès sont
possibles sont décrits dans la figure~\ref{fig:erreursec}. En cas
d'impossibilité (signalée par un \Square), une erreur se produit et l'exécution
s'arrête.

\begin{figure}
\begin{center}
\def\modeK{Noyau\xspace}
\def\modeU{Utilisateur\xspace}
\begin{tabular}{cccc}
  Mode du processeur
& Privilège (code)
& Privilège (données)
& Accès possible \\
\hline
  \modeK & \modeK & \modeK & \CheckedBox \\
  \modeK & \modeK & \modeU & \CheckedBox \\
  \modeK & \modeU & \modeK & \CheckedBox \\
  \modeK & \modeU & \modeU & \CheckedBox \\
  \modeU & \modeK & \modeK & \Square \\
  \modeU & \modeK & \modeU & \Square \\
  \modeU & \modeU & \modeK & \Square \\
  \modeU & \modeU & \modeU & \CheckedBox \\
\end{tabular}
\end{center}

\caption{ Règles d'exécution de code et d'accès à la mémoire. }
\label{fig:erreursec}

\end{figure}

En plus de cette vérification, certains types d'instructions sont explicitement
réservés au mode le plus privilégié : par exemple les lectures ou écritures sur
des ports matériels, ou celles qui permettent de définir les niveaux de
privilèges des différentes zones mémoire.

Les programmes utilisateur ne pouvant pas accéder à ces instructions de bas
niveau, ils sont très limités dans ce qu'ils peuvent faire. Puisque
l'interaction avec le matériel (comme l'écriture sur un disque dur) se fait
uniquement via des instructions privilégiées, ils sont limités à l'utilisation
du processeur et de la mémoire, permettant uniquement de réaliser des calculs.

Pour utiliser le matériel ou accéder à des abstractions de haut niveau (comme
créer un nouveau processus), ils doivent donc passer par l'intermédiaire du
noyau. La communication entre le noyau et les programmes utilisateur est
constituée par le mécanisme des \emph{appels système}.

Lors d'un appel système, une fonction du noyau est invoquée (en mode noyau) avec
des paramètres provenant de l'utilisateur. Il faut donc être particulièrement
précautionneux dans le traitement de ces données.

Par exemple, considérons un appel système de lecture depuis un disque : on passe
au noyau les arguments $(d, o, n, a)$ où $d$ est le nom du disque, $o$ l'adresse
sur le disque où commencer la lecture (\emph{offset}), $n$ le nombre d'octets à
lire et $a$ l'adresse en mémoire où commencer à stocker les résultats.

Dans le cas d'utilisation prévu, le noyau va copier la mémoire lue dans $a$. On
est en mode noyau, en train d'exécuter une instruction du noyau manipulant des
données utilisateur. D'après la figure~\ref{fig:erreursec} aucune erreur ne se
produit.

Mais même si ce cas ne produit pas d'erreur à l'exécution, il est tout de même
erroné. En effet, si on passe à l'appel système une adresse $a$ faisant partie
de l'espace noyau, que se passe-t-il ?

L'exécution est presque identique : au moment de la copie on est en mode noyau,
en train d'exécuter une instruction du noyau manipulant des données noyau.
Encore une fois il n'y a pas d'erreur à l'exécution.

On peut donc écrire n'importe où en mémoire. De même, une fonction d'écriture
sur un disque (et lisant en mémoire) permettrait de lire de la mémoire du noyau.
À partir de ces primitives, on peut accéder aux autres processus exécutés, ou
détourner l'exécution vers du code arbitraire. L'isolation est totalement
brisée à cause des appels système.

La cause de ceci est qu'on a accédé à la mémoire en testant les privilèges du
noyau au lieu de tester les privilèges de celui qui a fait la requête
(l'utilisateur). Ce problème est connu sous le nom de \emph{confused deputy
problem}\cite{hardy88confused}.

La bonne manière d'implanter un appel système est donc d'interdire le
déréférencement direct des pointeurs dont la valeur peut être contrôlée par
l'utilisateur. Dans le cas du passage par adresse d'un argument, il aurait fallu
vérifier à l'exécution que celle-ci a bien les mêmes privilèges que l'appelant.

Il est facile d'oublier d'ajouter cette vérification, puisque le cas ``normal''
fonctionne. Avec ce genre d'exemple on voit comment les bugs peuvent arriver si
fréquemment et pourquoi il est aussi capital de les détecter avant l'exécution.

\section{Systèmes de types}

La plupart des langages de programmation incorporent la notion de type, qui
permet de détecter ou d'empêcher de manipuler des données incompatibles entre
elles.

Nous avons vu dans le chapitre~\ref{cha:os} qu'au niveau du langage machine, les
seules données qu'un ordinateur manipule sont des nombres. Selon les opérations
effectuées, ils seront interprétés comme des entiers, des adresses mémoires, ou
des caractères. Pourtant il est clair que certaines opérations n'ont pas de
sens: par exemple, multiplier un nombre par une adresse, ou déréférencer le
résultat d'une division sont des comportements qu'on voudrait pouvoir empêcher.

En un mot, le but du typage est de classifier les objets et de restreindre les
opérations possibles selon la classe d'un objet : ``ne pas ajouter des pommes et
des oranges''. Le modèle qui permet cette classification est appelé
\emph{système de types} et est en général constitué d'un ensemble de
\emph{règles de typage}, comme ``un entier plus un entier égale un entier''.

Il y a deux grandes familles de systèmes de types, selon quand se fait la
vérification de types. On peut en effet l'effectuer au moment de l'exécution, ou
au contraire prévenir les erreurs à l'exécution en la faisant au moment de la
compilation (ou avant l'interprétation).

\paragraph{Typage dynamique :} dans ce cas, chaque valeur manipulée par le
programme est décorée d'une étiquette définissant comment interpréter la valeur
en question. Les règles de typage sont alors réalisées à l'exécution. Par
exemple, l'opérateur "$+$" vérifie que ces deux opérandes ont une étiquette
"entier", et construit alors une valeur obtenue en faisant l'addition des deux
valeurs, avec une étiquette ``entier''. Par exemple, le langage
Python~\link{python} utilise cette stratégie.

\paragraph{Typage statique :} dans ce cas on fait les vérifications à la
compilation. En quelque sorte, l'approche dynamique est pessimiste, puisqu'elle
demande de traiter très souvent le cas où les types ne sont pas corrects.
Intuitivement, dans le cas où toutes les fonctions se comportent bien, faire la
vérification est inutile. Pour vérifier ceci, on donne à chaque fonction un
contrat comme ``si deux entiers sont passés, et que la fonction renvoie une
valeur\footnote{
  La plupart des systèmes de types ne concernent que les termes qui convergent.
  Il est également possible que la fonction contienne une boucle infinie, ou
  provoque une erreur à cause d'une division par zéro. Dans ces cas, la fonction
  ne renvoie pas de valeur.
}, alors cette valeur sera un entier''. Cet ensemble de contrats peut être vérifié statiquement
par le compilateur, à l'aide d'un système de types statique.

Ainsi la fonction "$+$" est typée \texttt{(int, int)} $→$ \texttt{int}. Les
règles permettant de vérifier le typage sont par exemple les suivantes :

\begin{itemize}
\item
  une constante entière est toujours de type \texttt{int}.
\item
  si $f$ a pour type $(t_1, …, t_n) → t$, et que chaque $e_i$ a pour type $t_i$
  ($i ∈ [1;n]$), alors $f(e_1, …, e_n)$ a pour type $t$.
\item
  si en considérant que chaque $e_i$ a pour type $t_i$ ($i ∈ [1;n]$),
  on arrive à typer le corps de $f$ et que sa valeur de retour a alors
  pour type $t$,
  alors $f$ a pour type $(t_1, …, t_n) → t$.
\end{itemize}

\paragraph{Typage fort ou faible}

Contrairement à la distinction claire entre typage statique ou dynamique, la
séparation entre typage fort et faible est moins nette. À l'extrémité du
spectre, les systèmes de types forts permettent d'éliminer totalement la
nécessité de réaliser des tests de typage. Mais souvent ce n'est pas le cas, car
il peut y avoir des constructions au sein du langage qui permettent de
contourner le système de types, comme un opérateur de
transtypage\ref{fig:javacast}. À l'exécution, une erreur de types est levée.

\begin{figure}
  \insertcode{cast.java}

  \begin{Verbatim}
Exception in thread "main" java.lang.ClassCastException:
    java.lang.Integer cannot be cast to java.lang.Float
        at Cast.main(Cast.java:5)
  \end{Verbatim}

  \caption{Transtypage en Java}

  \label{fig:javacast}
\end{figure}

\paragraph{Polymorphisme}

Parfois, il est trop restrictif de donner un unique contrat à une fonction. Quel
doit être le type d'une fonction ajoutant un élément à une liste, ou celui d'une
fonction triant un tableau en place ?

En première approximation, on peut imaginer fournir une version du code par type
de données à manipuler. C'est la solution retenue par les premières versions du
langage Pascal, ce qui rendait très difficile l'écriture de
bibliothèques\cite{PascalNoEscape}. On parle alors de monomorphisme.

Une autre manière de procéder est d'autoriser plusieurs fonctions à avoir le
même nom, mais avec des types d'arguments différents. Par exemple, on peut
définir séparément l'addition entre deux entiers, entre deux flottants, ou entre
un entier et un flottant. Selon les informations connues à la compilation, la
bonne version sera choisie. C'est ainsi que fonctionnent les opérateurs en C++.
On parle de polymorphisme \emph{ad hoc}.

La dernière possibilité est le polymorphisme universel, qui consiste à utiliser
le même code quelque soit le type des arguments. Dans ce cas, on utilise une
seule fonction pour retourner une liste d'entiers ou une liste de flottants, par
exemple. Au lieu d'associer à chaque fonction un type, dans certains cas on lui
associe un schéma de types, instanciable en un type concret. En quelque sorte,
on déplace la vérification du site d'appel au site de définition. Cette
technique a été décrite en premier dans~\cite{Milner78}.

Un tour d'horizon de différents systèmes types statiques, avec en particulier du
polymorphisme, on pourra se référer à~\cite{TAPL}.

\section{Langages d'implantation}

Puisque notre but est d'analyser du code provenant de systèmes d'exploitation,
il est nécessaire de s'intéresser aux langages de programmation dans lesquels
ils sont écrits.

\paragraph{Assembleur}

Le noyau d'un système d'exploitation nécessite d'accéder au matériel, donc il
est naturellement bas niveau. Pour accéder aux fonctionnalités spécifiques de
chaque processeur, il est donc nécessaire d'en implanter une partie dans le
langage d'assemblage natif de chaque architecture. Historiquement, les premiers
système d'exploitations étaient entièrement écrits en assembleur. Cela est de
plus en plus rare, sauf dans les cas où les ressources sont trop limitées pour
exécuter du code compilé, comme dans les systèmes embarqués ou temps-réel.

\paragraph{C}

Le système Unix, développé à partir de 1969, a tout d'abord été développé en
assembleur sur un mini-ordinateur PDP-7, puis a été porté sur d'autres
architectures matérielles. Pour aider ce portage, il a été nécessaire de créer
un ``assembleur portable'', le langage C~\cite{KandR,AnsiC}. Son but est de
fournir des abstractions au dessus du langage d'assemblage. Les structures de
contrôle (\texttt{if}, \texttt{while}, \texttt{for}) permettent d'utiliser la
programmation structurée, c'est-à-dire en limitant l'utilisation de
l'instruction \texttt{goto}. Les types de données sont également abstraits de la
machine : ainsi, \texttt{int} désigne un entier machine, indépendamment de sa
taille concrète. Ceci dit, le système de types est assez rudimentaire : toutes
les formes de transtypage sont acceptées, certaines conversions sont insérées
automatiquement par le compilateur, et la plupart des abstractions fournies par
le langage sont perméables. Le noyau Linux est écrit dans un dialecte du langage
C.

\paragraph{C++}

Le manque de modularité de C a conduit à la création d'un nouveau langage plus
riche autour de celui-ci. Dans les années 1980, C++ est apparu comme un C
amélioré, avec de nombreuses fonctionnalités supplémentaires comme un modèle
objet avec des classes, du polymorphisme \emph{ad hoc} et un système de
\emph{templates} puissant permettant d'implanter une forme de polymorphisme
universel. Microsoft Windows, initialement écrit en C, s'est enrichi de plus en
plus de code C++, en faisant un des principaux systèmes d'exploitation écrits
dans ce langage.

% TODO Obj C ?

\paragraph{Ada}

Le langage C est bas niveau, mais son système de types n'est pas suffisamment
évolué pour le rendre plus sûr que le langage d'assemblage vers lequel il est
compilé. Dans les années 1970, le département de la défense américain
(\emph{DoD}) a créé un comité dans le but de créer un nouveau langage pour ses
systèmes temps-réels embarqués. Le résultat est Ada, un langage impératif avec
un système de types statique plus contraignant mais plus sûr que celui de C. Par
exemple, deux types entiers différents (comme les entiers de 16 bits et ceux de
32 bits) ne sont pas compatibles. Il faut ajouter une conversion explicite dans
le code, qui se traduira par un test à l'exécution et éventuellement par une
erreur \texttt{Constraint\_Error}. Bien qu'il ne se soit pas beaucoup développé
dans les applications grand public, Ada garde toujours une place de choix dans
l'implantation de systèmes embarqués, notamment dans les applications spatiales
et de défense.

\paragraph{Divers}

Il est bien sûr possible d'implanter un système d'exploitation dans n'importe
quel langage, si celui-ci peut être compilé vers du langage machine et qu'il
permet facilement d'inclure des fragments d'assembleur pour les parties de bas
niveau. Néanmoins il s'agit en général de travaux de recherche et non des
systèmes d'exploitation de production dont il est nécessaire de vérifier la
sûreté d'exécution. On peut ainsi trouver des systèmes d'exploitation écrits en
C\#~\cite{SingularityOverview},
Haskell~\cite{HaskellOS}
ou
Ocaml~\cite{unikernels}.

\section{Langages d'analyse}

Les langages décrits précédemments sont faits pour être facilement écrits par
des programmeurs humains. En général ils sont ambigüs, peu précis ou ont des
comportements implicites. Pour analyser du code source, il est plus pratique
d'avoir une représentation intermédiaire plus simple afin d'avoir moins de
traitements dupliqués. Dans de nombreux projets, des sous-ensembles de C ont été
définis pour aller dans ce sens.

Les premiers candidats sont bien entendu les représentations intermédiaires
utilisées dans les compilateurs C. Elles ont l'avantage d'accepter en plus du C
standard, les diverses extensions (GNU, Microsoft, Plan9) utilisées par la
plupart des logiciels. En particulier, le noyau Linux repose fortement sur les
extensions GNU.

\paragraph{GCC} utilise une représentation interne nommée
GIMPLE\cite{gcc-gimple}. Il s'agit d'une structure d'arbre écrite en C, reposant
sur de nombreuses macros afin de cacher les détails d'implémentation pouvant
varier entre deux versions de GCC. Cette représentation étant réputée difficile
à manipuler, le projet MELT\cite{gcc-melt} permet de générer un greffon de
compilateur à partir d'un dialecte de Lisp.

\paragraph{LLVM}\cite{llvm-pres} est un compilateur développé par la communauté
puis sponsorisé Apple. À la différence de GCC, sa base de code est écrite en
C++. Il utilise une représentation intermédiaire qui peut être manipulée soit
sous forme d'une structure de données C++, soit d'un fichier de code-octet
compact, soit sous forme textuelle.

\paragraph{Objective Caml}\link{ocamlManual} utilise pour sa génération de code
une représentation interne nommée Cmm, disponible dans les sources du
compilateur sous le chemin \texttt{asmcomp/cmm.mli} (il s'agit donc d'une
structure de données OCaml). Ce langage a l'avantage d'être très restreint, mais
malheureusement il n'existe pas directement de traducteur permettant de compiler
C vers Cmm.

\paragraph{C-~-}\cite{spjcmm} \link{cmm}, dont le nom est inspiré du précédent,
est un projet qui visait à unifier les langages intermédiaires utilisés par les
compilateurs. L'idée est que si un front-end peut émettre du C-~- (sous forme de
texte), il est possible d'obtenir du code machine efficace. Le compilateur
Haskell GHC utilise une représentation intermédiaire très similaire à C-~-.

Comme le problème de construire une représentation intermédiaire adaptée à une
analyse statique n'est pas nouveau, plusieurs projets ont déjà essayé d'y
apporter une solution. Puisque qu'ils sont développés en parallèle des
compilateurs, le support des extensions est en général moins important dans ces
langages.

\paragraph{CIL}\cite{NeculaCil} \link{kerneisCil} est une représentation en
OCaml d'un programme C, développée depuis 2002. Grâce à un mécanisme de
greffons, elle permet de prototyper rapidement des analyses statiques de
programmes.

\paragraph{Compcert} est un projet qui vise à produire un compilateur certifié
pour C. C'est à dire que le fait que les transformations conservent la
sémantique est prouvé. Il utilise de nombreux langages intermédiaires, dont CIL.
Pour le front-end, le langage se nomme Clight\cite{cfront}. Les passes de
middle-end, quant à elles, utilisent Cminor\cite{cminorSL}.

\paragraph{Newspeak}\cite{newspeak} est un langage intermédiaire développé par
EADS Innovation Works, et qui est spécialisé dans l'analyse de valeurs par
interprétation abstraite. Il sera décrit plus en détails dans la
section~\ref{sec:npk}.

Nous présentons \langname, un langage intermédiaire minimal afin de pouvoir
expirmer les règles de typage de la manière la plus simple possible. Néanmoins
l'implantation est faite sur une version adaptée de Newspeak, ce qui nous pettra
d'avoir une traduction automatique depuis du code déjà écrit en C.

\section{Plan de la thèse}

Cette thèse comporte trois parties.

\paragraph{La partie~\ref{part:ctx}} présente le contexte de ces travaux. Le
fonctionnement général d'un système d'exploitation y est détaillé, et les
problèmes de manipulation de pointeurs contrôlés par l'utilisateur y sont
introduits. On fait ensuite un tour d'horizon des techniques existantes
permettant de traiter ce problème. Cette partie se conclut par la proposition au
cœur de cette thèse.

\paragraph{La partie~\ref{part:lang}} décrit notre solution : \langname, un
langage impératif. On y décrit sa syntaxe, sa sémantique ainsi qu'un système de
types statiques. On l'étend ensuite pour capturer les problèmes d'adressage
mémoire présents dans les systèmes d'exploitation en ajoutant des pointeurs
contrôlés par l'utilisateur. Le système de types est également étendu. Pour
chacune de ces variantes, on établit la propriété de sûreté de typage reliant la
sémantique dynamique aux types statiques.

\paragraph{La partie~\ref{part:xp}} documente la démarche expérimentale associée
à ces travaux. L'implantation du système de types est décrite, afin que la
manière de transformer automatiquement du code C en \langname. Un cas d'étude
est déroulé, consistant d'un bug ayant touché le noyau Linux. Il est démontré
que le système de type capture précisément ce genre d'erreur de programmation.
Enfin, les possibilités d'extension tant théoriques qu'expérimentales sont
présentées.

%  - historique des techniques
%  - analyse non intrusive
%  - méthodes de développement du noyau
%  - syntaxe, sémantique, typage

% TODO [E] + besoins EADS

% vim: spelllang=fr
