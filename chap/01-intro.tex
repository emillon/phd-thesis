Communication,
audiovisuel,
transports,
médecine:
tout ces domaines se sont transformés dans les dernières décennies,
en particulier grâce à la révolution numérique.
En effet le plus petit appareil électrique contient maintenant des composants
matériels programmables.

En 2013, on pense bien sûr aux téléphones portables dont la fonctionnalité et la
complexité les rapprochent des ordinateurs de bureau. Par exemple, le système
d'exploitation Android de Google est basé sur le noyau Linux, destiné à la base
aux micro-ordinateurs.

Le noyau d'un système d'exploitation est chargé de faire l'intermédiaire entre
le matériel (processeur, mémoire, périphériques, …) et les applications
exécutées sur celui-ci (par exemple un navigateur web, une calculatrice ou un
carnet d'adresses). Il doit aussi garantir la sécurité de celles-ci. % TODO def

En tant qu'intermédiaire de confiance, le noyau a un certain nombre de
responsabilités et est le seul à avoir accès à certaines informations sensibles.
Il est capital de s'assurer qu'il est bien le seul à pouvoir y accéder. En
particulier, il faut pouvoir vérifier que les requêtes faites par l'utilisateur
au noyau ne peuvent pas volontairement ou involontairement détourner ce dernier
et lui faire fuiter des informations confidentielles.

Le problème est que comme tous les logiciels, les noyaux de système
d'exploitation sont écrits par des humains, qui ne sont pas parfaits. Les
activités de relecture et de débogage ont beau prendre la majeure partie du
temps de développement, il est facile de laisser passer des défauts de
programmation.

Ces erreurs, ou \emph{bugs}, peuvent avoir des conséquences dramatiques sur le
plan matériel ou humain. Dans le cadre des produits d'EADS, il est donc capital
de vérifier la correction des logiciels embarqués. De plus, le coût de déployer
des correctifs est assez important: il est d'autant plus important d'être
correct dès la première version.

Une technique efficace est de réaliser des tests, c'est-à-dire exécuter le
programme sous un environnement contrôlé. On peut alors détecter des
comportements non désirés. Mais même avec des tests les plus exhaustifs il n'est
pas possible de couvrir tous les cas d'utilisation.

Une autre approche est d'analyser le code source du programme avant de
l'exécuter et de refuser de lancer les programmes qui contiennent des erreurs,
quitte à limiter la possibilité d'en écrire certains. C'est l'analyse statique
de programmes.

Une des techniques d'analyse statique les plus répandues est le typage statique,
qui consiste % TODO hyph
à associer à chaque morceau de programme, une étiquette
décrivant quel genre de valeur sera produite par son évaluation. Par exemple, si
$n$ est le nom d'une variable entière, alors $n + 2$ produira toujours une
valeur entière.

Pour garantir l'isolation d'un noyau de système d'exploitation, un des points
cruciaux est de restreindre la manière dont sont traitées les informations
provenant des programmes utilisateur. Le but de cette thèse est de montrer que
le typage statique peut être utilisé pour détecter et interdire ces
manipulations dangereuses.

% TODO uniformité entre guillemets `` '' vs « »

\section{Rôle d'un système d'exploitation}

Un ordinateur est constitué de nombreux composants matériels: microprocesseur,
mémoire, et divers périphériques. Et au niveau de l'utilisateur, des dizaines de
logiciels permettent d'effectuer toutes sortes de calculs et de communications.
Le système d'exploitation permet de faire l'interface entre ces aspects.

Au cours de l'histoire des systèmes informatiques, la manière de les programmer
a beaucoup évolué. Au départ, les programmeurs avaient accès au matériel dans
son intégralité: toute la mémoire pouvait être accédée, toutes les instructions
pouvaient être utilisées.

Néanmoins c'est un peu restrictif, puisque cela ne permet qu'à une personne
d'interagir avec le système. Dans la seconde moitié des années 60, sont apparus
les premiers systèmes ``à temps partagé'', permettant à plusieurs utilisateurs
de travailler en même temps.

Permettre l'exécution de plusieurs programmes en même temps est une idée
révolutionnaire, mais elle n'est pas sans difficultés techniques: en effet les
ressources de la machine doivent être aussi partagées entre les utilisateurs et
les programmes. Par exemple, plusieurs programmes vont utiliser le processeur
les uns à la suite des autres; et chaque programme aura à sa disposition une
partie de la mémoire principale, ou du disque dur.

Si plusieurs programmes s'exécutent de manière concurrente sur le même matériel,
il faut s'assurer que l'un ne puisse pas écrire dans la mémoire de l'autre,
ainsi que les deux n'utilisent pas la carte réseau en même temps. Ce sont des
rôles du système d'exploitation.

Ainsi, au lieu d'accéder directement au matériel via des instructions de bas
niveau, les programmes communiquent avec le noyau, qui centralise donc les
appels au matériel, et abstrait certaines opérations.

Par exemple, comparons ce qui se passe concrètement lors de la copie de données
depuis un cédérom ou une clef USB.\@

\begin{itemize}

  \item Dans le cas du cédérom, il faut interroger le bus SATA, interroger le
    lecteur sur la présence d'un disque dans le lecteur, activer le moteur,
    calculer le numéro de trame des données sur le disque, demander la lecture,
    puis déclencher une copie de la mémoire.

  \item Avec une clef, il faut interroger le bus USB, rechercher le bon numéro
    de périphérique, le bon numéro de canal dans celui-ci, lui appliquer une
    commande de lecture au bon numéro de bloc, puis copier la mémoire.

\end{itemize}

Ces deux opérations, bien qu'elles aient la même intention (copier de la mémoire
depuis un périphérique amovible), ne sont pas effectuées en extension de la même
manière. C'est pourquoi le système d'exploitation fournit les notions de
fichier, lecteur, etc: le programmeur n'a plus qu'à utiliser des commandes de
haut niveau (``monter un lecteur'', ``ouvrir un fichier'', ``lire dans un
fichier'') et selon le type de lecteur, le système d'exploitation effectuera les
actions appropriées.

En résumé, un système d'exploitation est l'intermédiaire entre le logiciel et le
matériel, et en particulier est responsable de la gestion de la mémoire, des
périphériques et des processus. Les détails d'implantation ne sont pas présentés
à l'utilisateur; à la place il manipule des abstractions, comme la notion de
fichier. Pour une explication détaillée du concept de système d'exploitation
ainsi que des cas d'étude, on pourra se référer à~\cite{tanenbaum}.

\section{Séparation entre noyau et espace utilisateur}

Puisque le noyau est garant du bon fonctionnement du système, il ne doit pas
pouvoir être manipulé directement par l'utilisateur ou les programmes exécutés.
Ainsi, il est nécessaire de mettre en place des protections entre les espaces
noyau et utilisateur.

Au niveau matériel, on utilise la notion de \emph{niveaux de privilèges} pour
déterminer s'il est possible d'exécuter une instruction.

D'une part, le processeur contient un niveau de privilège intrinsèque. D'autre
part, \linebreak chaque zone mémoire contenant du code ou des données possède
également un niveau de privilège minimum nécessaire. L'exécution d'une
instruction est alors possible si et seulement si le niveau de privilège du
processeur est supérieur à celui de l'instruction et des opérandes mémoires qui
y sont présentes
\footnote{
  Ici ``supérieur'' est synonyme de ``plus privilégié''. Dans l'implantation
  d'Intel présentée dans le chapitre~\ref{cha:os}, les niveaux sont numérotés de
  0 à 3 où le niveau 0 est le plus privilégié.
}.

Par exemple, supposons qu'un programme utilisateur contienne l'instruction
\texttt{mov \%eax, \hexa{54c3b2f7}}. Celle-ci consiste à déplacer le contenu du
registre \eax{} vers l'adresse mémoire \texttt{\hexa{54c3b2f7}}. Puisque cette
adresse est dans l'espace utilisateur (la raison est décrite dans le
chapitre~\ref{cha:os}), aucune erreur de protection mémoire n'est déclenchée.

Ainsi, pour une instruction manipulant des données en mémoire, les accès
possibles sont décrits dans le tableau suivant. En cas d'impossibilité (signalée
par un \Square), une erreur se produit et l'exécution s'arrête.

\begin{center}
\def\modeK{Noyau\xspace}
\def\modeU{Utilisateur\xspace}
\begin{tabular}{cccc}
\toprule
  Mode du processeur
& Privilège (code)
& Privilège (données)
& Accès possible \\
\midrule
  \modeK{} & \modeK{} & \modeK{} & \CheckedBox{} \\
  \modeK{} & \modeK{} & \modeU{} & \CheckedBox{} \\
  \modeK{} & \modeU{} & \modeK{} & \CheckedBox{} \\
  \modeK{} & \modeU{} & \modeU{} & \CheckedBox{} \\
  \modeU{} & \modeK{} & \modeK{} & \Square{} \\
  \modeU{} & \modeK{} & \modeU{} & \Square{} \\
  \modeU{} & \modeU{} & \modeK{} & \Square{} \\
  \modeU{} & \modeU{} & \modeU{} & \CheckedBox{} \\
\bottomrule
\end{tabular}
\end{center}
\label{page:erreursec}

En plus de cette vérification, certains types d'instructions sont explicitement
réservés au mode le plus privilégié: par exemple les lectures ou écritures sur
des ports matériels, ou celles qui permettent de définir les niveaux de
privilèges des différentes zones mémoire.

Les programmes utilisateur ne pouvant pas accéder à ces instructions de bas
niveau, ils sont très limités dans ce qu'ils peuvent faire. Puisque
l'interaction avec le matériel (comme l'écriture sur un disque dur) se fait
uniquement via des instructions privilégiées, ils sont limités à l'utilisation
du processeur et de la mémoire, permettant uniquement de réaliser des calculs.

Pour utiliser le matériel ou accéder à des abstractions de haut niveau (comme
créer un nouveau processus), ils doivent donc passer par l'intermédiaire du
noyau. La communication entre le noyau et les programmes utilisateur est
constituée par le mécanisme des \emph{appels système}.

Lors d'un appel système, une fonction du noyau est invoquée (en mode noyau) avec
des paramètres provenant de l'utilisateur. Il faut donc être particulièrement
précautionneux dans le traitement de ces données.

Par exemple, considérons un appel système de lecture depuis un disque: on passe
au noyau les arguments $(d, o, n, a)$ où $d$ est le nom du disque, $o$ (pour
\emph{offset}) l'adresse sur le disque où commencer la lecture, $n$ le nombre
d'octets à lire et $a$ l'adresse en mémoire où commencer à stocker les
résultats.

Dans le cas d'utilisation prévu, le noyau va copier la mémoire lue dans $a$. Le
processeur est en mode noyau, en train d'exécuter une instruction du noyau
manipulant des données utilisateur. D'après le tableau de la
page~\pageref{page:erreursec}, aucune erreur ne se produit.

Mais même si ce cas ne produit pas d'erreur à l'exécution, il est tout de même
codé de manière incorrecte. En effet, si on passe à l'appel système une adresse
$a$ faisant partie de l'espace noyau, que se passe-t-il?

L'exécution est presque identique: au moment de la copie on est en mode noyau,
en train d'exécuter une instruction du noyau manipulant des données noyau.
Encore une fois il n'y a pas d'erreur à l'exécution.

On peut donc écrire n'importe où en mémoire. De même, une fonction d'écriture
sur un disque (et lisant en mémoire) permettrait de lire de la mémoire du noyau.
À partir de ces primitives, on peut accéder aux autres processus exécutés, ou
détourner l'exécution vers du code arbitraire. L'isolation est totalement
brisée à cause de ces appels système.

La cause de ceci est qu'on a accédé à la mémoire en testant les privilèges du
noyau au lieu de tester les privilèges de celui qui a fait la requête
(l'utilisateur). Ce problème est connu sous le nom de \emph{confused deputy
problem}~\cite{hardy88confused}.

La bonne manière d'implanter un appel système est donc d'interdire le
déréférencement direct des pointeurs dont la valeur peut être contrôlée par
l'utilisateur. Dans le cas du passage par adresse d'un argument, il aurait fallu
vérifier à l'exécution que celui-ci a bien les mêmes privilèges que l'appelant.

% TODO[E] on a l'impression que c'est le seul pb

Il est facile d'oublier d'ajouter cette vérification, puisque le cas ``normal''
fonctionne. Avec ce genre d'exemple on voit comment les bugs peuvent arriver si
fréquemment et pourquoi il est aussi capital de les détecter avant l'exécution.

\section{Systèmes de types}
\label{sec:types-intro}

La plupart des langages de programmation incorporent la notion de type, dont un
des buts est d'empêcher de manipuler des données incompatibles entre elles.

En mémoire, les seules données qu'un ordinateur manipule sont des nombres. Selon
les opérations effectuées, ils seront interprétés comme des entiers, des
adresses mémoires, ou des caractères. Pourtant il est clair que certaines
opérations n'ont pas de sens: par exemple, multiplier un nombre par une adresse,
ou déréférencer le résultat d'une division sont des comportements qu'on voudrait
pouvoir empêcher.

En un mot, le but du typage est de classifier les objets et de restreindre les
opérations possibles selon la classe d'un objet: en somme, ``ne pas ajouter des
pommes et des oranges''. Le modèle qui permet cette classification est appelé
\emph{système de types} et est en général constitué d'un ensemble de
\emph{règles de typage}, comme ``un entier plus un entier égale un entier''.

\paragraph{Typage dynamique}

Dans ce cas, chaque valeur manipulée par le programme est décorée d'une
étiquette définissant comment interpréter la valeur en question. Les règles de
typage sont alors réalisées à l'exécution. Par exemple, l'opérateur ``$+$''
vérifie que ces deux opérandes ont une étiquette ``entier'', et construit alors
une valeur obtenue en faisant l'addition des deux valeurs, avec une étiquette
``entier''. Par exemple, le langage Python~\link{python} utilise cette
stratégie.

\paragraph{Typage statique}

Dans ce cas on fait les vérifications à la compilation. Pour vérifier ceci, on
donne à chaque fonction un contrat comme ``si deux entiers sont passés, et que
la fonction renvoie une valeur, alors cette valeur sera un entier''. Cet
ensemble de contrats peut être vérifié statiquement par le compilateur, à l'aide
d'un système de types statique.

Par exemple, on peut dire que l'opérateur ``$+$'' a pour type $(\tInt, \tInt) →
\tInt$. Cela veut dire que si on lui passe deux entiers ($\tInt$ \tInt), alors
la valeur obtenue est également un entier.

\paragraph{Typage fort ou faible}

Contrairement à la distinction claire entre typage statique ou dynamique, la
séparation entre typage fort et faible est moins nette. En poussant à l'extrême,
les systèmes de types forts permettent d'éliminer totalement la nécessité de
réaliser des tests de typage. Mais souvent ce n'est pas le cas, car il peut y
avoir des constructions au sein du langage qui permettent de contourner le
système de types, comme un opérateur de transtypage. On parle alors de typage
faible.

\paragraph{Polymorphisme}

% TODO[E] ici tu parles de polymorpphisme paralétrique ou tu veux etre fénérale
% dans d'autres cas tu veux justement spécialiser: surcharge ou objet
% TODO Il manque le polymorphisme objet

Parfois, il est trop restrictif de donner un unique type à une fonction. Si on
considère une fonction ajoutant un élément à une liste, ou une autre
triant un tableau en place, leur type doit-il faire intervenir le type des
éléments manipulés?

En première approximation, on peut imaginer fournir une version du code par type
de données à manipuler. C'est la solution retenue par les premières versions du
langage Pascal, ce qui rendait très difficile l'écriture de
bibliothèques~\cite{PascalNoEscape}. On parle alors de monomorphisme.

Une autre manière de procéder est d'autoriser plusieurs fonctions à avoir le
même nom, mais avec des types d'arguments différents. Par exemple, on peut
définir séparément l'addition entre deux entiers, entre deux flottants, ou entre
un entier et un flottant. Selon les informations connues à la compilation, la
bonne version sera choisie. C'est ainsi que fonctionnent les opérateurs en C++.
On parle de polymorphisme \emph{ad hoc}, ou de surcharge.

La dernière possibilité est le polymorphisme paramétrique, qui consiste à
utiliser le \linebreak même code quelque soit le type des arguments. Dans ce
cas, on utilise une seule fonction pour traiter une liste d'entiers ou une liste
de flottants, par exemple. Au lieu d'associer à chaque fonction un type, dans
certains cas on lui associe un type paramétré, instanciable en un type concret.
Dans le cas des fonctions de traitement de liste, l'idée est que lorsqu'on ne
touche pas aux éléments, alors le traitement est valable quelque soit leur type.
Cette technique a été décrite en premier dans~\cite{Milner78}.

Pour un tour d'horizon de différents systèmes types de statiques, avec en
particulier du polymorphisme, on pourra se référer à~\cite{TAPL}.

\section{Langages d'implantation}

Puisque notre but est d'analyser du code provenant de systèmes d'exploitation,
il est nécessaire de s'intéresser aux langages de programmation dans lesquels
ils sont écrits.

\paragraph{Assembleur}

Le noyau d'un système d'exploitation nécessite d'accéder au matériel, donc il
est naturellement bas niveau. Pour accéder aux fonctionnalités spécifiques de
chaque processeur, il est donc nécessaire d'en implanter une partie dans le
langage d'assemblage natif de chaque architecture. Historiquement, les premiers
système d'exploitations étaient entièrement écrits en assembleur. Cela est de
plus en plus rare, sauf dans les cas où les ressources sont trop limitées pour
exécuter du code compilé, comme dans les systèmes embarqués ou temps-réel.

\paragraph{C}

Le système Unix, développé à partir de 1969, a tout d'abord été développé en
assembleur sur un mini-ordinateur PDP-7, puis a été porté sur d'autres
architectures matérielles. Pour aider ce portage, il a été nécessaire de créer
un ``assembleur portable'', le langage C~\cite{KandR,AnsiC}. Son but est de
fournir des abstractions au dessus du langage d'assemblage. Les structures de
contrôle (\texttt{if}, \texttt{while}, \texttt{for}) permettent d'utiliser la
programmation structurée, c'est-à-dire en limitant l'utilisation de
l'instruction \texttt{goto}. Les types de données sont également abstraits de la
machine: ainsi, \texttt{int} désigne un entier machine, indépendamment de sa
taille concrète. Son système de types est assez rudimentaire: toutes les formes
% TODO il y a tout de même des erreurs de typage à la compil
de transtypage sont acceptées, certaines conversions sont insérées
automatiquement par le compilateur, et la plupart des abstractions fournies par
le langage sont perméables. Le noyau Linux est écrit dans un dialecte du langage
C. Le noyau du système Mac OSX d'Apple est également un dérivé d'Unix, et est
donc aussi écrit dans ce langage.


\paragraph{C++}

Le manque de modularité de C a conduit à la création d'un nouveau langage plus
riche autour de celui-ci. Dans les années 1980, C++ est apparu comme un C
amélioré, avec de nombreuses fonctionnalités supplémentaires comme un modèle
objet avec des classes, du polymorphisme \emph{ad hoc} et un système de
\emph{templates} puissant permettant d'implanter une forme de polymorphisme
universel. Microsoft Windows, initialement écrit en C, s'est enrichi de plus en
plus de code C++, en faisant un des principaux systèmes d'exploitation écrits
dans ce langage.

\paragraph{Ada}

Le langage C est bas niveau, mais son système de types n'est pas suffisamment
évolué pour le rendre plus sûr que le langage d'assemblage vers lequel il est
compilé. Dans les années 1970, le département de la défense américain
(\emph{DoD}) a créé un comité dans le but de créer un nouveau langage pour ses
systèmes temps-réels embarqués. Le résultat est Ada, un langage impératif avec
un système de types statique plus contraignant mais plus sûr que celui de C. Par
exemple, deux types entiers différents (comme les entiers de 16 bits et ceux de
32 bits) ne sont pas compatibles. Il faut ajouter une conversion explicite dans
le code, qui se traduira par un test à l'exécution et éventuellement par une
erreur \texttt{Constraint\_Error}. Bien qu'il ne se soit pas beaucoup développé
dans les applications grand public, Ada garde toujours une place de choix dans
l'implantation de systèmes embarqués, notamment dans les applications spatiales
et de défense.

% TODO[E] + riche, réducteur

\paragraph{Autres langages}

Il est bien sûr possible d'implanter un système d'exploitation dans n'importe
quel langage, si celui-ci peut être compilé vers du langage machine et qu'il
permet facilement d'inclure des fragments d'assembleur pour les parties de bas
niveau. On peut par exemple trouver des systèmes d'exploitation écrits en
C\#~\cite{SingularityOverview}, Haskell~\cite{HaskellOS} ou
Ocaml~\cite{unikernels}.

\section{Langages d'analyse}

Les langages décrits précédemments sont faits pour être facilement écrits par
des programmeurs humains. En général ils sont ambigüs ou ont des comportements
implicites. Pour analyser du code source, il est plus pratique d'avoir une
représentation intermédiaire plus simple afin d'avoir moins de traitements
dupliqués. Dans de nombreux projets, des sous-ensembles de C ont été définis
pour aller dans ce sens.

\subsection*{Middle-ends}

Les premiers candidats sont bien entendu les représentations intermédiaires
utilisées dans les compilateurs C. Elles ont l'avantage d'accepter en plus du C
standard, les diverses extensions (GNU, Microsoft, Plan9) utilisées par la
plupart des logiciels. En particulier, le noyau Linux repose fortement sur les
extensions GNU.\@

\paragraph{GCC} utilise une représentation interne nommée
GIMPLE\cite{gcc-gimple}. Il s'agit d'une structure d'arbre écrite en C, reposant
sur de nombreuses macros afin de cacher les détails d'implantation interne
pouvant varier entre deux versions. Cette représentation étant réputée difficile
à manipuler, le projet MELT\cite{gcc-melt} permet de générer un greffon de
compilateur écrit dans un dialecte de Lisp.

\paragraph{LLVM}\cite{llvm-pres} est un compilateur développé par la communauté
% TODO laquelle
puis sponsorisé par Apple. À la différence de GCC, sa base de code est écrite en
C++. Il utilise une représentation intermédiaire qui peut être manipulée soit
sous forme d'une structure de données C++, soit d'un fichier de code-octet
compact, soit sous forme textuelle.

\paragraph{Cmm} est une représentation interne utilisée pour la génération de
code lors de la compilation d'Objective Caml~\link{ocamlManual}, et disponible
dans les sources du compilateur sous le chemin \texttt{asmcomp/cmm.mli} (il
s'agit donc d'une structure de données OCaml). Ce langage a l'avantage d'être
très restreint, mais malheureusement il n'existe pas directement de traducteur
permettant de compiler C vers Cmm.

\paragraph{C-~-}\cite{spjcmm} \link{cmm}, dont le nom est inspiré du précédent,
est un projet qui visait à unifier les langages intermédiaires utilisés par les
compilateurs. L'idée est que si un front-end peut émettre du C-~- (sous forme de
texte), il est possible d'obtenir du code machine efficace. Le compilateur
Haskell GHC, par exemple, utilise une représentation intermédiaire très
similaire à C-~-.

\subsection*{Langages intermédiaires ad hoc}

Comme le problème de construire une représentation intermédiaire adaptée à une
analyse statique n'est pas nouveau, plusieurs projets ont déjà essayé d'y
apporter une solution. Puisque qu'ils sont développés en parallèle des
compilateurs, le support des extensions est en général moins important dans ces
langages.

\paragraph{CIL}\cite{NeculaCil} \link{kerneisCil} est une représentation en
OCaml d'un programme C, développée depuis 2002. Grâce à un mécanisme de
greffons, elle permet de prototyper rapidement des analyses statiques de
programmes.

\paragraph{Compcert} est un projet qui vise à produire un compilateur certifié
pour C. C'est-à-dire que le fait que les transformations conservent la
% TODO un peu lourd
sémantique est prouvé. Il utilise de nombreux langages intermédiaires, dont
CIL.\@ Pour le front-end, le langage se nomme Clight\cite{cfront}. Les passes de
middle-end, quant à elles, utilisent Cminor\cite{cminorSL}.

% TODO dire un mot EADS
\paragraph{Newspeak}\cite{newspeak} est un langage intermédiaire développé par
EADS Innovation Works, et qui est spécialisé dans l'analyse de valeurs par
interprétation abstraite. Il sera décrit plus en détails dans la
section~\ref{sec:npk}.

\subsection*{La solution retenue: \langname{}}

Dans la suite de cette thèse nous nous appuierons sur \langname{}, un langage
intermédiaire minimal, pour exprimer les règles de typage de la manière la plus
simple possible.

% TODO un peu court

% TODO redire ici ce que tu veux faire, ou ce que tu as fait et ensuite
% présenter ton plan

\section{Plan de la thèse}

Cette thèse comporte trois parties.

\paragraph{La partie~\ref{part:ctx}} présente le contexte de ces travaux. Le
fonctionnement général d'un système d'exploitation y est détaillé, et les
problèmes de manipulation de pointeurs contrôlés par l'utilisateur y sont
introduits. On fait ensuite un tour d'horizon des techniques existantes
permettant de traiter ce problème. Cette partie se conclut par la proposition au
cœur de cette thèse.

\paragraph{La partie~\ref{part:lang}} décrit notre solution: \langname{}, un
langage impératif. On y décrit sa syntaxe, sa sémantique ainsi qu'un système de
types statiques. On l'étend ensuite pour capturer les problèmes d'adressage
mémoire présents dans les systèmes d'exploitation en ajoutant des pointeurs
contrôlés par l'utilisateur. Le système de types est également étendu. Pour
chacune de ces variantes, on établit la propriété de sûreté de typage reliant la
sémantique d'exécution aux types statiques.

\paragraph{La partie~\ref{part:xp}} documente la démarche expérimentale associée
à ces travaux. L'implantation du système de types est décrite, ainsi que la
manière de transformer automatiquement du code C en \langname{}. Un cas d'étude
est déroulé portant sur un bug ayant touché le noyau Linux. Il est démontré que
le système de type capture précisément ce genre d'erreur de programmation.
Enfin, les possibilités d'extension tant théoriques qu'expérimentales sont
présentées.

% vim: spelllang=fr
