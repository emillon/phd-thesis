Les logiciels sont de plus en plus présents partout, même dans des endroits
incongrus. Le plus petit appareil électrique contient maintenant des composants
matériels programmables nécessitant des logiciels.

Autant certains de ces systèmes embarqués ont un rôle très délimité et ne
comportent que peu de code, certains comportent des millions de lignes de code.
En cette époque, on pense bien sûr aux téléphones portables qui se rapproche
de très près des ordinateurs. Ainsi le système Android de Google est basé sur le
noyau Linux, né comme un clone gratuit d'Unix pour les micro-ordinateurs dans
les années 90.

Au cœur de chacun de ces systèmes, se trouve un noyau de système d'exploitation,
chargé d'abstraire le matériel à la vue des logiciels utilisateurs (comme les
applications de téléphones) et de garantir la sécurité et l'isolation de
celles-ci.

En tant que tiers de confiance, le noyau a un certain nombre de responsabilités
et est le seul à avoir accès à certaines informations sensibles. Il est capital
de s'assurer qu'il est bien le seul à pouvoir y accéder. En particulier, il faut
pouvoir vérifier que les requêtes faites par l'utilisateur au noyau ne peuvent
pas détourner ce dernier et lui faire fuiter des informations confidentielles.

Le problème est que comme tous les logiciels, les noyaux de système
d'exploitation sont écrits par des humains, qui ne sont pas parfaits. Loin de
là: on estime qu'avant relecture, une erreur de programmation est présente
toutes les N lignes de code en moyenne. Les activités de relecture et de
débogage ont beau prendre la majeure partie du temps de développement, elles ne
laissent pas un logiciel de qualité parfaite à la sortie, loin de là. En effet,
même avec des tests les plus exhaustifs il n'est pas possible de simuler le code
d'une manière qui recouvre tous les cas d'utilisation et permette de s'assurer
de sa correction.

De plus, les tests ne permettent que de s'assurer qu'il y a un bug ; pas de
prouver leur absence. S'assurer qu'un programme n'a pas de bug est
particulièrement délicat, et ne peut pas être fait automatiquement dans le cas
général. Une solution est en effet de restreindre l'expressivité du langage de
programmation afin de n'accepter que des programmes sans un certain type
d'erreur.

\section{Noyaux de systèmes d'exploitation}

% TODO trad

Modern operating systems such as GNU/Linux are comprised of several independent
programs: the kernel, which handles the machine's hardware as well as trusted
core features; and user applications.

These programs run with different privilege levels: low-level operations can
only be executed by the kernel. They also have different views on the memory. If
a user program had access to the kernel's internal data structures, it could use
it to obtain information it is normally denied, or gain extra privileges (for
example getting access to the \texttt{root} account). This is why the kernel
stores its code and data in a place in memory that is not accessible to
unprivileged programs. On an Intel 32-bit system, it corresponds to addresses
higher than \texttt{0xc0000000}, or 3 GiB.

Because user-mode programs cannot run low-level instructions, they cannot do
anything interesting on their own. They have to use the kernel's facilities to
perform input/output or manipulate the operating system's abstractions (such as
creating a new process). To this end, they can communicate with the kernel
via the narrow interface of \emph{system calls}.

For example, every time a user process calls the \texttt{read()} function, an
architecture-specific mechanism invokes the kernel-mode function
\texttt{sys\_read()}. The user passes a file descriptor, a pointer and an amount
of bytes to fill and the kernel will actually perform input/output and copy the
resulting bytes on the user's buffer.

But if the user supplies a pointer whose value is in the kernel's reserved area,
this zone will be overwritten, potentially leading to a security breach. In a
sense, the kernel has been abused because it accessed the memory with its own
privileges instead of the originator's. This is known as the \emph{confused
deputy problem}\cite{hardy88confused}.

When implementing a system call, it is thus necessary to forbid direct
dereference of a pointer whose value can be controlled by the user. In case of a
system call with a pointer argument, one has to dynamically verify that the
address provided by the user lies within the process's memory space.

The object of this work is to detect the places where it is necessary to insert
dynamic checks. To this end, we augment the type system of a subset of the C
programming language with \emph{type qualifiers}: instead of having a single
pointer type, we add syntactic rules to distinguish between safe pointers that
can be dereferenced with the \texttt{*}, \texttt{->} and \texttt{[]} operators ;
and unsafe pointers that have to go through a special API provided by the
kernel, consisting most notably of the two functions \texttt{copy\_from\_user}
and \texttt{copy\_to\_user}.

\section{Systèmes de types}

\section{Plan de la thèse}

Cette thèse comporte trois parties.

\paragraph{La partie~\ref{part:ctx}} présente le contexte de ces travaux. Le
fonctionnement général d'un système d'exploitation y est détaillé, et les
problèmes de manipulation de pointeurs contrôlés par l'utilisateur y sont
introduits. On fait ensuite un tour d'horizon des techniques existantes
permettant de traiter ce problème.

\paragraph{La partie~\ref{part:lang}} décrit notre solution : \langname, un
langage impératif. On y décrit sa syntaxe, sa sémantique ainsi qu'un système de
types statiques. On l'étend ensuite pour capturer les problèmes d'adressage
mémoire présents dans les systèmes d'exploitation en ajoutant des pointeurs
contrôlés par l'utilisateur. Le système de types est également étendu. Pour
chacune de ces variantes, on établit la propriété de sûreté de typage reliant la
sémantique dynamique aux types statiques.

\paragraph{La partie~\ref{part:xp}} documente la démarche expérimentale associée
à ces travaux. L'implantation du système de types est décrite, afin que la
manière de transformer automatiquement du code C en \langname. Un cas d'étude
est déroulé, consistant d'un bug ayant touché le noyau Linux. Il est démontré
que le système de type capture précisément ce genre d'erreur de programmation.
Enfin, les possibilités d'extension tant théoriques qu'expérimentales sont
présentées.

\begin{itemize}
\item
  omniprésence
\item
  complexité
\item
  vérification
\item
  taux de bugs après relecture
\item
  vérification automatique obligatoire
\item
  historique des techniques
\item
  analyse non intrusive
\item
  méthodes de développement du noyau
\item
  syntaxe, sémantique, typage
\end{itemize}
