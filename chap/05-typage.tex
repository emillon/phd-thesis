\section{Présentation et but}

On a vu dans le chapitre~\ref{cha:os} qu'au niveau du langage machine, les
seules données qu'un ordinateur manipule sont des nombres. Selon les opérations
effectuées, ils seront interprétés comme des entiers, des adresses mémoires, ou
des caractères.

Pourtant il est clair que certaines opérations n'ont pas de sens : par exemple,
ajouter deux adresses, ou déréférencer le résultat d'une division sont des
comportements qu'on voudrait pouvoir empêcher.

En un mot, le but du typage est de classifier les objets et de restreindre les
opérations possibles selon la classe d'un objet : "ne pas ajouter des pommes et
des oranges".

Le modèle qui permet cette classification est appelé \emph{système de types} et
est en général constitué d'un ensemble de \emph{règles de typage}, comme "un
entier plus un entier égale un entier".

\section{Taxonomie}

La définition d'un langage de programmation introduit la plupart du temps celle
d'un système de types. Il y a donc de nombreux systèmes de types différents,
dont nous pouvons donner une classification sommaire.

\subsection{Dynamique, statique, mixte}

Il y a deux grandes familles de systèmes de types, selon quand se fait la
vérification de types. On peut en effet l'effectuer au moment de l'exécution, ou
au contraire prévenir les erreurs à l'exécution en la faisant au moment de la
compilation (ou avant l'interprétation).

\subsubsection{Typage dynamique}

La première est le typage \emph{dynamique}. Pour différencier les différents
types de données, on ajoute une étiquette à chaque valeur. Dans tout le
programme, on ne manipulera que des valeurs étiquetées. Si on veut réaliser
l'opération $(\hexa{00000001}, Int) + (\hexa{0000f000}, Int)$, on vérifie tout
d'abord qu'on peut réaliser l'opération $+$ entre deux $Int$. Ensuite on réalise
l'opération elle même, qu'on étiquette avec le type du résultat :
$(\hexa{0000f001}, Int)$. Si au contraire on tente d'ajouter deux adresses
$(\hexa{2e8d5a90}, Addr) + (\hexa{76a5e0ec}, Addr)$, la vérification échoue et
l'opération s'arrête avec une erreur.

\begin{figure}
  \insertcode{typage-dynamique.py}
  \caption{Session Python présentant le typage dynamique}
  \label{fig:typage-dynamique}
\end{figure}

Il existe plusieurs techniques pour signaler les erreurs de typage dynamiques :
arrêter l'exécution, lever une exception, convertir une opérande, utiliser une
valeur d'erreur, etc.

\subsubsection{Typage statique}

La seconde technique est le typage \emph{statique} : plutôt que de vérifier les
types sur les données, on les vérifie à l'arrêt, sur les expressions. Cela
implique par exemple que chaque variable doit contenir des valeurs d'un même
type tout au long de sa vie.

A première vue, cela semble moins puissant que le typage dynamique : en effet,
il existe des programmes qui s'exécuteront sans erreur de type mais sur lesquels
le typage statique ne peut s'appliquer.

\begin{figure}
  \insertcode{non-typable.py}
  \caption{Fonction Python non typable statiquement.}
  \label{fig:nontypable}
\end{figure}

Dans la figure~\ref{fig:nontypable}, on peut voir par une simple analyse de cas
que si on fournit un booléen à \texttt{f}, elle retourne un entier. Mais selon
la valeur de \texttt{b}, la variable \texttt{x} contiendra une valeur de type
entier ou fonction.

Dans le cas où le typage statique est possible, les garanties sont en revanche
plus importantes : les valeurs portées par une variable auront toujours le même
type. Par voie de conséquence, la vérification dynamique de types réussira
toujours : on peut donc la supprimer. Il est également possible de supprimer
toutes les étiquettes de typage : on parle de \emph{type erasure}.

Une conséquence heureuse de cette suppression est que l'exécution de ce
programme se fera de manière plus rapide.

Connaître les types à la compilation permet aussi de réaliser plus
d'optimisations. Par exemple, en Python, considérons l'expression \texttt{y = x
- x}. Sans information sur le type de \texttt{x}, aucune simplification n'est
possible : l'implémentation de la différence sur ce type est une fonction
quelconque, sans propriétés particulières \emph{a priori}.

Si au contraire, on sait que \texttt{x} est un entier, on peut en déduire que
\texttt{y = 0}, sans réaliser la soustraction (si c'était la seule utilisation
de \texttt{x}, le calcul de \texttt{x} aurait alors pu être éliminé).

\subsubsection{Typage hybride ("stanamique")}

Il est aussi possible de mélanger ces deux approches :

\begin{itemize}
\item
  à la compilation, essayer d'obtenir les types les plus précis
  possibles
\item
  pour les cas restants, insérer un test dynamique
\end{itemize}

\subsection{Fort, faible, sound}

Un autre critère intéressant est la "force" du typage : est-ce qu'il peut
induire des conversions de type implicites ?

Prenons l'exemple de l'addition entre un entier $2$ et un flottant $3.14$. On
peut le voir de plusieurs manières différentes :

\begin{itemize}
\item
  un entier est un nombre décimal comme les autres : $2 = 2.00$. Donc
  $2 + 3.14 = 2.00 + 3.14 = 5.14$.
\item
  $2$ est un entier, $3.14$ un flottant : ces deux types sont différents et
  l'opération est impossible.
\end{itemize}

\subsection{Polymorphisme}

Dans le cas du typage statique, restreindre une opération à un seul type de
données peut être assez restrictif.

Par exemple, quel doit être le type d'une fonction qui trie un tableau ?

\begin{figure}
\centering
\input{fig/types-de-polymorphisme.tex}
\caption{Les différents types de polymorphisme.}
\label{fig:types-de-polymorphisme}
\end{figure}

\subsubsection{Monomorphisme}

Une première solution peut être de forcer des types concrets, c'est à dire
qu'une même fonction ne pourra s'appliquer qu'à un seul type de données.

Il est confortable pour le programmeur de n'avoir à écrire un algorithme qu'une
seule fois, indépendamment du type des éléments considérés.

Il existe deux grandes classes de systèmes de types introduisant du
polymorphisme.

\subsubsection{Polymorphisme universel}

% = {paramétrique, par inclusion}

Le polymorphisme est dit universel si toute fonction générique peut s'appliquer
à n'importe quel type.

\subsubsection{Polymorphisme ad-hoc}

% = {par surcharge, par coercition}

Le polymorphisme est \emph{ad-hoc} si les fonctions génériques ne peuvent
s'appliquer qu'à un ensemble de types prédéfini.

\subsubsection{Polymorphisme paramétrique}

\todo{Historique + citer le papier de Milner sur le polymorphisme}
\cite{Milner78}

\begin{figure}
  \insertcode{listappend.ml}
  \caption{Fonction de concaténation de listes en OCaml.}
  \label{fig:listappend}
\end{figure}

La fonction de la figure~\ref{fig:listappend} n'opère que sur la structure du type
liste (en utilisant ses constructeurs \texttt{{[}{]}} et \listcons ainsi que
le filtrage) : les éléments de \texttt{lx} et \texttt{ly} ne sont pas manipulés
à part pour les transférer dans le résultat.

Moralement, cette fonction est donc indépendante du type de données contenu dans
la liste : elle pourra agir sur des listes de n'importe quel type d'élément.

Plutôt qu'un type, on peut lui donner le \emph{schéma de types} suivant :

\[
  \textrm{append} : \forall a . a \textrm{list}
                             -> a \textrm{list}
                             -> a \textrm{list}
\]

C'est à dire que \texttt{append} peut être utilisé avec n'importe quel type
concret \texttt{a} en substituant les variables quantifiées (on parle d'
\emph{instanciation}).

\subsubsection{Polymorphisme par sous-typage}

\todo{héritage,sous-typage,classe,méthode,héritage multiple,late binding,Liskov}

Certains langages définissent la notion de sous-typage. C'est une relation
d'ordre partiel sur les types, qui modélise la relation "est un". Chaque
sous-classe peut redéfinir le comportement de chaque méthode de ses
superclasses.

\subsubsection{Polymorphisme par surcharge}

Considérons l'opération d'addition : \texttt{+}. On peut considérer que certains
types l'implémentent, et pas d'autres : ajouter deux flottants ou deux entiers a
du sens, mais pas ajouter deux pointeurs.

On dira que \texttt{+} est \emph{surchargé}. À chaque site d'appel, il faudra
\emph{résoudre la surcharge} pour déterminer quelle fonction appeler.

Cela rend l'inférence de types \todo{introduire l'inférence plus haut}
impossible dans le cas général, puisque certaines constructions sont ambigües.

\begin{figure}
  \insertcode{showread.hs}
  \caption{Cas d'ambigüité avec de la surcharge ad-hoc.}
  \label{fig:showread}
\end{figure}

Dans le code Haskell de la figure~\ref{fig:showread}, \texttt{show} peut
s'appliquer à toutes les valeurs de types "affichables" et renvoie une
représentation textuelle. \texttt{read} réalise le contraire avec les types
"lisibles".

Lorsqu'on compose ces deux fonctions, le type de la valeur intermédiaire est
capital puisqu'il détermine les instances de \texttt{show} et \texttt{read} à
utiliser.

\subsubsection{Polymorphisme par coercition}

\subsubsection{Polymorphisme d'ordre supérieur}

\begin{verbatim}
g f = (f true, f 2)
\end{verbatim}

\[
g : (\forall a . a -> a) -> (bool * int)
\]

Pas inférable (annotations nécessaires).

\subsection{Expressivité, garanties, types dépendants}

\section{Exemples}

\subsection{Faible dynamique : Perl}
\subsection{Faible statique : C}
\subsection{Fort dynamique : Python}
\subsection{Fort statique : OCaml}
\subsection{Fort statique à effets typés : Haskell}
\subsection{Theorem prover : Coq}
