Dans ce chapitre, nous décrivons la mise en œuvre des analyses statiques
précédentes. Nous commençons par un tour d'horizon des représentations
intermédiaires possibles, avant de décrire celle retenue : Newspeak. La chaîne
de compilation est explicitée, partant de C pour aller au langage impératif
décrit dans le chapitre~\ref{cha:lang}. Enfin, nous donnons les détails d'un
algorithme d'inférence de types à la Hindley-Milner, reposant sur l'unification
et le partage de références.

%\input{fig/il-features.tex}

\section{Newspeak}
\label{sec:npk}

Newspeak~\cite{newspeak} est un langage conçu pour être à la fois :

\begin{itemize}
  \item \textbf{Précis} : sa sémantique est définie formellement
  \cite{newspeak}
  \item \textbf{Expressif} : la plupart des primitives présentes dans les
    langages de bas niveau sont compilables en Newspeak \footnote{Penjili étant
    spécialisé dans l'aéronautique, les constructions complexes comme
    \texttt{longjmp} / \texttt{setjmp} ou les exceptions ne sont pas nécessaires.}
    % TODO adapter la footnote
  \item \textbf{Simple} : peu de primitives sont présentes.
  \item \textbf{Minimal} : aucun élément syntaxique ne peut être exprimé
    comme combinaison d'autres.
  \item \textbf{Explicite} : les constructions sont toutes indépendantes du
    contexte.
  \item \textbf{Orienté analyse} : les primitives sont décorées d'informations
    reflétant leur validité (tests de bornes, etc)
  \item \textbf{Indépendant de l'architecture} : toutes les caractéristiques comme
    la taille des types ou l'alignement des structures sont rendues explicites.
\end{itemize}

\section{Chaîne de compilation}

\begin{figure}
  \centering
  \input{fig/compil-pipeline.tex}
  \caption{Compilation depuis Newspeak}
  \label{fig:compil-npk}
\end{figure}

%TODO Mettre à jour la figure

La compilation vers C est faite en trois étapes (figure~\ref{fig:compil-npk}) :
prétraitement du code source, compilation de C prétraité vers \newspeak{}, puis
compilation de \newspeak{} vers ce langage.

\section*{Trad}

La première étape consiste à prétraiter les fichiers C source avec le logiciel
\texttt{cpp}, comme pour une compilation normale. Cette étape interprète les
directives comme \texttt{\#include}, \texttt{\#ifdef}, À cet étape, les
commentaires sont aussi supprimés.

% TODO comment interpréter les /*!npk xxx */ ?

Une fois cette passe effectuée, nous avons des fichiers C prétraités,
c'est à dire des unités de compilation autocontenues. % TODO bof

Puisque la directive \texttt{\#include} est textuelle, ces fichiers sont très
grands et donnent lieu à beaucoup de duplication dans les passes suivantes.

À ce niveau, les fichiers sont passés à l'outil \texttt{c2newspeak} qui les
traduit vers Newspeak. Dans cette étape, les types et les noms sont résolus, et
le programme est annoté de manière à rendre les prochaines étapes indépendante
du contexte. Par exemple, chaque déclaration de variable est adjointe d'une
description complète du type.

Lors de cette étape, le flôt de contrôle est également simplifié. C en effet
propose de nombreuses constructions ambigües ou redondantes.

Au contraire, Newspeak propose un nombre réduit de constructions. Rappelons que
le but de ce langage est de faciliter l'analyse statique : des constructions
orthogonales permettent donc d'éviter la duplication de règles sémantique, ou de
code lors de l'implémentation d'un analyseur.

Par exemple, plutôt que de fournir une boucle \emph{while}, une boucle
\emph{do/while} et une boucle for, Newspeak fournit une unique boucle
\npkWhile{}. La sortie de boucle est compilée vers un \npkGoto{}\cite{goto}, qui est
toujours un saut vers l'avant (similaire à un "break" généralisé).

La sémantique de Newspeak et la traduction de C vers Newspeak sont décrites dans
\cite{newspeak}.

Newspeak est conçu pour l'analyse statique par interprétation abstraite. Il a
donc une vue de bas niveau sur les programmes. Par exemple, aucune distinction
n'est faite entre l'accès à un champ et l'accès un l'élément d'un tableau (tous
deux sont traduits par un décalage numérique depuis le début de la zone
mémoire). Pour supprimer cette ambiguïté, il faut s'interfacer dans les
structures internes de \texttt{c2newspeak}, où les informations nécessaires sont
encore présentes.

Ensuite, les différents fichiers sont liés ensemble. Cet étape consiste
principalement à s'assurer que les hypothèses faites par les différentes unités
de compilation sont cohérentes entre elles. Les objets marqués \texttt{static},
invisibles à l'extérieur de leur unité de compilation, sont renommés afin qu'ils
aient un nom unique.

Enfin, l'implantation d'un algorithme d'inférence pour les systèmes de types
décrits dans les chapitres~\ref{cha:typbase} et~\ref{cha:qualifs} est assez
simple. Puisqu'ils sont suffisament proches du lambda calcul simplement typé, on
peut utiliser une variante de l'algorithme W de Damas et
Milner~\cite{DamasMilner}. On utilise l'optimisation classique qui consiste à se
reposer sur le partage de références pour réaliser l'unification, plutôt que de
faire des substitutions explicites. Puisque ces systèmes de types sont
monomorphes, on présente une erreur si des variable de type libres sont
présentes.

À la fin de cette étape, on obtient soit un programme complètement annoté, soit
une erreur de type.

\subsection{Prétraitement}

\ctonewspeak{} travaillant uniquement sur du code prétraité (dans directives de
préprocesseur), la première étape consiste donc à faire passer le code par \cpp:
les macros sont développées, les constantes remplacées par leurs valeurs, les
commentaires supprimés, les fichiers d'en-tête inclus, etc.

\subsection{Compilation (levée des ambigüités)}

Cette passe est réalisée par l'utilitaire \ctonewspeak{}. L'essentiel de la
compilation consiste à mettre à plat les définition de types, et \subsection{Annotations}

\newspeak{} a de nombreux avantages, mais pour une analyse par typage il est
trop bas niveau. Par exemple, dans le code suivant

\input{gen/struct-array.c.pyg.tex}

\wip{}

\subsection{Implantation de l'algorithme de typage}

On prend l'exemple d'un lambda-calcul simplement typé avec entiers, flottants et
couples (figure~\ref{fig:stlc}).

\begin{figure}

\input{fig/lambda-simple.tex}

\caption{Lambda calcul simplement typé avec entiers, flottants et couples}
\label{fig:stlc}

\end{figure}

Prenons l'exemple de la fonction suivante\footnote{ On suppose que \texttt{plus}
est une fonction de l'environnement global qui a pour type $\tInt \rightarrow
\tInt \rightarrow \tInt$.} :

\[
f = λx.λy. \textrm{plus} (\textrm{plus} (\textrm{fst} x) (\textrm{snd} x)) y
\]

Soit en syntaxe ML :

\begin{Verbatim}
let f x y =
  plus
    (plus
      (fst x)
      (snd x)
    )
    y
\end{Verbatim}

Puisque \texttt{fst} et \texttt{snd} sont appliqués à \texttt{x}, ce doit être
un tuple. En outre on additionne ces deux composantes ensemble, donc elles
doivent être de type \tInt (et le résultat aussi). Par le même argument,
\texttt{y} doit aussi être de type \tInt. En conclusion, \texttt{x} est de type
$\tInt × \tInt$ et \texttt{y} de type $\tInt$, donc f est de type $\tInt × \tInt
→ \tInt → \tInt$.

Pour implanter cette analyse, on peut remarquer qu'étant donné la forme d'un
terme, on peut savoir quelle règle de typage a été utilisée en dernier. Il est
ainsi possible de ``remonter'' l'arbre d'inférence afin de savoir quelles règles
ont été employées (figure~\ref{fig:inftree-rules})\footnote{Par souci de clarté,
les prémisses des applications de \textsc{(Var)} ne sont pas notées.}. Pour le
moment, on ne connait pas les types.

% TODO quel prop cela utilise t'il?

\begin{figure} % {{{ Fig règles
\def\disptypeR#1#2{:#1}

\input{fig/inftree.tex}

\caption{Arbre d'inférence : règles à utiliser}
\label{fig:inftree-rules}
\end{figure} % }}}

Une fois à cette étape, on peut donner un nom à chaque type inconnu : $t_1, t_2,
\ldots$. L'utilisation qui en est faite permet de générer un ensemble de
contraintes d'unification (figure~\ref{fig:stlc-const}).

Le symbole $?$ qui apparait dans les règles correspond à ``n'importe quel
type'', dans le sens où l'unification avec ce symbole est toujours possible.

\begin{figure} % {{{
  \def\stlcConst#1#2{
  \fbox{
    \begin{tabular}{m{3.5cm}||c}
      \raggedleft \fbox{\raggedleft \ensuremath{#1}} & \fbox{\ensuremath{#2}}
    \end{tabular}
  }
  }
  \centering
  \begin{tabular}{m{4cm}||lm{4cm}||l}
    \raggedleft
    $
    \irule{Var}
      { (x, t_x) ∈ Γ }
      { Γ ⊢ x : t_1 }
    $
    &
    $
      t_1 = t_x
    $
    &
    \raggedleft
    $
    \irule{Abs}
      { Γ, (x:t_x) ⊢     e : t_2 }
      { Γ          ⊢ λx. e : t_1 }
    $
    &
    $
      t_1 = t_x → t_2
    $
    \\
    \multicolumn{4}{c}{} \\
    \raggedleft
    $
    \irule{App}
      { Γ ⊢ e_1 : t_1
     \\ Γ ⊢ e_2 : t_2
      }
      { Γ ⊢ e_1~e_2 : t_3 }
    $
    &
    $
      t_1 = t_2 → t_3
    $
    &
    \raggedleft
    $
    \irule{Proj-G}
      { Γ ⊢ e : t_2 }
      { Γ ⊢ \termFst{e} : t_1 }
    $
    &
    $
      t_2 = t_1 × ?
    $
    \\
    \multicolumn{4}{c}{} \\
    \raggedleft
    $
    \irule{Proj-D}
      { Γ ⊢ e : t_2 }
      { Γ ⊢ \termSnd{e} : t_1 }
    $
    &
    $
      t_2 = ? × t_1
    $
    &
    \raggedleft
    $
    \irule{Tup}
       { Γ⊢e_1:t_1
      \\ Γ⊢e_2:t_2
      }{
        Γ⊢(e_1,e_2):t_3
      }
    $
    &
    $
    t_3 = t_1 \times t_2
    $
  \end{tabular}
\caption{Contraintes crées par les applications de règles}
\label{fig:stlc-const}
\end{figure} %}}}

\begin{figure}
\centering

\subbottom[Contraintes]{
  \label{fig:inf-constr-ex}
  \begin{minipage}{0.5\linewidth}
  \begin{align}
  t_1    &= t_x → t_2             \tag{Abs1} \\
  t_2    &= t_y → t_3             \tag{Abs2} \\
  t_5    &= t_4 → t_3             \tag{App1} \\
  t_4    &= t_y                   \tag{Var1} \\
  t_6    &= t_7 → t_5             \tag{App2} \\
  t_6    &= \tInt → \tInt → \tInt \tag{Var2} \\
  t_{10} &= t_8 → t_7             \tag{App3} \\
  t_9    &= ? × t_8               \tag{Proj-D1} \\
  t_9    &= t_x                   \tag{Var3} \\
  t_{11} &= t_{12} → t_{10}       \tag{App4} \\
  t_{11} &= \tInt → \tInt → \tInt \tag{Var4} \\
  t_{13} &= t_{12} × ?            \tag{Proj-G1} \\
  t_{13} &= t_x                   \tag{Var5}
  \end{align}
  \end{minipage}
}
\subbottom[Solution]{
  \label{fig:inf-sol-ex}
  \begin{minipage}{0.3\linewidth}
  \begin{align*}
  t_{1}  &= \tInt × \tInt → \tInt \\
  t_{2}  &= \tInt → \tInt         \\
  t_{3}  &= \tInt                 \\
  t_{4}  &= \tInt                 \\
  t_{5}  &= \tInt → \tInt         \\
  t_{6}  &= \tInt → \tInt → \tInt \\
  t_{7}  &= \tInt                 \\
  t_{8}  &= \tInt                 \\
  t_{9}  &= \tInt × \tInt         \\
  t_{10} &= \tInt → \tInt         \\
  t_{11} &= \tInt → \tInt → \tInt \\
  t_{12} &= \tInt                 \\
  t_{13} &= \tInt × \tInt         \\
  t_{x}  &= \tInt × \tInt         \\
  t_{y}  &= \tInt
  \end{align*}
  \end{minipage}
}

\caption{Contraintes d'égalité et solution obtenues à partir de la
figure~\ref{fig:inftree-rules}}

\end{figure}

% TODO mal numéroté

On en déduit donc un ensemble de contraintes d'égalité
(figure~\ref{fig:inf-constr-ex}). La prochaine étape est de résoudre ce système.
D'après (App1) et (App2), $t_6 = t_7 → t_4 → t_3$ d'où par (Var2), $t_7 → t_4 →
t_3 = \tInt → \tInt → \tInt$. Le constructeur $→$ étant injectif, on a donc $t_3
= t_4 = t_7 = \tInt$. En procédant de même avec (App3) et (App4), on obtient
$t_8 = t_{12} = \tInt$. D'après (Proj-G1), (Var5), (Var3), et (Proj-D1) on a
$t_{12} × ? = t_{13} = t_{x} = t_9 = ? × t_{8}$, donc $t_x = t_{12} × t_8 =
\tInt × \tInt$. En remplaçant, on obtient tous les autres types
(figures~\ref{fig:inf-sol-ex}) et donc un arbre de typage complet
(figure~\ref{fig:inftree-full}).

\begin{figure} % {{{ Fig full tree
\def\disptypeR#1#2{:#2}

\input{fig/inftree.tex}

\caption{Arbre d'inférence complet}
\label{fig:inftree-full}
\end{figure} % }}}


Pour effectuer une résolution de manière automatique, il faut une technique
d'unification. La manière la plus classique de procéder est due à
Robinson~\cite{robinson} et se déroule par substitution.


\clearpage

Pour résoudre ces contraintes, on commence par les simplifier : si $t_a
\rightarrow t_b = t_c \rightarrow t_d$, alors $t_a = t_c$ et $t_b = t_d$. De
même si $t_a \times t_b = t_c \times t_d$. Au contraire, si $t_a \rightarrow t_b
= t_c \times t_d$, il est impossible d'unifier les types et il faut abandonner
l'inférence de types. D'autre cas sont impossibles, par exemple $\tInt = t_1
\rightarrow t_2$ ou $\tInt = \tFloat$.

Une fois ces simplifications réalisées, les contraintes restantes sont d'une des
formes suivantes :

\begin{itemize}
\item
  $t_i = t_i$. Il n'y a rien à faire, cette contrainte peut être supprimée.
\item
  $t_i = t_j$ avec $i \ne j$ : toutes les occurrences de $t_j$ dans les autres
  contraintes peuvent être remplacées par $t_i$.
\item
  $t_i = x$ (ou $x = t_i$) où $x$ est un type concret : idem.
\end{itemize}

%TODO C'est faux

\clearpage

\begin{figure} % fig:unifpartage {{{

  \subbottom{
  \label{fig:unifpartage:a}
  \begin{tikzpicture}
  \node               (var) {Var};
  \node[right of=var] (ref) {ref};
  \node[right of=ref, node distance=1.7cm] (u0) {Unknown 0};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (var);
  \draw[->] (var) -- (ref);
  \draw[->] (ref) -- (u0);
  \end{tikzpicture}
  }
  \subbottom{
  \label{fig:unifpartage:b}
  \begin{tikzpicture}
  \node               (var) {Var};
  \node[right of=var] (ref) {ref};
  \node[right of=ref, node distance=1.7cm] (u0) {Instanciated};
  \node[right of=u0, node distance=1.7cm] (ii) {Int};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (var);
  \draw[->] (var) -- (ref);
  \draw[->] (ref) -- (u0);
  \draw[->] (u0) -- (ii);
  \end{tikzpicture}
  }
  \subbottom{
  \label{fig:unifpartage:c}
  \begin{tikzpicture}
  \node               (var) {Int};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \node[right of=ptr] (pi) {Int};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (pi);
  \end{tikzpicture}
  }

  \caption{Unification par partage}
  \label{fig:unifpartage}

\end{figure} % }}}

Plutôt que de modifier toutes les occurrences d'un type $t_i$, on va affecter à
$t_i$ la valeur du nouveau type.

L'implémentation de cet algorithme utilise le partage et les références
(figure~\ref{fig:unifpartage}).

D'abord \ref{fig:unifpartage:a}, ensuite \ref{fig:unifpartage:b}, et enfin
\ref{fig:unifpartage:c}.

\begin{figure} % fig:exunif:c {{{

  \insertcode{ex-unif-c.c}

  \caption{Compilation d'un programme C - avant}
  \label{fig:exunif:c}
\end{figure} % }}}

Prenons l'exemple de la figure~\ref{fig:exunif:c} et typons-le "à la main". On
commence par oublier toutes les étiquettes de type présentes dans le programme.
Celui-ci devient alors :

\insertcode{exunif-code.c}

La premiere ligne introduit deux variables. On peut noter leurs types respectifs
(inconnus pour le moment) $t_1$ et $t_2$. La première affectation \texttt{p =
\&x} implique que les deux côtés du signe "=" ont le même type. À gauche, le
type est $t_2$, et à droite $Ptr(t_1)$. On applique le même raisonnement à la
seconde affectation : à gauche, le type est $t_1$ et à droite Int. On en déduit
que le type de x est Int et celui de p est Ptr(Int).


\insertcode{lambda-types.ml}

Pour implanter cet algorithme, on représente les types de données du programmes
à typer par une valeur de type \texttt{ml\_type}. En plus des constantes de
types comme int ou float, et des constructeurs de type comme pair et fun, le
constructeur Var permet d'exprimer les variables de types (inconnues ou non).

Celles-ci sont numérotées par un int, on suppose avoir à disposition deux
fonctions manipulant un compteur global d'inconnues.

\insertcode{exunif-counter.ml}

De plus, on a un module gérant les environnements de typage. Il pourra être
implanté avec des listes d'association ou des tables de hachage, par exemple. Sa
signature est :

\insertcode{exunif-env.ml}

Reprenons l'exemple précédent. Partant d'un environnement vide (Env.empty), on
commence par l'étendre de deux variables. Comme on n'a aucune information, il
fait allouer des nouveaux noms d'inconnues (qui correspondent à $t_1$ et $t_2$):

\insertcode{exunif-1.ml}

La première instruction indique que les deux côtés de l'affectation doivent
avoir le même type.

\insertcode{exunif-2.ml}

\begin{figure}
  \centering
  \begin{tikzpicture}
    [scale=2.3]

    \node at (0,  0) (n0a) {t1:};
    \node at (0, -1) (n0b) {t2:};

    \node at (1,  0) (n1a) {Var\_type};
    \node at (2,  0) (n2a) {ref};
    \node at (3,  0) (n3a) {Unknown 0};

    \node at (1, -1) (n1b) {Var\_type};
    \node at (2, -1) (n2b) {ref};
    \node at (3, -1) (n3b) {Instanciated};
    \node at (4, -1) (n4b) {Ptr};

    \draw [->] (n1a) -- (n2a);
    \draw [->] (n2a) -- (n3a);

    \draw [->] (n1b) -- (n2b);
    \draw [->] (n2b) -- (n3b);
    \draw [->] (n3b) -- (n4b);

    \draw [->] (n4b) -- ++ (0, 0.5) -| (n1a);

  \end{tikzpicture}
  \caption{Unification : partage}
  \label{fig:unifsharing}
\end{figure}

Ici il se passe plusieurs choses intéréssantes. D'une part nous faisont appel à
une fonction externe typeof qui retourne le type d'une expression sous un
environnement (dans une implantation complète il s'agirait d'un appel récursif).
Dans ce cas, \texttt{typeof lhs1 env} est identique à \texttt{Env.get lhs1 env}
et \texttt{typeof rhs1 env} à \texttt{Ptr\_type t1}. L'autre aspect intéressant
est la dernière ligne : la fonction \texttt{unify} va modifier en place les
représentations des types afin de les rendre égales. L'implantation de
\texttt{unify} sera décrite plus tard. Dans ce cas précis, elle va faire pointer
la référence dans t2 vers t1 (figure~\ref{fig:unifsharing}).

Enfin, la seconde affectation se déroule à peu près de la même manière.

\insertcode{exunif-3.ml}

Ici \texttt{typeof lhs2 env} est identique à \texttt{Ptr\_type (Env.get "p"
env)} et \texttt{typeof lhs2 env} à \texttt{Const\_type Int\_type}. Et dans cas,
l'unification doit se faire entre t1 et \texttt{Const\_type Int\_type} : cela
mute la référence derrière t1 (figure~\ref{fig:typeunifref}).

\begin{figure}
  \begin{tikzpicture}
    [scale=2.3]

    \node at (0,  0) (n0a) {t1:};
    \node at (0, -1) (n0b) {t2:};

    \node at (1,  0) (n1a) {Var\_type};
    \node at (2,  0) (n2a) {ref};
    \node at (3,  0) (n3a) {Instanciated};
    \node at (4,  0) (n4a) {Const\_type};
    \node at (5,  0) (n5a) {Int\_type};

    \node at (1, -1) (n1b) {Var\_type};
    \node at (2, -1) (n2b) {ref};
    \node at (3, -1) (n3b) {Instanciated};
    \node at (4, -1) (n4b) {Ptr};

    \draw [->] (n1a) -- (n2a);
    \draw [->] (n2a) -- (n3a);
    \draw [->] (n3a) -- (n4a);
    \draw [->] (n4a) -- (n5a);

    \draw [->] (n1b) -- (n2b);
    \draw [->] (n2b) -- (n3b);
    \draw [->] (n3b) -- (n4b);

    \draw [->] (n4b) -- ++ (0, 0.5) -| (n1a);

  \end{tikzpicture}
  \caption{Unification par mutation de références}
  \label{fig:typeunifref}
\end{figure}

L'essence de l'algorithme d'inférence se situe donc dans 2 fonctions. D'une
part, \texttt{unify} qui réalise l'unification des types grâce à au partage des
références. D'autre part, la \texttt{typeof} qui encode les règles de typage
elles-mêmes et les applique à l'aide de \texttt{unify}.

\subsection{Algorithme d'unification}

Voici une implantation de la fonction \texttt{unify}.

Celle-ci prend en entrée deux types $t_1$ et $t_2$. À l'issue de l'exécution de
\texttt{unify}, ces deux types doivent pouvoir être considérés comme égaux. Si
ce n'est pas possible, une erreur sera levée.

La première étape est de réduire ces deux types, c'est à dire à transformer les
constructions \texttt{Var (ref (Instanciated t))} en \texttt{t}.

Ensuite, cela dépend des formes qu'ont les types réduits :

\begin{figure}
  \centering
  \begin{tikzpicture}
    [every node/.style={node distance=2cm}
    ,>=latex
    ]

    \node (n1) {Ptr};
    \node[right of=n1] (n2) {Var};
    \node[right of=n2] (n3) {ref};
    \node[right of=n3] (n4) {Instanciated};

    \draw [->] (n1) -- (n2);
    \draw [->] (n2) -- (n3);
    \draw [->] (n3) -- (n4);

    \draw [->] (n4) -- ++ (0, -1cm) -| (n1);

  \end{tikzpicture}
  \caption{Cycle dans le graphe de types}
  \label{fig:typecycle}
\end{figure}

\begin{itemize}

\item si les deux types sont inconnus (de la forme \texttt{Var (ref
(Instanciated t))}), on fait pointer l'une des deux références vers le premier
type. Notons que cela crée un type de la forme \texttt{Var (ref (Instanciated
(Var (ref (Unknown n)))))} qui sera réduit lors d'une prochaine étape
d'unification.

\item si un type est inconnu et pas l'autre, il faut de la même manière affecter la
référence. Mais en faisant ça inconditionnellement, cela peut poser problème :
par exemple en tentant d'unifier \texttt{a} avec \texttt{Ptr(a)} on pourrait
créer un cycle dans le graphe (figure~\ref{fig:typecycle}).
Pour éviter cette situation, il suffit de s'assurer que le type inconnu n'est
pas présent dans le type à affecter.

\item si les deux types sont des types de base (comme \tInt ou \tFloat) égaux,
on ne fait rien.

\item si les deux types sont des constructeurs de type, il faut que les
constructeurs soient égaux. On unifie en outre leurs arguments deux à deux.

\item dans les autres cas, l'algorithme échoue.

\item TODO sous typage pour les structures

\end{itemize}

TODO :

\begin{itemize}
\item implem du polymorphisme
\item implem du sous-typage
\item généralisation depuis le toy language
\end{itemize}

\clearpage

\begin{figure} % fig:exunif:tpk {{{

  \insertcode{ex-unif-tpk.ml}

  \caption{Compilation d'un programme C - après}
  \label{fig:exunif:tpk}
\end{figure} % }}}

Le programme C (figure~\ref{fig:exunif:c}) est compilé ainsi en Tyspeak
(figure~\ref{fig:exunif:tpk}).

\section{Unification}

% template {{{
%\begin{Verbatim}
%\end{Verbatim} % }}}

\begin{figure}
% types {{{
\begin{Verbatim}
type unknown = { id : int }

type 'a var_type =
  | Unknown of unknown
  | Instanciated of 'a

and qual =
  | Kernel
  | User
  | QVar of qual var_type ref

and simple =
  | Int
  | Float
  | Fun of simple list * simple list
  | Ptr of qual * simple
  | Array of simple
  | Struct of (int * simple) list ref
  | Var of simple var_type ref
\end{Verbatim}
% }}}
\caption{Implantation - types}
\label{fig:implem-typ}
\end{figure}

Les types de données utilisés sont donnés dans la figure~\ref{fig:implem-typ}.
Les types \langname sont représentés soit par un constructeur de type ``résolu''
immutable comme \texttt{Int}, soit par une référence dans le cas d'une variable
inconnue (placée alors derrière le constructeur \texttt{Var}).

Ces références contiennent une valeur du type \texttt{simple var\_type}, c'est à
dire :

\begin{itemize}
\item soit un numéro d'inconnue (constructeur \texttt{Unknown})\footnote{On
  place le numéro dans un enregistrement pour abstraire l'entier sous-jacent, en
  empêchant par exemple de faire de l'arithmétique sur celui-ci.}.

\item soit un type concret (constructeur \texttt{Instanciated}) si cette
  inconnue a été unifiée avec un type concret.
\end{itemize}

Ce système peut créer des représentations de types arbitrairement longues, comme
par exemple :

\texttt{Var (ref (Instanciated (Var (ref (Instanciated Int)))))}

Cela est dû au fait que \texttt{fun x -> Var (ref (Instanciated x))} est typé
\texttt{simple -> simple} et peut donc être appliquée à loisir. Pour éviter cet
effet d'allongement, on définit une fonction \texttt{shorten} qui supprime ces
chaînes (figure~\ref{fig:implem-shorten}).

% TODO décrire la première branche du pattern matching

\begin{figure}
% shorten {{{
\begin{Verbatim}
let rec shorten = function
  | Var ({contents = Instanciated (Var _ as t)} as vt) ->
      let t2 = shorten t in
      vt := Instanciated t;
      t2
  | Var {contents = Instanciated t} -> t
  | t -> t
\end{Verbatim}
% }}}
\caption{Implantation : fonction de racourcissement des représentations de types}
\label{fig:implem-shorten}
\end{figure}

La fonction d'unification, quant à elle, commence par raccourcir ses deux
arguments puis faire une analyse de cas par filtrage.

Les cas principaux pour unifier deux types réduits \texttt{sta} et \texttt{stb}
sont :

\begin{itemize}

\item \texttt{sta} et \texttt{stb} sont deux inconnues. Alors on modifie l'un
  pour pointer sur l'autre. Les références étant uniques et partagées, cela
  revient à substituer l'un par l'autre dans toutes les représentations de
  types.

\item Un type est concret, l'autre une inconnue. Dans ce cas on modifie le
  second comme étant un \texttt{Instanciated} du premier. Il faut vérifier que
  le type inconnu remplacé n'apparaît pas dans le type concret, sinon on créé un
  cycle. Ce cas a lieu par exemple quand on cherche à unifier $a$ avec
  $a~\qKernel~*$. Il faut alors signaler une erreur, ce que fait la fonction
  \texttt{occurs\_check\_failed}.

\item Les deux types sont des types concrets. Alors ils sont de la forme
  respective
  $C (t_1, …, t_n)$
  et
  $D (u_1, …, u_m)$ où $C$ et $D$ sont des constructeurs de type avec
  respectivement $n$ et $m$ arguments
  \footnote{
    Le cas $n = 0$ ou $m = 0$ correspond aux types concrets comme $\tInt$ ou
    $\tFloat$.
  }. Si $C = D$ et
  $n = m$, alors on unifie récursivementchaque $t_i$ avec $u_i$. Sinon on lève une erreur
  (fonction \texttt{type\_clash}).

  % TODO structures

\end{itemize}

Cette analyse de cas est implantée dans la fonction \texttt{unify_now}
(figure~\ref{fig:implem-unify-now}).

\begin{figure}
% unify_now % {{{
\begin{Verbatim}
let rec unify_now ta tb =
  let sta = shorten ta in
  let stb = shorten tb in
  match (sta, stb) with
  | ((Var ({contents = Unknown na} as ra)),
     (Var  {contents = Unknown nb})) ->
       begin
         if na <> nb then
           ra := Instanciated stb
       end
  | ((Var ({contents = Unknown {id = n}} as r)), t)
    ->
      begin
        if occurs n t then
          occurs_check_failed sta stb
        else
          r := Instanciated t
      end
  | (_, (Var ({contents = Unknown _}))) -> unify_now stb sta

  | Int, Int
  | Float, Float -> ()

  | Ptr (qa, ta), Ptr (qb, tb) ->
      unify_quals qa qb;
      unify_now ta tb

  | Array a, Array b -> unify_now a b

  | Fun (args_a, rets_a), Fun (args_b, rets_b) ->
      List.iter2 unify_now args_a args_b;
      List.iter2 unify_now rets_a rets_b

  | Struct rfa, Struct rfb ->
      unify_structs rfa rfb

  | _ -> type_clash sta stb
\end{Verbatim}
% }}}
\caption{Implantation - fonction d'unification}
\label{fig:implem-unify-now}
\end{figure}

cas structure (figure~\ref{fig:implem-unify-structs}).

\begin{figure}
% unify_structs % {{{
\begin{Verbatim}
let unify_structs rfa rfb =
  let fa = !rfa in
  let fb = !rfb in

  let new_a = ref [] in
  let new_b = ref [] in

  let unify_fields = function
    | _, InBoth (ta, tb) -> unify_now ta tb
    | k, OnlyL f -> new_b := (k,f) :: !new_b
    | k, OnlyR f -> new_a := (k,f) :: !new_a
  in

  List.iter unify_fields (compare_lists fa fb);
  let by_offset (x, _) (y, _) =
    compare x y
  in
  rfa := List.sort by_offset (!new_a @ !rfa);
  rfb := List.sort by_offset (!new_b @ !rfb)
\end{Verbatim}
% }}}
\caption{Implantation - structures}
\label{fig:implem-unify-structs}
\end{figure}

Pour les pointeurs, il est nécessaire de définir des fonctions similaires sur
les qualificateurs (figure~\ref{fig:implem-qualifs}).

\begin{figure}
% qualifs {{{
\begin{Verbatim}
let rec shorten_q = function
  | QVar ({contents = Instanciated (QVar _ as t)} as vt) ->
      let t2 = shorten_q t in
      vt := Instanciated t;
      t2
  | QVar {contents = Instanciated t} -> t
  | t -> t

let rec unify_quals a b =
  let sa = shorten_q a in
  let sb = shorten_q b in
  match (sa, sb) with
  | User, User -> ()
  | Kernel, Kernel -> ()
  | ((QVar ({contents = Unknown na} as ra)),
     (QVar  {contents = Unknown nb})) ->
       begin
         if na <> nb then
           ra := Instanciated sb
       end
  | ((QVar ({contents = Unknown {id = n}} as r)), q)
    ->
      begin
        if occurs_q n q then
          occurs_q_check_failed sa sb
        else
          r := Instanciated q
      end
  | (_, (QVar ({contents = Unknown _}))) -> unify_quals sb sa
  | _ -> Utils.error "Cannot unify qualifiers:\n  %s\n  %s\n"
                        (string_of_qual sa)
                        (string_of_qual sb)
\end{Verbatim}
% }}}

\caption{Implantation - qualificateurs}
% TODO mettre des emdash
\label{fig:implem-qualifs}

\end{figure}

\section{Système de types}

% infer_stmtkind {{{
\begin{Verbatim}
let rec infer_stmtkind env sk =
  match sk with
  | T.Set (lv, e, st) ->
      let lv' = infer_lv env lv in
      let tlv = lval_type env lv in
      let (_, te) as e' = infer_exp env e in
      unify te tlv;
      T.Set (lv', e', st)
  | T.Select (a, b) ->
      let a' = infer_blk env a in
      let b' = infer_blk env b in
      T.Select (a', b')
  | T.InfLoop blk ->
      let blk' = infer_blk env blk in
      T.InfLoop blk'
  | T.DoWith (blk, lbl) ->
      let new_env = Env.add_lbl lbl env in
      let blk' = infer_blk new_env blk in
      T.DoWith (blk', lbl)
  | T.Goto lbl ->
      Env.assert_lbl lbl env;
      T.Goto lbl
  | T.Decl (n, nty, _ty, blk) ->
      let var = T.Local n in
      let t0 = new_unknown () in
      let new_env = Env.add (VLocal n) (Some nty) t0 env in
      let blk' = infer_blk new_env blk in
      let ty = lval_type new_env var in
      T.Decl (n, nty, ty, blk')
  | T.UserSpec a -> T.UserSpec (infer_assertion env a)
  | T.Copy (dst, src, sz) ->
      let dst' = infer_lv env dst in
      let src' = infer_lv env src in
      T.Copy (dst', src', sz)
  | T.Guard e -> T.Guard (infer_exp env e)
  | T.Call (args, fexp, rets) ->
      (*
       * Warning : plumbing ahead.
       *
       * Nothing interesting here : we just construct a Fun type corresponding
       * to the actual arguments and unify it with the formal arguments from
       * the environment.
       *)

      let infer_arg (e, nt) =
        let et = infer_exp env e in
        (et, nt)
      in

      let infer_ret (lv, nt) =
        (infer_lv env lv, nt)
      in

      let args' = List.map infer_arg args in
      let rets' = List.map infer_ret rets in

      let t_args = List.map (fun ((_, t), _) -> t) args' in
      let t_rets = List.map (fun (lv, _) -> lval_type env lv) rets' in

      let (fexp', tf) = infer_funexp env fexp in
      let call_type = Fun (t_args, t_rets) in
      unify tf call_type;

      T.Call (args', fexp', rets')
\end{Verbatim}
% }}}

\section{Exemple}

Lançons l'analyse sur un petit exemple :

\begin{verbatim}
int f(int *x) { return (*x + 1); }
\end{verbatim}

L'exécution de notre analyseur affiche un programme complètement annoté :

\begin{verbatim}
 % ptrtype example.c
f : (Ptr (Int)) -> (Int)
Int (example.c:1#4)^f(Ptr (Int) x) {
  (.c:3#4)^!return =(int32)
    (coerce[-2147483648,2147483647]
      ( ( ([(x_Ptr (Int) : Ptr (Int))]32_Int
            : Int
          )
          + (1 : Int)
        ) : Int
      ) : Int
    );
}
\end{verbatim}

L'opérateur \texttt{coerce[a,b]} est un artefact de Newspeak, destiné à détecter
les débordements d'entiers lors d'une analyse de valeurs par interprétation
abstraite. Dans le cas de notre analyse, les valeurs ne sont pas pertinentes et
cet opérateur peut être vu que comme un ``plus'' unaire typé $(\tInt) → \tInt$.

\emph{A contrario}, lorsqu'il n'est pas possible d'inférer des types
compatibles, l'analyseur s'arrête avec une erreur.

\begin{verbatim}
void f(int *p) {
    /*!npk userptr p */
    *p = 3;
}
\end{verbatim}

Le commentaire \texttt{/*!npk userptr p */} est interpréter par l'analyseur et
le fait unifier le type de \texttt{p} avec $t~\qUser~*$, c'est à dire qu'il
force son qualificateur à être \qUser.

\begin{verbatim}
04-addrof.c:4#4 - Cannot unify qualifiers:
  Kernel
  User
\end{verbatim}

On signale l'emplacement où la dernière unification a échoué.

\section*{Extrait PLAS}

The language described above, as well as a type inference algorithm, have been
implemented in OCaml as part of the Newspeak framework of program
analysis\cite{newspeak}. It is released under the GNU Lesser General Public
License, and is available on \texttt{http://penjili.org} (directory
\texttt{src/ptrtype} in the distribution). Our implementation consists of the
following steps.

but to analyze larger parts of the kernel, it may be
necessary to define a ``maximal'' configuration file (which is impossible
because of incompatibilities between some options).


% vim: spelllang=fr
