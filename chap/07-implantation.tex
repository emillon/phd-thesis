Dans ce chapitre, nous décrivons la mise en œuvre des analyses statiques
précédentes. Nous commençons par un tour d'horizon des représentations
intermédiaires possibles, avant de décrire celle retenue : Newspeak. La chaîne
de compilation est explicitée, partant de C pour aller au langage impératif
décrit dans le chapitre~\ref{cha:lang}. Enfin, nous donnons les détails d'un
algorithme d'inférence de types à la Hindley-Milner, reposant sur l'unification
et le partage de références.

%\input{fig/il-features.tex}

\section{Newspeak}
\label{sec:npk}

Newspeak~\cite{newspeak} est un langage conçu pour être à la fois :

\begin{itemize}
  \item \textbf{Précis} : sa sémantique est définie formellement
  \cite{newspeak}
  \item \textbf{Expressif} : la plupart des primitives présentes dans les
    langages de bas niveau sont compilables en Newspeak \footnote{Penjili étant
    spécialisé dans l'aéronautique, les constructions complexes comme
    \texttt{longjmp} / \texttt{setjmp} ou les exceptions ne sont pas nécessaires.}
    % TODO adapter la footnote
  \item \textbf{Simple} : peu de primitives sont présentes.
  \item \textbf{Minimal} : aucun élément syntaxique ne peut être exprimé
    comme combinaison d'autres.
  \item \textbf{Explicite} : les constructions sont toutes indépendantes du
    contexte.
  \item \textbf{Orienté analyse} : les primitives sont décorées d'informations
    reflétant leur validité (tests de bornes, etc)
  \item \textbf{Indépendant de l'architecture} : toutes les caractéristiques comme
    la taille des types ou l'alignement des structures sont rendues explicites.
\end{itemize}

\section{Chaîne de compilation}

\begin{figure}
  \centering
  \input{fig/compil-pipeline.tex}
  \caption{Compilation depuis Newspeak}
  \label{fig:compil-npk}
\end{figure}

%TODO Mettre à jour la figure

La compilation vers C est faite en trois étapes (figure~\ref{fig:compil-npk}) :
prétraitement du code source, compilation de C prétraité vers \newspeak{}, puis
compilation de \newspeak{} vers ce langage.

\section*{Trad}

La première étape consiste à prétraiter les fichiers C source avec le logiciel
\texttt{cpp}, comme pour une compilation normale. Cette étape interprète les
directives comme \texttt{\#include}, \texttt{\#ifdef}, À cet étape, les
commentaires sont aussi supprimés.

% TODO comment interpréter les /*!npk xxx */ ?

Une fois cette passe effectuée, nous avons des fichiers C prétraités,
c'est à dire des unités de compilation autocontenues. % TODO bof

Puisque la directive \texttt{\#include} est textuelle, ces fichiers sont très
grands et donnent lieu à beaucoup de duplication dans les passes suivantes.

À ce niveau, les fichiers sont passés à l'outil \texttt{c2newspeak} qui les
traduit vers Newspeak. Dans cette étape, les types et les noms sont résolus, et
le programme est annoté de manière à rendre les prochaines étapes indépendante
du contexte. Par exemple, chaque déclaration de variable est adjointe d'une
description complète du type.

Lors de cette étape, le flôt de contrôle est également simplifié. C en effet
propose de nombreuses constructions ambigües ou redondantes.

Au contraire, Newspeak propose un nombre réduit de constructions. Rappelons que
le but de ce langage est de faciliter l'analyse statique : des constructions
orthogonales permettent donc d'éviter la duplication de règles sémantique, ou de
code lors de l'implémentation d'un analyseur.

Par exemple, plutôt que de fournir une boucle \emph{while}, une boucle
\emph{do/while} et une boucle for, Newspeak fournit une unique boucle
\npkWhile{}. La sortie de boucle est compilée vers un \npkGoto{}\cite{goto}, qui est
toujours un saut vers l'avant (similaire à un "break" généralisé).

La sémantique de Newspeak et la traduction de C vers Newspeak sont décrites dans
\cite{newspeak}.

Newspeak est conçu pour l'analyse statique par interprétation abstraite. Il a
donc une vue de bas niveau sur les programmes. Par exemple, aucune distinction
n'est faite entre l'accès à un champ et l'accès un l'élément d'un tableau (tous
deux sont traduits par un décalage numérique depuis le début de la zone
mémoire). Pour supprimer cette ambiguïté, il faut s'interfacer dans les
structures internes de \texttt{c2newspeak}, où les informations nécessaires sont
encore présentes.

Ensuite, les différents fichiers sont liés ensemble. Cet étape consiste
principalement à s'assurer que les hypothèses faites par les différentes unités
de compilation sont cohérentes entre elles. Les objets marqués \texttt{static},
invisibles à l'extérieur de leur unité de compilation, sont renommés afin qu'ils
aient un nom unique.

Enfin, l'implantation d'un algorithme d'inférence pour les systèmes de types
décrits dans les chapitres~\ref{cha:typbase} et~\ref{cha:qualifs} est assez
simple. Puisqu'ils sont suffisament proches du lambda calcul simplement typé, on
peut utiliser une variante de l'algorithme W de Damas et
Milner~\cite{DamasMilner}. On utilise l'optimisation classique qui consiste à se
reposer sur le partage de références pour réaliser l'unification, plutôt que de
faire des substitutions explicites. Puisque ces systèmes de types sont
monomorphes, on présente une erreur si des variable de type libres sont
présentes.

À la fin de cette étape, on obtient soit un programme complètement annoté, soit
une erreur de type.

\subsection{Prétraitement}

\ctonewspeak{} travaillant uniquement sur du code prétraité (dans directives de
préprocesseur), la première étape consiste donc à faire passer le code par \cpp:
les macros sont développées, les constantes remplacées par leurs valeurs, les
commentaires supprimés, les fichiers d'en-tête inclus, etc.

\subsection{Compilation (levée des ambigüités)}

Cette passe est réalisée par l'utilitaire \ctonewspeak{}. L'essentiel de la
compilation consiste à mettre à plat les définition de types, et \subsection{Annotations}

\newspeak{} a de nombreux avantages, mais pour une analyse par typage il est
trop bas niveau. Par exemple, dans le code suivant

\input{gen/struct-array.c.pyg.tex}

\wip{}

\subsection{Implantation de l'algorithme de typage}

On prend l'exemple d'un lambda-calcul simplement typé avec entiers, flottants et
couples (figure~\ref{fig:stlc}).

\begin{figure}

\input{fig/lambda-simple.tex}

\caption{Lambda calcul simplement typé avec entiers, flottants et couples}
\label{fig:stlc}

\end{figure}

Prenons l'exemple de la fonction suivante\footnote{ On suppose que \texttt{plus}
est une fonction de l'environnement global qui a pour type $\tInt \rightarrow
\tInt \rightarrow \tInt$.} :

\[
f = λx.λy. \textrm{plus} (\textrm{plus} (\textrm{fst} x) (\textrm{snd} x)) y
\]

Soit en syntaxe ML :

\begin{Verbatim}
let f x y =
  plus
    (plus
      (fst x)
      (snd x)
    )
    y
\end{Verbatim}

Puisque \texttt{fst} et \texttt{snd} sont appliqués à \texttt{x}, ce doit être
un tuple. En outre on additionne ces deux composantes ensemble, donc elles
doivent être de type \tInt (et le résultat aussi). Par le même argument,
\texttt{y} doit aussi être de type \tInt. En conclusion, \texttt{x} est de type
$\tInt × \tInt$ et \texttt{y} de type $\tInt$, donc f est de type $\tInt × \tInt
→ \tInt → \tInt$.

Pour implanter cette analyse, on peut remarquer qu'étant donné la forme d'un
terme, on peut savoir quelle règle de typage a été utilisée en dernier. Il est
ainsi possible de ``remonter'' l'arbre d'inférence afin de savoir quelles règles
ont été employées (figure~\ref{fig:inftree-rules})\footnote{Par souci de clarté,
les prémisses des applications de \textsc{(Var)} ne sont pas notées.}. Pour le
moment, on ne connait pas les types.

% TODO quel prop cela utilise t'il?

\begin{figure} % {{{ Fig règles
\def\disptypeR#1#2{:#1}

\input{fig/inftree.tex}

\caption{Arbre d'inférence : règles à utiliser}
\label{fig:inftree-rules}
\end{figure} % }}}

Une fois à cette étape, on peut donner un nom à chaque type inconnu : $t_1, t_2,
\ldots$. L'utilisation qui en est faite permet de générer un ensemble de
contraintes d'unification (figure~\ref{fig:stlc-const}).

Le symbole $?$ qui apparait dans les règles correspond à ``n'importe quel
type'', dans le sens où l'unification avec ce symbole est toujours possible.

\begin{figure} % {{{
  \def\stlcConst#1#2{
  \fbox{
    \begin{tabular}{m{3.5cm}||c}
      \raggedleft \fbox{\raggedleft \ensuremath{#1}} & \fbox{\ensuremath{#2}}
    \end{tabular}
  }
  }
  \centering
  \begin{tabular}{m{4cm}||lm{4cm}||l}
    \raggedleft
    $
    \irule{Var}
      { (x, t_x) ∈ Γ }
      { Γ ⊢ x : t_1 }
    $
    &
    $
      t_1 = t_x
    $
    &
    \raggedleft
    $
    \irule{Abs}
      { Γ, (x:t_x) ⊢     e : t_2 }
      { Γ          ⊢ λx. e : t_1 }
    $
    &
    $
      t_1 = t_x → t_2
    $
    \\
    \multicolumn{4}{c}{} \\
    \raggedleft
    $
    \irule{App}
      { Γ ⊢ e_1 : t_1
     \\ Γ ⊢ e_2 : t_2
      }
      { Γ ⊢ e_1~e_2 : t_3 }
    $
    &
    $
      t_1 = t_2 → t_3
    $
    &
    \raggedleft
    $
    \irule{Proj-G}
      { Γ ⊢ e : t_2 }
      { Γ ⊢ \termFst{e} : t_1 }
    $
    &
    $
      t_2 = t_1 × ?
    $
    \\
    \multicolumn{4}{c}{} \\
    \raggedleft
    $
    \irule{Proj-D}
      { Γ ⊢ e : t_2 }
      { Γ ⊢ \termSnd{e} : t_1 }
    $
    &
    $
      t_2 = ? × t_1
    $
    &
    \raggedleft
    $
    \irule{Tup}
       { Γ⊢e_1:t_1
      \\ Γ⊢e_2:t_2
      }{
        Γ⊢(e_1,e_2):t_3
      }
    $
    &
    $
    t_3 = t_1 \times t_2
    $
  \end{tabular}
\caption{Contraintes crées par les applications de règles}
\label{fig:stlc-const}
\end{figure} %}}}

\begin{figure}
\centering

\subbottom[Contraintes]{
  \label{fig:inf-constr-ex}
  \begin{minipage}{0.5\linewidth}
  \begin{align}
  t_1    &= t_x → t_2             \tag{Abs1} \\
  t_2    &= t_y → t_3             \tag{Abs2} \\
  t_5    &= t_4 → t_3             \tag{App1} \\
  t_4    &= t_y                   \tag{Var1} \\
  t_6    &= t_7 → t_5             \tag{App2} \\
  t_6    &= \tInt → \tInt → \tInt \tag{Var2} \\
  t_{10} &= t_8 → t_7             \tag{App3} \\
  t_9    &= ? × t_8               \tag{Proj-D1} \\
  t_9    &= t_x                   \tag{Var3} \\
  t_{11} &= t_{12} → t_{10}       \tag{App4} \\
  t_{11} &= \tInt → \tInt → \tInt \tag{Var4} \\
  t_{13} &= t_{12} × ?            \tag{Proj-G1} \\
  t_{13} &= t_x                   \tag{Var5}
  \end{align}
  \end{minipage}
}
\subbottom[Solution]{
  \label{fig:inf-sol-ex}
  \begin{minipage}{0.3\linewidth}
  \begin{align*}
  t_{1}  &= \tInt × \tInt → \tInt \\
  t_{2}  &= \tInt → \tInt         \\
  t_{3}  &= \tInt                 \\
  t_{4}  &= \tInt                 \\
  t_{5}  &= \tInt → \tInt         \\
  t_{6}  &= \tInt → \tInt → \tInt \\
  t_{7}  &= \tInt                 \\
  t_{8}  &= \tInt                 \\
  t_{9}  &= \tInt × \tInt         \\
  t_{10} &= \tInt → \tInt         \\
  t_{11} &= \tInt → \tInt → \tInt \\
  t_{12} &= \tInt                 \\
  t_{13} &= \tInt × \tInt         \\
  t_{x}  &= \tInt × \tInt         \\
  t_{y}  &= \tInt
  \end{align*}
  \end{minipage}
}

\caption{Contraintes d'égalité et solution obtenues à partir de la
figure~\ref{fig:inftree-rules}}

\end{figure}

% TODO mal numéroté

On en déduit donc un ensemble de contraintes d'égalité
(figure~\ref{fig:inf-constr-ex}). La prochaine étape est de résoudre ce système.
D'après (App1) et (App2), $t_6 = t_7 → t_4 → t_3$ d'où par (Var2), $t_7 → t_4 →
t_3 = \tInt → \tInt → \tInt$. Le constructeur $→$ étant injectif, on a donc $t_3
= t_4 = t_7 = \tInt$. En procédant de même avec (App3) et (App4), on obtient
$t_8 = t_{12} = \tInt$. D'après (Proj-G1), (Var5), (Var3), et (Proj-D1) on a
$t_{12} × ? = t_{13} = t_{x} = t_9 = ? × t_{8}$, donc $t_x = t_{12} × t_8 =
\tInt × \tInt$. En remplaçant, on obtient tous les autres types
(figures~\ref{fig:inf-sol-ex}) et donc un arbre de typage complet
(figure~\ref{fig:inftree-full}).

\begin{figure} % {{{ Fig full tree
\def\disptypeR#1#2{:#2}

\input{fig/inftree.tex}

\caption{Arbre d'inférence complet}
\label{fig:inftree-full}
\end{figure} % }}}


Pour effectuer une résolution de manière automatique, il faut une technique
d'unification. La manière la plus classique de procéder est due à
Robinson~\cite{robinson} et se déroule par substitution.


\clearpage

Pour résoudre ces contraintes, on commence par les simplifier : si $t_a
\rightarrow t_b = t_c \rightarrow t_d$, alors $t_a = t_c$ et $t_b = t_d$. De
même si $t_a \times t_b = t_c \times t_d$. Au contraire, si $t_a \rightarrow t_b
= t_c \times t_d$, il est impossible d'unifier les types et il faut abandonner
l'inférence de types. D'autre cas sont impossibles, par exemple $\tInt = t_1
\rightarrow t_2$ ou $\tInt = \tFloat$.

Une fois ces simplifications réalisées, les contraintes restantes sont d'une des
formes suivantes :

\begin{itemize}
\item
  $t_i = t_i$. Il n'y a rien à faire, cette contrainte peut être supprimée.
\item
  $t_i = t_j$ avec $i \ne j$ : toutes les occurrences de $t_j$ dans les autres
  contraintes peuvent être remplacées par $t_i$.
\item
  $t_i = x$ (ou $x = t_i$) où $x$ est un type concret : idem.
\end{itemize}

%TODO C'est faux

\clearpage

\begin{figure} % fig:unifpartage {{{

  \subbottom{
  \label{fig:unifpartage:a}
  \begin{tikzpicture}
  \node               (var) {Var};
  \node[right of=var] (ref) {ref};
  \node[right of=ref, node distance=1.7cm] (u0) {Unknown 0};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (var);
  \draw[->] (var) -- (ref);
  \draw[->] (ref) -- (u0);
  \end{tikzpicture}
  }
  \subbottom{
  \label{fig:unifpartage:b}
  \begin{tikzpicture}
  \node               (var) {Var};
  \node[right of=var] (ref) {ref};
  \node[right of=ref, node distance=1.7cm] (u0) {Instanciated};
  \node[right of=u0, node distance=1.7cm] (ii) {Int};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (var);
  \draw[->] (var) -- (ref);
  \draw[->] (ref) -- (u0);
  \draw[->] (u0) -- (ii);
  \end{tikzpicture}
  }
  \subbottom{
  \label{fig:unifpartage:c}
  \begin{tikzpicture}
  \node               (var) {Int};
  \node[below of=var] (ptr) {Ptr};
  \node[left of=var]  (x) {x :};
  \node[left of=ptr] (p) {p :};
  \node[right of=ptr] (pi) {Int};
  \draw[->] (x) -- (var);
  \draw[->] (p) -- (ptr);
  \draw[->] (ptr) -- (pi);
  \end{tikzpicture}
  }

  \caption{Unification par partage}
  \label{fig:unifpartage}

\end{figure} % }}}

Plutôt que de modifier toutes les occurrences d'un type $t_i$, on va affecter à
$t_i$ la valeur du nouveau type.

L'implémentation de cet algorithme utilise le partage et les références
(figure~\ref{fig:unifpartage}).

D'abord \ref{fig:unifpartage:a}, ensuite \ref{fig:unifpartage:b}, et enfin
\ref{fig:unifpartage:c}.

\begin{figure} % fig:exunif:c {{{

  \insertcode{ex-unif-c.c}

  \caption{Compilation d'un programme C -- avant}
  \label{fig:exunif:c}
\end{figure} % }}}

Prenons l'exemple de la figure~\ref{fig:exunif:c} et typons-le "à la main". On
commence par oublier toutes les étiquettes de type présentes dans le programme.
Celui-ci devient alors :

\insertcode{exunif-code.c}

La premiere ligne introduit deux variables. On peut noter leurs types respectifs
(inconnus pour le moment) $t_1$ et $t_2$. La première affectation \texttt{p =
\&x} implique que les deux côtés du signe "=" ont le même type. À gauche, le
type est $t_2$, et à droite $Ptr(t_1)$. On applique le même raisonnement à la
seconde affectation : à gauche, le type est $t_1$ et à droite Int. On en déduit
que le type de x est Int et celui de p est Ptr(Int).


\insertcode{lambda-types.ml}

Pour implanter cet algorithme, on représente les types de données du programmes
à typer par une valeur de type \texttt{ml\_type}. En plus des constantes de
types comme int ou float, et des constructeurs de type comme pair et fun, le
constructeur Var permet d'exprimer les variables de types (inconnues ou non).

Celles-ci sont numérotées par un int, on suppose avoir à disposition deux
fonctions manipulant un compteur global d'inconnues.

\insertcode{exunif-counter.ml}

De plus, on a un module gérant les environnements de typage. Il pourra être
implanté avec des listes d'association ou des tables de hachage, par exemple. Sa
signature est :

\insertcode{exunif-env.ml}

Reprenons l'exemple précédent. Partant d'un environnement vide (Env.empty), on
commence par l'étendre de deux variables. Comme on n'a aucune information, il
fait allouer des nouveaux noms d'inconnues (qui correspondent à $t_1$ et $t_2$):

\insertcode{exunif-1.ml}

La première instruction indique que les deux côtés de l'affectation doivent
avoir le même type.

\insertcode{exunif-2.ml}

\begin{figure}
  \centering
  \begin{tikzpicture}
    [scale=2.3]

    \node at (0,  0) (n0a) {t1:};
    \node at (0, -1) (n0b) {t2:};

    \node at (1,  0) (n1a) {Var\_type};
    \node at (2,  0) (n2a) {ref};
    \node at (3,  0) (n3a) {Unknown 0};

    \node at (1, -1) (n1b) {Var\_type};
    \node at (2, -1) (n2b) {ref};
    \node at (3, -1) (n3b) {Instanciated};
    \node at (4, -1) (n4b) {Ptr};

    \draw [->] (n1a) -- (n2a);
    \draw [->] (n2a) -- (n3a);

    \draw [->] (n1b) -- (n2b);
    \draw [->] (n2b) -- (n3b);
    \draw [->] (n3b) -- (n4b);

    \draw [->] (n4b) -- ++ (0, 0.5) -| (n1a);

  \end{tikzpicture}
  \caption{Unification : partage}
  \label{fig:unifsharing}
\end{figure}

Ici il se passe plusieurs choses intéréssantes. D'une part nous faisont appel à
une fonction externe typeof qui retourne le type d'une expression sous un
environnement (dans une implantation complète il s'agirait d'un appel récursif).
Dans ce cas, \texttt{typeof lhs1 env} est identique à \texttt{Env.get lhs1 env}
et \texttt{typeof rhs1 env} à \texttt{Ptr\_type t1}. L'autre aspect intéressant
est la dernière ligne : la fonction \texttt{unify} va modifier en place les
représentations des types afin de les rendre égales. L'implantation de
\texttt{unify} sera décrite plus tard. Dans ce cas précis, elle va faire pointer
la référence dans t2 vers t1 (figure~\ref{fig:unifsharing}).

Enfin, la seconde affectation se déroule à peu près de la même manière.

\insertcode{exunif-3.ml}

Ici \texttt{typeof lhs2 env} est identique à \texttt{Ptr\_type (Env.get "p"
env)} et \texttt{typeof lhs2 env} à \texttt{Const\_type Int\_type}. Et dans cas,
l'unification doit se faire entre t1 et \texttt{Const\_type Int\_type} : cela
mute la référence derrière t1 (figure~\ref{fig:typeunifref}).

\begin{figure}
  \begin{tikzpicture}
    [scale=2.3]

    \node at (0,  0) (n0a) {t1:};
    \node at (0, -1) (n0b) {t2:};

    \node at (1,  0) (n1a) {Var\_type};
    \node at (2,  0) (n2a) {ref};
    \node at (3,  0) (n3a) {Instanciated};
    \node at (4,  0) (n4a) {Const\_type};
    \node at (5,  0) (n5a) {Int\_type};

    \node at (1, -1) (n1b) {Var\_type};
    \node at (2, -1) (n2b) {ref};
    \node at (3, -1) (n3b) {Instanciated};
    \node at (4, -1) (n4b) {Ptr};

    \draw [->] (n1a) -- (n2a);
    \draw [->] (n2a) -- (n3a);
    \draw [->] (n3a) -- (n4a);
    \draw [->] (n4a) -- (n5a);

    \draw [->] (n1b) -- (n2b);
    \draw [->] (n2b) -- (n3b);
    \draw [->] (n3b) -- (n4b);

    \draw [->] (n4b) -- ++ (0, 0.5) -| (n1a);

  \end{tikzpicture}
  \caption{Unification par mutation de références}
  \label{fig:typeunifref}
\end{figure}

L'essence de l'algorithme d'inférence se situe donc dans 2 fonctions. D'une
part, \texttt{unify} qui réalise l'unification des types grâce à au partage des
références. D'autre part, la \texttt{typeof} qui encode les règles de typage
elles-mêmes et les applique à l'aide de \texttt{unify}.

\subsection{Algorithme d'unification}

Voici une implantation de la fonction \texttt{unify}.

Celle-ci prend en entrée deux types $t_1$ et $t_2$. À l'issue de l'exécution de
\texttt{unify}, ces deux types doivent pouvoir être considérés comme égaux. Si
ce n'est pas possible, une erreur sera levée.

La première étape est de réduire ces deux types, c'est à dire à transformer les
constructions \texttt{Var (ref (Instanciated t))} en \texttt{t}.

Ensuite, cela dépend des formes qu'ont les types réduits :

\begin{figure}
  \centering
  \begin{tikzpicture}
    [every node/.style={node distance=2cm}
    ,>=latex
    ]

    \node (n1) {Ptr};
    \node[right of=n1] (n2) {Var};
    \node[right of=n2] (n3) {ref};
    \node[right of=n3] (n4) {Instanciated};

    \draw [->] (n1) -- (n2);
    \draw [->] (n2) -- (n3);
    \draw [->] (n3) -- (n4);

    \draw [->] (n4) -- ++ (0, -1cm) -| (n1);

  \end{tikzpicture}
  \caption{Cycle dans le graphe de types}
  \label{fig:typecycle}
\end{figure}

\begin{itemize}

\item si les deux types sont inconnus (de la forme \texttt{Var (ref
(Instanciated t))}), on fait pointer l'une des deux références vers le premier
type. Notons que cela crée un type de la forme \texttt{Var (ref (Instanciated
(Var (ref (Unknown n)))))} qui sera réduit lors d'une prochaine étape
d'unification.

\item si un type est inconnu et pas l'autre, il faut de la même manière affecter la
référence. Mais en faisant ça inconditionnellement, cela peut poser problème :
par exemple en tentant d'unifier \texttt{a} avec \texttt{Ptr(a)} on pourrait
créer un cycle dans le graphe (figure~\ref{fig:typecycle}).
Pour éviter cette situation, il suffit de s'assurer que le type inconnu n'est
pas présent dans le type à affecter.

\item si les deux types sont des types de base (comme \tInt ou \tFloat) égaux,
on ne fait rien.

\item si les deux types sont des constructeurs de type, il faut que les
constructeurs soient égaux. On unifie en outre leurs arguments deux à deux.

\item dans les autres cas, l'algorithme échoue.

\item TODO sous typage pour les structures

\end{itemize}

TODO :

\begin{itemize}
\item implem du polymorphisme
\item implem du sous-typage
\item généralisation depuis le toy language
\end{itemize}

\clearpage

\begin{figure} % fig:exunif:tpk {{{

  \insertcode{ex-unif-tpk.ml}

  \caption{Compilation d'un programme C -- après}
  \label{fig:exunif:tpk}
\end{figure} % }}}

Le programme C (figure~\ref{fig:exunif:c}) est compilé ainsi en Tyspeak
(figure~\ref{fig:exunif:tpk}).

\clearpage

\section{Architecture de \ptrtype}
\label{sec:ptrtype-archi}

L'outil \ptrtype lit un programme Newspeak (ou un fichier C), et réalise
l'inférence de qualificateurs. En sortie, il affiche soit le programme
complètement annoté, soit une erreur. Le cœur de l'outil est dans la

Si l'argument à \ptrtype est un fichier C, il est tout d'abord compilé vers
Newspeak grâce à l'utilitaire \texttt{c2newspeak}. Ensuite, les autres passes
travaillent sur une représentation intermédiaire proche de Newspeak, mais où des
étiquettes de type supplémentaires sont ajoutées. Ce type de représentation
intermédiaire (polymorphe en le type des étiquettes) est \texttt{'a Tyspeak.t}.

\begin{figure}
\insertcode{implem-process.ml}
\caption{Implantation -- fonction principale de \ptrtype}
\label{fig:implem-process}
\end{figure}

Le reste de l'outil est résumé dans la fonction
\texttt{process\_npk} (figure~\ref{fig:implem-process}) :

\begin{itemize}

\item Grâce à la fonction \texttt{convert_unit : Newspeak.t -> unit Tyspeak.t},
  on ajoute des étiquettes ``vides'' (toutes égales à \texttt{() : unit}).

\item L'ensemble des fonctions du programme est trié topologiquement selon la
  relation~$\preceq$ définie par $f \preceq g \eqdef \textrm{``} g
  \textrm{ apparaît dans la définition de } f \textrm{''}$. Cela est fait en
  construisant une représentation de $\preceq$ sous forme de graphe, puis en
  faisant un parcours en largeur de celui-ci.

\item Les annotations extérieures sont alors lues (variable \texttt{exttbl}), ce
  qui permet de créer un environnement initial.

\item Les types de chaque fonction sont inférés, par le biais de la fonction
  suivante :

\begin{Verbatim}
val infer : Newspeak.fid list
         -> Types.simple Env.t
         -> 'a Tyspeak.t
         -> Types.simple Tyspeak.t
\end{Verbatim}

\item Ces types sont vérifiés. Cette étape est normalement redondante et est
  donc optionnelle (l'option \texttt{-{}-no-check} permet de la désactiver).

\item Le programme obtenu, de type \texttt{Types.simple Tyspeak.t}, est affiché
  sur le terminal.

\end{itemize}

\section{Inférence de types}

L'inférence de types consiste à remplacer les étiquettes de type \texttt{unit}
par des étiquettes de type \texttt{simple} (autrement dit de vraies
représentations de types).

Cette étape se fait de manière impérative : on peut créer de nouveaux types avec
\texttt{new\_unknown} et unifier deux types
avec \texttt{unify}. Leurs types sont :

\begin{verbatim}
val new_unknown : unit -> Types.simple
val unify : Types.simple -> Types.simple -> unit
\end{verbatim}

La fonction \texttt{infer} s'appuie sur un ensemble de fonctions récursivement
définies portant sur chaque type de fragment : \texttt{infer\_fdec} pour les
déclarations de fonction, \texttt{infer\_exp} pour les expressions,
\texttt{infer\_stmtkind} pour les instructions, etc.

\begin{figure}

% TODO expliquer pourquoi il y a plusieurs left-values, et toutes les
% différences avec safespeak ainsi que décrit dans les chapitres précédents

\insertcode{infer-unif-stmt.ml}

\caption{Implantation -- inférence des déclarations de variable et appels de
         fonction}

% TODO ces "Implantation -- " sont ils vraiment indispensables ?
\label{fig:implem-unif-stmt}
\end{figure}

% TODO s/lval_type/infer_lval/ ?

Les règles de typage sont implantées par \texttt{new\_unknown} et
\texttt{unify}. Par exemple, pour typer une déclaration
(figure~\ref{fig:implem-unif-stmt}), on crée un nouveau
type \texttt{t0}. On étend l'environnement courant avec cette nouvelle
association et sous ce nouvel environnement, on type le bloc de portée de la
déclaration.

De même, pour typer un appel de fonction, on infère le type de ses arguments et
left-values de retour. On obtient également le type de la fonction (à partir du
type de la fonction présent dans l'environnement, ou du type du pointeur de
fonction qui est déréférencé), et on unifie ces deux informations.

On peut donner quelques exemples, comme :

\begin{itemize}
  \item addition de deux flottant (dans \texttt{infer\_binop}) :

\begin{verbatim}
let infer_binop op (_, a) (_, b) =
  match op with
    (* [...] *)
    | N.PlusF _ ->
        unify a Float;
        unify b Float;
        Float
\end{verbatim}

  \item adresse d'une left-value (dans \texttt{lval\_type}) :

\begin{verbatim}
| T.AddrOf lv ->
    let lv' = infer_lv env lv in
    let ty = lval_type env lv in
    (T.AddrOf lv', Ptr (Kernel, ty))
\end{verbatim}

  \item déréférencement d'une left-value (dans \texttt{lval\_type}) :

\begin{verbatim}
| T.Deref(e, _sz) ->
    let (_, te) = infer_exp env e in
    let t = new_unknown () in
    unify (Ptr (Kernel, t)) te;
    t
\end{verbatim}

\end{itemize}

\section{Vérification de types}

La passe de vérification de types, optionnelle et en théorie redondante, est
présente pour s'assurer que les types inférés ne sont pas aberrants.

Là encore, on travaille par effet de bord : si tout ne se passe pas bien, on
lève une erreur. La fonction principale a le type suivant :

\begin{verbatim}
val check : Types.simple Env.t -> Types.simple Tyspeak.t -> unit
\end{verbatim}

% TODO

\section{Unification}

\begin{figure}
\insertcode{implem-types.ml}
\caption{Implantation -- types}
\label{fig:implem-typ}
\end{figure}

Les types de données utilisés sont donnés dans la figure~\ref{fig:implem-typ}.
Les types \langname sont représentés soit par un constructeur de type ``résolu''
immutable comme \texttt{Int}, soit par une référence dans le cas d'une variable
inconnue (placée alors derrière le constructeur \texttt{Var}).

Ces références contiennent une valeur du type
\texttt{simple var\_type}\footnote{
  Ce type est polymorphe pour pouvoir être repris dans l'unification des
  qualificateurs (figure~\ref{fig:implem-qualifs}).
}, c'est à
dire :

\begin{itemize}
\item soit un numéro d'inconnue (constructeur \texttt{Unknown})\footnote{On
  place le numéro dans un enregistrement pour abstraire l'entier sous-jacent, en
  empêchant par exemple de faire de l'arithmétique sur celui-ci.}.

\item soit un type résolu (constructeur \texttt{Instanciated}) si cette
  inconnue a été unifiée avec un type concret.
\end{itemize}

Ce système peut créer des représentations de types arbitrairement longues, comme
par exemple :

\texttt{Var (ref (Instanciated (Var (ref (Instanciated Int)))))}

Cela est dû au fait que \texttt{fun x -> Var (ref (Instanciated x))} est typée
\texttt{simple -> simple} et peut donc être appliquée à loisir. Pour éviter cet
effet d'allongement, on définit une fonction \texttt{shorten} qui supprime ces
chaînes (figure~\ref{fig:implem-shorten}).

% TODO décrire la première branche du pattern matching

\begin{figure}

  \insertcode{implem-shorten.ml}

\caption{Implantation -- fonction de racourcissement des représentations de types}
\label{fig:implem-shorten}
\end{figure}

La fonction d'unification, quant à elle, commence par raccourcir ses deux
arguments puis faire une analyse de cas par filtrage.

Les cas principaux pour unifier deux types réduits \texttt{sta} et \texttt{stb}
sont :

\begin{itemize}

\item \texttt{sta} et \texttt{stb} sont deux inconnues. Alors on modifie l'un
  pour pointer sur l'autre. Les références étant uniques et partagées, cela
  revient à substituer l'un par l'autre dans toutes les représentations de
  types.

\item Un type est concret, l'autre une inconnue. Dans ce cas on modifie le
  second comme étant un \texttt{Instanciated} du premier. Il faut vérifier que
  le type inconnu remplacé n'apparaît pas dans le type concret, sinon on créé un
  cycle. Ce cas a lieu par exemple quand on cherche à unifier $a$ avec
  $a~\qKernel~*$. Il faut alors signaler une erreur, ce que fait la fonction
  \texttt{occurs\_check\_failed}.

\item Les deux types sont des types concrets. Alors ils sont de la forme
  respective
  $C (t_1, …, t_n)$
  et
  $D (u_1, …, u_m)$ où $C$ et $D$ sont des constructeurs de type avec
  respectivement $n$ et $m$ arguments
  \footnote{
    Le cas $n = 0$ ou $m = 0$ correspond aux types concrets comme $\tInt$ ou
    $\tFloat$.
  }. Si $C = D$ et
  $n = m$, alors on unifie récursivementchaque $t_i$ avec $u_i$. Sinon on lève une erreur
  (fonction \texttt{type\_clash}).

  % TODO structures

\end{itemize}

Cette analyse de cas est implantée dans la fonction \texttt{unify_now}
(figure~\ref{fig:implem-unify-now}).

\begin{figure}
  \insertcode{implem-unify.ml}
\caption{Implantation -- fonction d'unification}
\label{fig:implem-unify-now}
\end{figure}

cas structure (figure~\ref{fig:implem-unify-structs}).

\begin{figure}
  \insertcode{implem-structs.ml}
\caption{Implantation -- structures}
\label{fig:implem-unify-structs}
\end{figure}

Pour les pointeurs, il est nécessaire de définir des fonctions similaires sur
les qualificateurs (figure~\ref{fig:implem-qualifs}).

\begin{figure}

  \insertcode{implem-qualifs.ml}

  \caption{Implantation -- qualificateurs}
\label{fig:implem-qualifs}

\end{figure}

\begin{figure}

\insertcode{unify-main.ml}

\caption{Implantation -- unification directe ou retardée}
\label{fig:implem-lazy}
\end{figure}

La fonction appellée directement par le reste du code, appellée \texttt{unify},
peut retarder l'unification (figure~\ref{fig:implem-lazy}). Dans ce cas, la
paire de types à unifier est mise dans une liste d'attente qui sera unifiée
après le parcours du programme. Le but est d'instrumenter l'inférence de types
afin de pouvoir en faire une exécution ``pas à pas''.

\section{Exemple}

Lançons l'analyse sur un petit exemple :

\begin{verbatim}
int f(int *x) { return (*x + 1); }
\end{verbatim}

L'exécution de notre analyseur affiche un programme complètement annoté :

\begin{verbatim}
 % ptrtype example.c
f : (Ptr (Int)) -> (Int)
Int (example.c:1#4)^f(Ptr (Int) x) {
  (.c:3#4)^!return =(int32)
    (coerce[-2147483648,2147483647]
      ( ( ([(x_Ptr (Int) : Ptr (Int))]32_Int
            : Int
          )
          + (1 : Int)
        ) : Int
      ) : Int
    );
}
\end{verbatim}

L'opérateur \texttt{coerce[a,b]} est un artefact de Newspeak, destiné à détecter
les débordements d'entiers lors d'une analyse de valeurs par interprétation
abstraite. Dans le cas de notre analyse, les valeurs ne sont pas pertinentes et
cet opérateur peut être vu que comme un ``plus'' unaire typé $(\tInt) → \tInt$.

\emph{A contrario}, lorsqu'il n'est pas possible d'inférer des types
compatibles, l'analyseur s'arrête avec une erreur.

\begin{verbatim}
void f(int *p) {
    /*!npk userptr p */
    *p = 3;
}
\end{verbatim}

Le commentaire \texttt{/*!npk userptr p */} est interpréter par l'analyseur et
le fait unifier le type de \texttt{p} avec $t~\qUser~*$, c'est à dire qu'il
force son qualificateur à être \qUser.

\begin{verbatim}
04-addrof.c:4#4 - Cannot unify qualifiers:
  Kernel
  User
\end{verbatim}

On signale l'emplacement où la dernière unification a échoué.

\section*{Extrait PLAS}

The language described above, as well as a type inference algorithm, have been
implemented in OCaml as part of the Newspeak framework of program
analysis\cite{newspeak}. It is released under the GNU Lesser General Public
License, and is available on \texttt{http://penjili.org} (directory
\texttt{src/ptrtype} in the distribution). Our implementation consists of the
following steps.

but to analyze larger parts of the kernel, it may be
necessary to define a ``maximal'' configuration file (which is impossible
because of incompatibilities between some options).


% vim: spelllang=fr
