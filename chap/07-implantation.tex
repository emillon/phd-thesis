Dans ce chapitre, nous décrivons la mise en œuvre des analyses statiques
précédentes. Nous commençons par décrire la représentation intermédiaire
utilisée: \newspeak. Ensuite, nous décrivons la phase de compilation, de C à
\newspeak, auquel on rajoute ensuite des étiquettes de types. Celles-ci sont
calculées par un algorithme d'inférence de types à la Hindley-Milner, reposant
sur l'unification et le partage de références. Toutes ces étapes sont implantées
dans le langage OCaml~\link{ocaml}.

Le prototype décrit ici est disponible sur \url{http://penjili.org} sous une
license libre, la \emph{GNU Lesser General Public License}.

\section{Newspeak}
\label{sec:npk}

Newspeak est un langage intermédiaire conçu pour être un bon support d'analyses
statiques, contrairement à des langages conçus pour les programmeurs comme C.
Plusieurs points en font un langage pratique à utiliser. Tout d'abord, il est
suffisamment expressif pour compiler tout C, y compris de nombreuses extensions
GNU utilisées dans le noyau Linux (section~\label{sec:gnuc}), et des traducteurs
automatiques depuis C et Ada existent (section~\label{sec:compil}).

Ensuite, ses instructions sont orthogonales et minimales: il existe en général
une seule manière de faire les choses. Par exemple, le flot de contrôle est
restreint à la boucle infinie et au saut en avant («\emph{break}» généralisé).

Enfin, lorsque certaines constructions sont ambigües, un choix est fait. Par
exemple, l'évaluation des arguments d'une fonction est faite de manière
explicite, les tailles des types sont indiqués à chaque déclaration de variable,
etc. Sa sémantique d'exécution (ainsi qu'une partie des étapes de compilation
depuis C) est décrites dans \cite{newspeak}. Sa syntaxe est donnée dans la
figure~\ref{fig:stx-npk}.

\begin{figure}%{{{

\def\npkstyle#1{\mathrm{#1}}

\begin{align*}
\gramdef{Instruction}{s}
    {\npkstyle{Set} (lv, e, st}{Affectation}
    {\npkstyle{Copy} (lv, lv, n)}{Copie}
    {\npkstyle{Guard} (e)}{Garde}
    {\npkstyle{Decl} (var, t, blk)}{Déclaration}
    {\npkstyle{Select} (blk, blk)}{Branchement}
    {\npkstyle{InfLoop} (blk)}{Boucle infinie}
    {\npkstyle{DoWith} (blk, x)}{Nommage de bloc}
    {\npkstyle{Goto} (x)}{Saut}
    {\npkstyle{Call} ([(e_i, t_i)], f, [(lv_i, t_i)])}
            {Appel de fonction}
    {END}
\\ \\
\gramdef{Bloc}{blk}
    {[i_i]}{Liste d'instructions}
    {END}
\\ \\
\gramdef{Left-value}{lv}
    {\npkstyle{Local} (x)}{Locale}
    {\npkstyle{Global} (x)}{Globale}
    {\npkstyle{Deref} (e, n)}{Déréférencement}
    {\npkstyle{Shift} (lv, e)}{Décalage}
    {END}
\\ \\
\gramdef{Expression}{e}
    { \npkstyle{CInt} (n) }{Entier}
    { \npkstyle{CFloat} (d)}{Flottant}
    { \npkstyle{Nil} }{ Pointeur nul }
    { \npkstyle{Lval} (lv, t)}{Accès mémoire}
    { \npkstyle{AddrOf} (lv) }{Adresse de variable}
    { \npkstyle{AddrOfFun} (x, [t_i], [t_i])}{Adresse de fonction}
    { \npkstyle{UnOp} (unop, e) }{Opérateur unaire}
    { \npkstyle{BinOp} (binop, e_1, e_2) }{Opérateur binaire}
    {END}
\\ \\
\gramdef{Fonction}{f}
    { \npkstyle{FunId} (x)}{Appel par nom}
    { \npkstyle{FunDeref} (e)}{Appel par pointeur}
    {END}
\\ \\
\gramdef{Type}{t}
    { \npkstyle{Scalar} (st) }{Type scalaire}
    { \npkstyle{Array} (t, n)}{Tableau}
    { \npkstyle{Region} ([(n_i, t_i)], n')}{Structure/union}
    {END}
\\ \\
\gramdef{Type scalaire}{st}
    { \npkstyle{Int} (n) }{Entier}
    { \npkstyle{Float} (n) }{Flottant}
    { \npkstyle{Ptr} }{ Pointeur sur données}
    { \npkstyle{FunPtr}}{ Pointeur sur fonction}
    {END}
\end{align*}
\caption{Syntaxe simplifiée de Newspeak}
\label{fig:stx-npk}
\end{figure}%}}}

\section{Chaîne de compilation}
\label{sec:compil}

\begin{figure}
  \centering
  \input{fig/compil-pipeline.tex}
  \caption{Compilation depuis Newspeak}
\label{fig:compil-npk}
\end{figure}

La compilation vers C est faite en trois étapes (figure~\ref{fig:compil-npk}):
prétraitement du code source, compilation de C prétraité vers \newspeak{}, puis
compilation de \newspeak{} vers ce langage.

La première étape consiste à prétraiter les fichiers C source avec le logiciel
\texttt{cpp}, comme pour une compilation normale. Cette étape interprète les
directives comme \texttt{\#include}, \texttt{\#ifdef}, À cet étape, les
commentaires sont aussi supprimés.

Une fois cette passe effectuée, le résultats est un ensemble de fichiers C
prétraités, c'est-à-dire des unités de compilation.

Puisque la directive \texttt{\#include} est textuelle, ces fichiers sont très
grands et donnent lieu à beaucoup de duplication dans les passes suivantes.

Sur cette représentation (du C prétraité), il est possible d'ajouter des
annotations de la forme \texttt{/*!npk [...] */} qui pourront être accessible
dans l'arbre de syntaxe abstrait des passes suivantes.

À ce niveau, les fichiers sont passés à l'outil \texttt{c2newspeak} qui les
traduit vers Newspeak. Comme il sera décrit dans la section~\ref{sec:gnuc}, la
plupart des extensions GNU C sont acceptés en plus du C ANSI. Dans cette étape,
les types et les noms sont résolus, et le programme est annoté de manière à
rendre les prochaines étapes indépendante du contexte. Par exemple, chaque
déclaration de variable est adjointe d'une description complète du type.

Lors de cette étape, le flôt de contrôle est également simplifié. C en effet
propose de nombreuses constructions ambigües ou redondantes.

Au contraire, Newspeak propose un nombre réduit de constructions. Rappelons que
le but de ce langage est de faciliter l'analyse statique: des constructions
orthogonales permettent donc d'éviter la duplication de règles sémantique, ou de
code lors de l'implantation d'un analyseur.

Par exemple, plutôt que de fournir une boucle \emph{while}, une boucle
\emph{do/while} et une boucle for, Newspeak fournit une unique boucle
\npkWhile{}. La sortie de boucle est compilée vers un \npkGoto{}\cite{goto}, qui
est toujours un saut vers l'avant (similaire à un «\emph{break}» généralisé).

Newspeak est conçu pour l'analyse statique par interprétation abstraite. Il a
donc une vue de bas niveau sur les programmes. Par exemple, aucune distinction
n'est faite entre l'accès à un champ et l'accès à un l'élément d'un tableau
(tous deux sont traduits par un décalage numérique depuis le début de la zone
mémoire). Pour supprimer cette ambiguïté, il faut s'interfacer dans les
structures internes de \texttt{c2newspeak}, où les informations nécessaires sont
encore présentes.

Ensuite, les différents fichiers sont liés ensemble. Cette étape consiste
principalement à s'assurer que les hypothèses faites par les différentes unités
de compilation sont cohérentes entre elles. Les objets marqués \texttt{static},
invisibles à l'extérieur de leur unité de compilation, sont renommés afin qu'ils
aient un nom unique.

Enfin, l'implantation d'un algorithme d'inférence pour les systèmes de types
décrits dans les chapitres~\ref{cha:typbase} et~\ref{cha:qualifs} est assez
simple. Puisqu'ils sont suffisament proches du lambda calcul simplement typé, on
peut utiliser une variante de l'algorithme W de Damas et
Milner~\cite{DamasMilner}.

Cela repose sur l'unification: on dispose d'une fonction permettant de créer des
inconnues de type, et d'une fonction pour unifier deux types partiellement
inconnus. Cet algorithme sera décrit dans la section~\ref{sec:unif}. En
pratique, on utilise l'optimisation classique qui consiste à se
reposer sur le partage de références pour réaliser l'unification, plutôt que de
faire des substitutions explicites. Puisque ces systèmes de types sont
monomorphes, on présente une erreur si des variable de type libres sont
présentes.

À la fin de cette étape, on obtient soit un programme complètement annoté, soit
une erreur de type.

\section{Algorithme d'unification}
\label{sec:unif}

On présente ici la fonction \texttt{unify}. Celle-ci prend en entrée deux
représentations de types pouvant contenir des inconnues de la forme \texttt{Var
n}, et retourne une liste de couples $(n, t)$ indiquant les substitutions à
faire.

Cet algorithme (figure~\ref{fig:algo-unif}) prend un chemin différent selon la
forme des deux types d'entrée:

\begin{figure}[h]%{{{
\begin{Verbatim}
unify (ta, tb):
    match (ta, tb) with
        Var na, Var nb ->
            if na == nb then
                Return []
            else
                Return [(na, tb)]

        Var na, tb ->
            if occurs(na, tb) then
                erreur
            else
                Return [(na, tb)]

        ta, Var nb ->
            Return unify(tb, ta)

        Int, Int -> Return []

        Float, Float -> Return []

        Array a, Array b -> Return (unify (a, b))

        Ptr a, Ptr b -> Return (unify (a, b))

        UserPtr a, UserPtr b -> Return (unify (a, b))

        Fun (la, ra), Fun (lb, rb) ->
            r = unify (ra, rb)
            n = length(la)
            if length(lb) != n then
                erreur
            for i = 0 to n-1 do
                r += unify (la[i], lb[i])
            Return r

        _ -> erreur

\end{Verbatim}

\caption{Algorithme d'unification}
\label{fig:algo-unif}
\end{figure}%}}}
% TODO algorithmicx?

\begin{itemize}

\item si les deux types sont inconnus (de la forme \texttt{Var n}), on substitue
l'un par l'autre.

\item si un type est inconnu et pas l'autre, il faut de la même manière faire
une substitution.
Mais en faisant ça inconditionnellement, cela peut poser problème:
par exemple en tentant d'unifier \texttt{a} avec \verb!Ptr(a)! on pourrait
créer une substitution cyclique.
Pour éviter cette situation, il suffit de s'assurer que le type inconnu n'est
pas présent dans le type à affecter. C'est le but de la fonction
\texttt{occurs(n, t)} qui calcule si \texttt{Var n} apparaît dans \texttt{t}.

\item si les deux types sont des types de base (comme $\tInt$ ou $\tFloat$)
égaux, on ne fait rien.

\item si les deux types sont des constructeurs de type, il faut que les
constructeurs soient égaux. On unifie en outre leurs arguments deux à deux.

\item dans les autres cas, l'algorithme échoue.

\end{itemize}

Le traitement des types structures est géré dans l'implantation d'une manière
différente de la présentation du chapitre~\ref{cha:lang}. C'est pourquoi elle
n'apparaît pas dans la figure~\ref{fig:algo-unif}. Au lieu d'accéder directement
au type complet $S$ à chaque accès $x.l_S$, on n'obtient qu'un nom de champ à
chaque accès. C'est à dire qu'on va par exemple inférer le type $\tStruct{ l:
\tInt ; … }$ où $…$ désigne l'ensemble des champs inconnus. En unifiant
$\tStruct{ a: t_a ; … }$ et $\tStruct{ b: t_b ; … }$ (si $a ≠ b$), on obtient
en sortie que ces deux types sont égaux à $\tStruct{ a: t_a; b: t_b ; … }$.
Plus présisément, pour unifier deux types structure, on étudie les types de
leurs champs. On commence par unifier les types des champs de même nom, et on on
ajoute à l'un les champs exclusifs à l'autre. Cela se rapproche du polymorphisme
de rangée (\emph{row polymorphism}) présent dans les langages comme OCaml.

\section{Architecture de \ptrtype}
\label{sec:ptrtype-archi}

Cette analyse est implantée dans un outil du nom de \ptrtype{}. Il lit un
programme Newspeak (ou un fichier C), et réalise l'inférence de types. En
sortie, il affiche soit le programme complètement annoté, soit une erreur.

Si l'argument passé à \ptrtype{} est un fichier C, il est tout d'abord compilé
vers Newspeak grâce à l'utilitaire \texttt{c2newspeak}. Ensuite, les autres
passes travaillent sur une représentation intermédiaire proche de Newspeak, mais
où des étiquettes de type supplémentaires sont ajoutées. Ce type de
représentation intermédiaire (polymorphe en le type des étiquettes) est
\texttt{'a Tyspeak.t}.

Le reste de l'outil est résumé dans la fonction
\texttt{process\_npk} (figure~\ref{fig:implem-process}):

\begin{figure}
\insertcode{implem-process.ml}
\caption{Fonction principale de \ptrtype{}}
\label{fig:implem-process}
\end{figure}

\begin{itemize}

\item Grâce à la fonction \verb!convert_unit : Newspeak.t -> unit Tyspeak.t!,
  on ajoute des étiquettes «vides» (toutes égales à \verb!() : unit!).

\item L'ensemble des fonctions du programme est trié topologiquement selon la
  relation~$\preceq$ définie par $f \preceq g \eqdef \textrm{«} g
  \textrm{ apparaît dans la définition de } f \textrm{»}$. Cela est fait en
  construisant une représentation de $\preceq$ sous forme de graphe, puis en
  faisant un parcours en largeur de celui-ci. Pour le moment, les fonctions
  récursives et mutellement récursives ne sont pas supportées dans
  l'implantation.

\item Les annotations extérieures sont alors lues (variable \texttt{exttbl}), ce
  qui permet de créer un environnement initial. Celle-ci permettent par exemple
  de forcer le type d'une fonction inconnue.

\item Les types de chaque fonction sont inférés, par le biais de la fonction
  suivante:

\begin{Verbatim}
val infer : Newspeak.fid list
         -> Types.simple Env.t
         -> 'a Tyspeak.t
         -> Types.simple Tyspeak.t
\end{Verbatim}

\item S'il n'y a pas d'erreurs, le programme obtenu, de type
\texttt{Types.simple Tyspeak.t}, est affiché sur le terminal.

\end{itemize}

La fonction appellée dans par le reste du code, appellée \texttt{unify}, peut
retarder l'unification (figure~\ref{fig:implem-lazy}). Dans ce cas, la paire de
types à unifier est mise dans une liste d'attente qui sera unifiée après le
parcours du programme. Le but est d'instrumenter l'inférence de types afin de
pouvoir en faire une exécution «pas à pas».

\begin{figure}

\insertcode{unify-main.ml}

\caption{Unification directe ou retardée}
\label{fig:implem-lazy}
\end{figure}

\section{Inférence de types}

L'inférence de types consiste à remplacer les étiquettes de type \texttt{unit}
par des étiquettes de type \texttt{simple} (autrement dit de vraies
représentations de types).

Cette étape se fait de manière impérative: on peut créer de nouveaux types avec
\texttt{new\_unknown} et unifier deux types
avec \texttt{unify}. Leurs types sont:

\begin{verbatim}
val new_unknown : unit -> Types.simple
val unify : Types.simple -> Types.simple -> unit
\end{verbatim}

La fonction \texttt{infer} s'appuie sur un ensemble de fonctions récursivement
définies portant sur chaque type de fragment: \texttt{infer\_fdec} pour les
déclarations de fonction, \texttt{infer\_exp} pour les expressions,
\texttt{infer\_stmtkind} pour les instructions, etc. Grâce au
lemme~\ref{lemma:inversion}, on sait quelle règle appliquer en fonction de
l'expression ou instruction considérée. Notons que même si le programme
\newspeak est décoré d'informations de types (celles qui existent dans le
programme C), elles ne sont pas utilisées.

Les règles de typage sont implantées par \texttt{new\_unknown} et
\texttt{unify}. Par exemple, pour typer une déclaration
(figure~\ref{fig:implem-unif-stmt}), on crée un nouveau type \texttt{t0}. On
étend l'environnement courant avec cette nouvelle association et sous ce nouvel
environnement, on type le bloc de portée de la déclaration.

\begin{figure}[h] %{{{

\insertcode{infer-unif-stmt.ml}

\caption{Inférence des déclarations de variable et appels de
         fonction}

\label{fig:implem-unif-stmt}
\end{figure}%}}}

De même, pour typer un appel de fonction, on infère le type de ses arguments et
left-values de retour. On obtient également le type de la fonction (à partir du
type de la fonction présent dans l'environnement, ou du type du pointeur de
fonction qui est déréférencé), et on unifie ces deux informations.

On peut donner quelques autres exemples. Pour additionner deux flottants, on
unifie leur type avec \tFloat. Le résultat est également de type \tFloat. Cela
correspond à la règle \textsc{Op-Float}.

\begin{verbatim}
let infer_binop op (_, a) (_, b) =
  match op with
    (* [...] *)
    | N.PlusF _ ->
        unify a Float;
        unify b Float;
        Float
\end{verbatim}

Pour prendre l'adresse d'une variable, la règle \textsc{AddrOf-Kernel}
s'applique: on prend le type de la left-value et on construit un pointeur noyau
à partir de lui:

\begin{verbatim}
| T.AddrOf lv ->
    let lv' = infer_lv env lv in
    let ty = lval_type env lv in
    (T.AddrOf lv', Ptr (Kernel, ty))
\end{verbatim}

Enfin, pour déréférencer une expression, on unifie tout d'abord son type avec le
type d'un pointeur noyau.

\begin{verbatim}
| T.Deref(e, _sz) ->
    let (_, te) = infer_exp env e in
    let t = new_unknown () in
    unify (Ptr (Kernel, t)) te;
    t
\end{verbatim}

\section{Exemple}

Lançons l'analyse sur un petit exemple:

\begin{verbatim}
int f(int *x) { return (*x + 1); }
\end{verbatim}

L'exécution de notre analyseur affiche un programme complètement annoté:

\begin{verbatim}
 % ptrtype example.c
f : (Ptr (Int)) -> (Int)
Int (example.c:1#4)^f(Ptr (Int) x) {
  (.c:3#4)^!return =(int32)
    (coerce[-2147483648,2147483647]
      ( ( ([(x_Ptr (Int) : Ptr (Int))]32_Int
            : Int
          )
          + (1 : Int)
        ) : Int
      ) : Int
    );
}
\end{verbatim}

L'opérateur \texttt{coerce[a,b]} est un artefact de Newspeak, destiné à détecter
les débordements d'entiers lors d'une analyse de valeurs par interprétation
abstraite. Dans le cas de notre analyse, les valeurs ne sont pas pertinentes et
cet opérateur peut être vu que comme un «plus» unaire typé $(\tInt) → \tInt$.

Un exemple de cas d'erreur sera décrit dans la section~\ref{sec:demo-unif}.

\section{Performance}

Sur les exemples testés nous n'avons pas noté de délai d'exécution notable. Cela
est dû au fait que l'algorithme d'inférence est assez efficace: son temps
d'exécution dépend essentiellement de la taille des types du programme, et pour
du code C ils sont en général très simples.

La compilation de C vers \newspeak peut être plus coûteuse, notamment lorsque
le fichier d'entrée est de taille importante. Le temps de traitement est plus
long que celui d'un compilateur comme GCC ou \texttt{clang}, mais reste
raisonnable. \ctonewspeak a été utilisé pour compiler des projets de l'ordre du
million de lignes de code source prétraité, et son exécution ne prenait pas plus
de quelques minutes.

Les structures internes de \ctonewspeak ont déjà été améliorées, et d'autres
optimisations sont certainement possibles, mais la performance n'est pas
bloquante pour le moment: on ne compile en général qu'une seule fois le code à
analyser.

\section{Conclusion}

Les analyses de typage correspondant aux chapitres~\ref{cha:typbase}
et~\ref{cha:qualifs} ont été implantées sous forme d'un prototype utilisant le
langage \newspeak développé par EADS. Cela permet de réutiliser les phases de
compilation déjà implantées, et d'exprimer les règles de typage sur un langage
suffisament simple.

On utilise un algorithme par unification, qui donne une forme simple
programme d'inférence. Pour chaque expression ou instruction à typer, on
détermine grâce au lemme~\ref{lemma:inversion} quelle règle il faut appliquer.
Ensuite, on génère les inconnues de type nécessaires pour appliquer cette règle
et on indique les contraintes en appelant la fonction d'unification.

Ce prototype, disponible sous license libre sur \url{http://penjili.org}, reste
incomplet mais permet de traiter des parties du noyau Linux comme on le verra
dans le chapitre suivant.

% vim: spelllang=fr
