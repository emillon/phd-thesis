\def\tBits{\textsc{Bits}\xspace}
\def\tChar{\textsc{Char}\xspace}

Dans le langage C, les types de données décrivent uniquement l'agencement en
mémoire des valeurs. Elles n'ont pas de portée plus sémantique permettant
d'exprimer ce qu'elles représentent. Par exemple, dans un programme manipulant
des dates, on sera amené à manipuler des numéros de mois et d'années,
représentés par des types entiers. Le langage C permet de définir des nouveaux
types:

\begin{verbatim}
typedef int month_t;
typedef int year_t;
\end{verbatim}

Cependant, rien ne distingue le nouveau type de l'ancien. Il ne s'agit que d'une
aide à la documentation. Dans cet exemple, \texttt{month\_t} et \texttt{year\_t}
sont tous les deux des nouveaux noms pour le type `int`, donc ils sont en fait
compatibles. Le compilateur ne peut donc pas détecter qu'on utilise un numéro de
mois là où un numéro d'année était attendu (ou \emph{vice versa}).

Cet idiome est commun en C. On manipule notamment certaines données abstraites
par des clés entières, et un \texttt{typedef} particulier permet de désigne
celles-ci. Par exemple sous Linux, les numéros de processus sont des indices
dans la table de processus interne au noyau, et on y accède par une valeur de
type \texttt{pid\_t}. De même, les utilisateurs sont représentés par un nombre
entier du type \texttt{uid\_t}.

Un autre idiome est répandu: l'utilisation d'entiers comme représentation d'un
ensemble de booléens. En effet, un nombre $a = \sum_{i=0}^{N-1} a_i 2^i$ peut
s'interpréter comme l'ensemble de ses bits égaux à 1: $\{ i ∈ [0;N-1] / a_i = 1
\}$. Un entier de 32 bits peut par exemple représenter une combinaison de 32
options indépendantes.

C'est de cette manière que fonctionne l'interface qui permet d'ouvrir un fichier
sous Unix.

\begin{verbatim}
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
\end{verbatim}

Le paramètre \texttt{flags} est un entier qui encode les options liées à
l'ouverture du fichier. On précise son mode (lecture, écriture ou les deux) par
les bits 1 et 2, s'il faut créer le fichier ou non s'il n'existe pas par le bit
7, si dans ce cas il doit être effacé par le bit 8, etc. On obtient le paramètre
complet en réalisant un «ou» bit à bit entre des constantes.

Le paramètre \texttt{mode} (en fait un \emph{unsigned int}) encode de la même
manière les permissions que doit avoir le fichier créé, le cas échéant.

Ces fonctions retournent un entier, qui est un \emph{descripteur de fichier}. Il
correspond à un indice numérique dans une table interne au processus. Par
exemple, $0$ désigne son entrée standard, $1$ sa sortie standard, et $2$ son
flux d'erreur standard.

On identifie donc au moins trois utilisations du type \texttt{int}:

\begin{itemize}
    \item entier: c'est l'utilisation classique pour représenter des valeurs
        numériques. Toutes les opérations sont possibles.
    \item bitmask: on utilise un entier comme ensemble de bits. Seules les
        opérations bit à bit ont du sens.
    \item Entier opaque: on utilise un entier de manière purement abstraite.
        C'est l'exemple des descripteurs de fichier.
\end{itemize}

Ces utilisations du type n'ont rien à voir ; il faudrait donc empêcher
d'utiliser un descripteur de fichier comme un mode, et vice-versa. De même,
aucun opérateur n'a de sens sur les descripteurs de fichier, mais l'opérateur
\texttt{\textbar{}} du «ou» bit à bit doit rester possible pour les modes.

On décrit ici une technique de typage pour détecter et interdire ces mauvaises
utilisations. Plus précisément, On propose une version ``bien typée'' de la
fonction \texttt{open}. Plus précisément, on donne à ses deuxième et troisième
argument (respectivement \texttt{flags} et \texttt{mode}) le nouveau type \tBits
qui correspond aux entiers utilisés comme bitmasks. Le type de retour n'est pas
modifié (il reste \tInt), mais on décrit comment il est possible de faire cette
adaptation.

\section{Modifications}

On ajoute un type \tBits. Il faut aussi ajouter un type \tChar apparaissant dans
les chaînes de caractères. On ne spécifie pas plus ce dernier mais on suppose
qu'il existe des littéraux de chaînes qui retournent un pointeur vers le premier
élément d'un tableaux de caractères.

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \tChar }{Caractère}
  { \tBits }{Entier utilisé comme \emph{bitmask}}
  {END}
\end{align*}

Au niveau des valeurs, les entiers sont représentés par des valeurs entières
classiques $\widehat{n}$. En particulier, on n'ajoute pas de nouveau type
sémantique, mais on ajoute la règle suivante de compatibilité entre le type de
valeurs \tInt et le type statique \tBits.

\[
  \irule{Comp-Bits}
    { }
    { \tComp{\tInt}{\tBits} }
\]

On change le type des ``constructeurs'':

\begin{align*}
    [] ⊢ \texttt{O\_RDONLY} : \tBits \\
    [] ⊢ \texttt{O\_RDWR}   : \tBits \\
    [] ⊢ \texttt{O\_APPEND} : \tBits
\end{align*}

Et celui des ``consommateurs'':

\[
    [] ⊢ \texttt{open} : (\tChar~*, \tBits) → \tInt
\]

Pour que les opérations bit à bit puissent s'appliquer aux bitmasks,
on ajoute ces règles:

\begin{mathpar}
    \irule{Or-Bits}
        { Γ ⊢ e_1 : \tBits
       \\ Γ ⊢ e_2 : \tBits
       }{ Γ ⊢ e_1~|~e_2 : \tBits
       }

    \irule{And-Bits}
        { Γ ⊢ e_1 : \tBits
       \\ Γ ⊢ e_2 : \tBits
       }{ Γ ⊢ e_1~\&~e_2 : \tBits
       }

    \irule{Xor-Bits}
        { Γ ⊢ e_1 : \tBits
       \\ Γ ⊢ e_2 : \tBits
       }{ Γ ⊢ e_1~\opxor~e_2 : \tBits
       }
\end{mathpar}
%TODO ajouter le not bit à bit ici + dans les autres chap

\jolibreak % TODO choisir

\begin{mathpar}
    \irule{Op-Bits}
        { \opun ∈ \{ |, \&, \opxor \}
       \\ Γ ⊢ e_1 : \tBits
       \\ Γ ⊢ e_2 : \tBits
       }{ Γ ⊢ e_1~\opbin~e_2 : \tBits
       }
\end{mathpar}

Cette règle pose problème pour l'inférence, car partant d'une expression de la
forme $e_1~|~e_2$ on ne sait pas quelle règle appliquer: celle qui porte sur
\tInt ou celle sur \tBits.

Concrètement, cela veut dire qu'on ne peut pas inférer de type pour la fonction
suivante:

\[
    \eFun{x, y}{\iReturn{x~|~y}}
\]

En revanche, si on annote le type de $x$ ou de $y$, le reste peut être inféré.

\clearpage

\paragraph{Polymorphisme restreint}

Aussi appelé \emph{bounded polymorphism}, il permet de contraindre les variables
de type généralisées. Cela permet de donner à la fonction précédente un type
comme:

\[
    ∀a. (a ∈ \{ \tInt, \tBits \}) ⇒ (a, a) → a
\]

Cela implique de modifier le système de type pour associer aux expression non
pas des types, mais des schémas de type (incluant des variables quantifiées). On
généralise les variables de certaines déclarations (les globales, par exemple),
et à l'utilisation il faut instancier les schémas, c'est-à-dire substituer aux
variables quantifiées des paramètres concrets. Ceci présente plusieurs
désavantages:

\begin{itemize}
    \item la présentation du système de types est alourdie;
    \item l'inférence est plus complexe;
    \item si on autorise le polymorphisme non restreint (en donnant par exemple à
        la fonction identité le type $∀a. (a) → a$), il faut
        à l'exécution
        représenter les données
        de manière uniforme, ce qui revient à changer la sémantique du langage.
\end{itemize}

\clearpage

\subsection*{Transtypage}

\begin{align*}
\gramdef{Expression}{e}
  { … }{}
  {e \angle t}{Transtypage}
  {END}
\\
\\
\gramdef{Contexte d'évaluation}{C}
  { … }{}
  { C \angle t}{ }
  {END}
\end{align*}

\begin{mathpar}
    \irule{E-Coerce}
        { }
        {
            \mms{(v \angle t)}{v}
        }

    \irule{T-Coerce}
        { Γ ⊢ e : t
       \\ \tComp{τ}{t}
       \\ \tComp{τ}{t'}
        }
        { Γ ⊢ (e \angle t') : t'
        }
\end{mathpar}

% TODO comment adapter FD
