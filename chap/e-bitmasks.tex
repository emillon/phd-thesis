Dans le langage C, les types de données décrivent uniquement l'agencement en
mémoire des valeurs. Elles n'ont pas de portée plus sémantique permettant
d'exprimer ce qu'elles représentent. Par exemple, dans un programme manipulant
des dates, on sera amené à manipuler des numéros de mois et d'années,
représentés par des types entiers. Le langage C permet de définir des nouveaux
types:

\begin{verbatim}
typedef int month_t;
typedef int year_t;
\end{verbatim}

Cependant, rien ne distingue le nouveau type de l'ancien. Il ne s'agit que d'une
aide à la documentation. Dans cet exemple, \texttt{month\_t} et \texttt{year\_t}
sont tous les deux des nouveaux noms pour le type `int`, donc ils sont en fait
compatibles. Le compilateur ne peut donc pas détecter qu'on utilise un numéro de
mois là où un numéro d'année était attendu (ou \emph{vice versa}).

\begin{center}\rule{3in}{0.4pt}\end{center}

Cet idiome est commun en C. On manipule notamment certaines données abstraites
par des clés entières, et un \texttt{typedef} particulier permet de désigne
celles-ci. Par exemple sous Linux, les numéros de processus sont des indices
dans la table de processus interne au noyau, et on y accède par une valeur de
type \texttt{pid\_t}. De même, les utilisateurs sont représentés par un nombre
entier du type \texttt{uid\_t}.

\begin{center}\rule{3in}{0.4pt}\end{center}

\def\tBits{\textsc{Bits}\xspace}

Par exemple, en ouvrant un fichier on précise le mode du fichier (lecture,
écriture ou les deux) par les bits 1 et 2, s'il faut créer le fichier ou non
s'il n'existe pas par le bit 7, s'il dans ce cas il doit être effacé par le bit
8), etc. On obtient un mode en réalisant un «ou» bit à bit entre des
constantes. Ces deux utilisations du type \texttt{int} n'ont rien à voir ; il
faudrait donc empêcher d'utiliser un descripteur de fichier comme un mode, et
vice-versa. De même, aucun opérateur n'a de sens sur les descripteurs de
fichier, mais l'opérateur \texttt{\textbar{}} du «ou» bit à bit doit rester
possible pour les modes.

\begin{center}\rule{3in}{0.4pt}\end{center}

Les fonctions suivantes permettent d'ouvrir un fichier sous Unix.

\begin{verbatim}
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
\end{verbatim}

Il est intéressant de remarquer que ces fonctions manipulent des entiers:

\begin{itemize}

\item la valeur de retour est un \emph{descripteur de fichier}, qui correspond à
un indice numérique dans une table interne au processus. Par exemple, $0$
désigne son entrée standard, $1$ sa sortie standard, et $2$ son flux d'erreur
standard.

\item \texttt{flags} est un entier qui encode les options liées à l'ouverture du
fichier.

\item \texttt{mode} (en fait un \emph{unsigned int}) encode de la même manière
les permissions que doit avoir le fichier créé, le cas échéant.

\end{itemize}

Ces entiers ont une particularité en commun: ils ne sont pas utilisés comme
entiers au sens arithmétique du terme. C'est-à-dire que \texttt{int} ou
\texttt{unsigned int} est le bon type car il correspond à la bonne taille de
données, mais les opérations comme $+$ ou $/$ n'ont pas de sens sur ces valeurs.

On décrit ici une technique de typage pour détecter et interdire ces mauvaises
utilisations.

\section{Ajouts}

On étend les types avec un type \tBits.

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \tBits }{Entier utilisé comme \emph{bitmask}}
  {END}
\end{align*}

Au niveau des valeurs, les entiers sont représentés par des valeurs entières
classiques $\widehat{n}$. C'est pourquoi on ajoute la règle suivante de
compatibilité entre le type de valeurs \tInt et le type statique \tBits.

\[
  \irule{Comp-Bits}
    { }
    { \tComp{\tInt}{\tBits} }
\]
