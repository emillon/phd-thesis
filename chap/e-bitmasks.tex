\def\tBits{\textsc{Bits}\xspace}
\def\tChar{\textsc{Char}\xspace}

Dans le langage C, les types de données décrivent uniquement l'agencement en
mémoire des valeurs. Elles n'ont pas de portée plus sémantique permettant
d'exprimer ce qu'elles représentent. Par exemple, dans un programme manipulant
des dates, on sera amené à manipuler des numéros de mois et d'années,
représentés par des types entiers. Le langage C permet de définir des nouveaux
types:

\begin{verbatim}
typedef int month_t;
typedef int year_t;
\end{verbatim}

Cependant, rien ne distingue le nouveau type de l'ancien. Il ne s'agit que d'une
aide à la documentation. Dans cet exemple, \texttt{month\_t} et \texttt{year\_t}
sont tous les deux des nouveaux noms pour le type `int`, donc ils sont en fait
compatibles. Le compilateur ne peut donc pas détecter qu'on utilise un numéro de
mois là où un numéro d'année était attendu (ou \emph{vice versa}).

\begin{center}\rule{3in}{0.4pt}\end{center}

Cet idiome est commun en C. On manipule notamment certaines données abstraites
par des clés entières, et un \texttt{typedef} particulier permet de désigne
celles-ci. Par exemple sous Linux, les numéros de processus sont des indices
dans la table de processus interne au noyau, et on y accède par une valeur de
type \texttt{pid\_t}. De même, les utilisateurs sont représentés par un nombre
entier du type \texttt{uid\_t}.

\begin{center}\rule{3in}{0.4pt}\end{center}

Par exemple, en ouvrant un fichier on précise le mode du fichier (lecture,
écriture ou les deux) par les bits 1 et 2, s'il faut créer le fichier ou non
s'il n'existe pas par le bit 7, si dans ce cas il doit être effacé par le bit 8,
etc. On obtient un mode en réalisant un «ou» bit à bit entre des constantes. Ces
deux utilisations du type \texttt{int} n'ont rien à voir ; il faudrait donc
empêcher d'utiliser un descripteur de fichier comme un mode, et vice-versa. De
même, aucun opérateur n'a de sens sur les descripteurs de fichier, mais
l'opérateur \texttt{\textbar{}} du «ou» bit à bit doit rester possible pour les
modes.

\begin{center}\rule{3in}{0.4pt}\end{center}

Les fonctions suivantes permettent d'ouvrir un fichier sous Unix.

\begin{verbatim}
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
\end{verbatim}

Il est intéressant de remarquer que ces fonctions manipulent des entiers:

\begin{itemize}

\item la valeur de retour est un \emph{descripteur de fichier}, qui correspond à
un indice numérique dans une table interne au processus. Par exemple, $0$
désigne son entrée standard, $1$ sa sortie standard, et $2$ son flux d'erreur
standard.

\item \texttt{flags} est un entier qui encode les options liées à l'ouverture du
fichier.

\item \texttt{mode} (en fait un \emph{unsigned int}) encode de la même manière
les permissions que doit avoir le fichier créé, le cas échéant.

\end{itemize}

Ces entiers ont une particularité en commun: ils ne sont pas utilisés comme
entiers au sens arithmétique du terme. C'est-à-dire que \texttt{int} ou
\texttt{unsigned int} est le bon type car il correspond à la bonne taille de
données, mais les opérations comme $+$ ou $/$ n'ont pas de sens sur ces valeurs.

On décrit ici une technique de typage pour détecter et interdire ces mauvaises
utilisations.

\section{Portée}

On propose une version ``bien typée'' de la fonction \texttt{open}. Plus
précisément, on donne à ses deuxième et troisième argument (respectivement
\texttt{flags} et \texttt{mode}) le nouveau type \tBits qui correspond aux
entiers utilisés comme bitmasks. Le type de retour n'est pas modifié (il reste
\tInt), mais on décrit comment il est possible de faire cette adaptation.

\section{Modifications}

On ajoute un type \tBits. Il faut aussi ajouter un type \tChar apparaissant dans
les chaînes de caractères. On ne spécifie pas plus ce dernier mais on suppose
qu'il existe des littéraux de chaînes qui retournent un pointeur vers le premier
élément d'un tableaux de caractères.

\begin{align*}
\gramdef{Type}{t}
  { … }{}
  { \tChar }{Caractère}
  { \tBits }{Entier utilisé comme \emph{bitmask}}
  {END}
\end{align*}

Au niveau des valeurs, les entiers sont représentés par des valeurs entières
classiques $\widehat{n}$. En particulier, on n'ajoute pas de nouveau type
sémantique, mais on ajoute la règle suivante de compatibilité entre le type de
valeurs \tInt et le type statique \tBits.

\[
  \irule{Comp-Bits}
    { }
    { \tComp{\tInt}{\tBits} }
\]

On change le type des ``constructeurs'':

\begin{align*}
    [] ⊢ \texttt{O\_RDONLY} : \tBits \\
    [] ⊢ \texttt{O\_RDWR}   : \tBits \\
    [] ⊢ \texttt{O\_APPEND} : \tBits
\end{align*}

Et celui des ``consommateurs'':

\[
    [] ⊢ \texttt{open} : (\tChar~*, \tBits) → \tInt
\]

\begin{center}\rule{3in}{0.4pt}\end{center}

\[
    \irule{Coerce}
        { Γ ⊢ e : t
       \\ \tComp{τ}{t}
       \\ \tComp{τ}{t'}
        }
        { Γ ⊢ (e \angle t') : t'
        }
\]

% TODO comment adapter FD
