Dans ce chapitre, un exemple de mise en œuvre du système de type décrit dans le
chapitre~\ref{cha:qualifs} et implanté dans le chapitre~\ref{cha:implem}.

\section{Linux}

Le noyau Linux, abordé dans le chapitre~\ref{cha:os}, est un noyau de système
d'exploitation développé depuis le début des années 90 et ``figure de proue'' du
mouvement open-source. Au départ écrit par Linus Torvalds sur son ordinateur
personnel, il a au fil des années était porté sur de nombreuses architectures et
s'est enrichi de nombreux pilotes de périphériques. En 20XX, son code source
comporte 8.8 millions de lignes de code (en grande majorité du C) dont 55\% de
pilotes.

% TODO fix le XX
% TODO mettre à jour

Même si le noyau est monolithique (la majeure partie des traitements s'effectue
au sein d'un même fichier objet), les sous-systèmes sont indépendants. C'est ce
qui permet d'écrire des pilotes de périphériques et des modules.

\section{GNU C}

Linux est écrit dans le langage C, mais pas sa version normalisée. Il utilise le
dialecte GNU C qui est celui que supporte GCC.

Pour traduire ce dialecte, il a été nécessaire d'adapter \texttt{c2newspeak}. La
principale particularité est la notation \texttt{\_\_attribute\_\_((...))} qui
peut décorer les déclarations de fonctions, de variables ou de types. De
nouvelles fonctionnalités sont aussi présentes.

Par exemple, il est possible de manipuler des étiquettes de première classe : si
\texttt{lbl:} est présent avant une instruction, on peut capturer l'adresse de
celle-ci avec \texttt{void *p = \&\&lbl} et y sauter indirectement avec
\texttt{goto *p}.

Une autre fonctionnalité est le concept d'instruction-expression :
\texttt{(\{bloc\})}) est une expression, dont la valeur est celle de la dernière
expression évaluée lors de \texttt{i}.

Les attributs, quant à eux, rentrent dans trois catégories :

\begin{itemize}
  \item les annotations de compilation ; par exemple, \texttt{used} désactive
    l'avertissement ``cette variable n'est pas utilisée ''.

  \item les optimisations ; par exemple, les objets marqués \texttt{hot} sont
    groupés de telle manière qu'ils se retrouvent en cache ensemble.

  \item les annotations de bas niveau ; par exemple, \texttt{aligned(n)}
    spécifie qu'un objet doit être aligné sur au moins \texttt{n} bits.
\end{itemize}

Dans notre cas, toutes ces annotations peuvent être ignorées.

\section{Configuration}

Pour que le code noyau soit compilable, il est nécessaire de définir certaines
macros. En particulier, le système de configuration de Linux utilise des macros
nommées \texttt{CONFIG\_*} pour inclure ou non certaines fonctionnalités. Il a
donc fallu faire un choix ; nous avons choisi la configuration par défaut. Pour
analyser des morceaux plus importants du noyau, il faudrait définir un fichier
de configuration plus important.

\section{Bug}

On décrit le cas d'un pilote video qui contenait un bug de pointeur utilisateur.
Il est répertorié sur \url{http://freedesktop.org} en tant que bug \#29340. 

Pour changer de mode graphique, les pilotes de GPU peuvent supporter le
\emph{Kernel Mode Setting} (KMS).

Pour configurer un périphérique, l'utilisateur communique avec le pilote noyau
avec le mécanisme d'\emph{ioctls}\footnote{
  Ce nom vient de la fonction \texttt{ioctl()} pour
  \emph{Input/Output Control}.
}.
Ils sont similaires à des appels système, mais spécifique à un périphérique
particulier. Les fonctions implantant un \emph{ioctl} sont donc vulnérables à la
même classe d'attaques que les appels système, et donc doivent être écrits avec
une attention particulière.

Le code suivant est présent dans le pilote KMS pour les GPU AMD Radeon :

\begin{verbatim}
/* from drivers/gpu/drm/radeon/radeon_kms.c */
int radeon_info_ioctl(struct drm_device *dev,
                      void *data,
                      struct drm_file *filp) {
	struct radeon_device *rdev =
            dev->dev_private;
	struct drm_radeon_info *info;
	struct radeon_mode_info *minfo =
            &rdev->mode_info;
	uint32_t *value_ptr;
	uint32_t value;
	struct drm_crtc *crtc;
	int i, found;

	info = data;
	value_ptr = (uint32_t *)
            ((unsigned long)info->value);
	value = *value_ptr;
        [...]
}
\end{verbatim}

On peut voit que l'argument \texttt{data} est converti en un \texttt{struct
drm\_radeon\_info *}. Un pointeur \texttt{value\_ptr} est extrait de son champ
\texttt{value}, et finalement ce pointeur est déréferencé.

Cependant, l'argument \texttt{data} est un pointeur vers une structure (allouée
en espace noyau) du type suivant, dont les champs proviennent d'un appel
utilisateur de \texttt{ioctl()}.

\begin{verbatim}
/* from include/drm/radeon_drm.h */
struct drm_radeon_info {
  uint32_t    request;
  uint32_t    pad;
  uint64_t    value;
};
\end{verbatim}

Pour mettre ce problème en évidence, nous avons annoté la fonction
\texttt{radeon\_info\_ioctl} de telle manière que son second paramètre soit un
pointeur noyau vers une structure contenant un champ \qUser, \texttt{value}.
Ceci est possible puisqu'avant la traduction, on efface les types présents dans
le programme C. Ainsi, un pointeur ne peut pas être distingué d'un entier
transtypé en un pointeur. Avec cette configuration, nous obtenons une erreur de
type à la ligne 16.

L'intégralité de ce code peut être trouvée en annexe~\ref{cha:code-noyau}.

\begin{figure}
  \insertcode{radeon-git-mini.diff}

  \caption{Patch résolvant le problème de pointeur utilisateur.}
  \label{fig:linux-patch}
\end{figure}

% TODO décrire syntaxe unified diff

La bonne manière de faire a été publiée avec le numéro de \emph{commit}
\texttt{d8ab3557} (figure~\ref{fig:linux-patch}) (\texttt{DRM\_COPY\_FROM\_USER}
étant une simple macro pout \texttt{copy\_from\_user}). Dans ce cas, on
n'obtient pas d'erreur de typage.

% TODO et l'assembleur inline?

\section{Détails}

Pour utiliser notre système de types, plusieurs étapes sont nécessaires en plus
de traduire le noyau linux en \langname.

Afin de réaliser l'analyse, il faut annoter les sources pour créer un
environnement initial (via la variable \texttt{exttbl} décrite en
section~\ref{sec:ptrtype-archi}).

% TODO dire ce qu'on annote : les sources de pointeurs souillés

Ensuite, il faut réécrire les fonctions de manipulation de pointeurs fournies
par le noyau : \texttt{get\_user}, \texttt{put\_user},
\texttt{copy\_from\_user}, \texttt{copy\_to\_user}, etc. Leur implantation
revient à réaliser un test puis à faire la copie. À leur place on utilise les
primitives $\phxx{\uGet}$ et $\phxx{\uPut}$.

% TODO ... ou on ne met pas ces primitives là en tyspeak et on ajoute juste un
% bon type dans l'environnement initial

Enfin, on peut lancer l'inférence de type.

%  \caption[Bug freedesktop.org \#29340]{Bug freedesktop.org \#29340. Le
%  paramètre \texttt{data} provient de l'espace utilisateur via un appel système.
%  Un appelant malveillant peut se servir de cette fonction pour lire la mémoire
%  du noyau à travers le message d'erreur.}

\section{Principes de l'analyse}

\wip{}

Le problème est modélisé de la façon suivante : on associe à chaque variable
\texttt{x} un type de données \texttt{t}, ce que l'on note \texttt{x:t}. En
plus des types présents dans le langage C, on ajoute une distinction
supplémentaire pour les pointeurs. D'une part, les pointeurs ``noyau'' (de type
\texttt{t~*}) sont créés en prenant l'adresse d'un objet présent dans le code
source. D'autre part, les pointeurs ``utilisateurs'' (leur type est noté
\texttt{t user*}) proviennent des interfaces avec l'espace utilisateur.

Il est sûr de déréférencer un pointeur noyau, mais pas un pointeur
utilisateur. L'opérateur \texttt{*} prend donc un \texttt{t *} en entrée
et produit un \texttt{t}.

Pour faire la vérification de type sur le code du programme, on a besoin de
quelques règles. Tout d'abord, les types suivent le flot de données.
C'est-à-dire que si on trouve dans le code \texttt{a = b}, \texttt{a} et
\texttt{b} doivent avoir un type compatible. Ensuite, le qualificateur
\texttt{user} est récursif : si on a un pointeur utilisateur sur une structure,
tous les champs pointeurs de la structure sont également utilisateur. Enfin, le
déréférencement s'applique aux pointeurs noyau seulement : si le code contient
l'expression \texttt{*x}, alors il existe un type \texttt{t} tel que
\texttt{x:t*} et \texttt{*x:t}.

Appliquons ces règles à l'exemple de la figure \ref{fig:radeon-bug} : on suppose
que l'interface avec l'espace utilisateur a été correctement annotée. Cela
permet de déduire que \texttt{data:void user*}. En appliquant la première règle
à la ligne 6, on en déduit que \texttt{info:struct drm\_radeon\_info user*}
(comme en C, on peut toujours convertir de et vers un pointeur sur
\texttt{void}).

Pour déduire le type de \texttt{value\_ptr} dans la ligne 7, c'est la
deuxième règle qu'il faut appliquer : le champ \texttt{value} de
la structure est de type \texttt{uint32\_t~*} mais on y accède à travers
un pointeur utilisateur, donc \texttt{value\_ptr:uint32\_t user*}.

% TODO faux

À la ligne 8, on peut appliquer la troisième règle : à cause du déréférencement,
on en déduit que \texttt{value\_ptr:t *}, ce qui est une contradiction puisque
d'après les lignes précédentes, \texttt{value\_ptr:uint32\_t user*}.

Si la ligne 3 était remplacée par l'appel à \texttt{copy\_from\_user}, il n'y
aurait pas d'erreur de typage car cette fonction peut accepter les arguments
\texttt{(uint32\_t~*, uint32\_t user*, size\_t)}.

Le principe de cette technique (associer des types aux valeurs puis restreindre
les opérations sur certains types) peut être repris. Par exemple, si on définit
un type ``numéro de bloc'' comme étant un nouvel alias de \texttt{int}, on peut
considérer que multiplier deux telles valeurs est une erreur.
