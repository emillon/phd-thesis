Dans ce chapitre, on décrit un exemple de mise en œuvre du système de type
décrit dans le chapitre~\ref{cha:qualifs} et implanté dans le
chapitre~\ref{cha:implem}.

% TODO court

\section{Linux}

Le noyau Linux, abordé dans le chapitre~\ref{cha:os}, est un noyau de système
d'exploitation développé depuis le début des années 90 et «figure de proue» du
mouvement open-source. Au départ écrit par Linus Torvalds sur son ordinateur
personnel, il a au fil des années été porté sur de nombreuses architectures et
s'est enrichi de nombreux pilotes de périphériques. Dans la version 3.9.8
(2013), son code source comporte 11.2 millions de lignes de code (en grande
majorité du C) dont 57\% de pilotes.

Même si le noyau est monolithique (la majeure partie des traitements s'effectue
au sein d'un même fichier objet), les sous-systèmes sont indépendants. C'est ce
qui permet d'écrire des pilotes de périphériques et des modules.

\section{GNU C}
\label{sec:gnuc}

Linux est écrit dans le langage C, mais pas sa version normalisée. Il utilise le
dialecte GNU C qui est celui que supporte GCC.\@

Pour traduire ce dialecte, il a été nécessaire d'adapter \texttt{c2newspeak}. La
principale particularité est la notation \verb!__attribute__((...))! qui peut
décorer les déclarations de fonctions, de variables ou de types. De nouvelles
fonctionnalités sont aussi présentes.

Par exemple, il est possible de manipuler des étiquettes de première classe: si
\texttt{lbl:} est présent avant une instruction, on peut capturer l'adresse de
celle-ci avec \texttt{void *p = \&\&lbl} et y sauter indirectement avec
\texttt{goto *p}.

Une autre fonctionnalité est le concept d'instruction-expression:
\texttt{(\{bloc\})} est une expression, dont la valeur est celle de la dernière
expression évaluée lors de \texttt{i}.

Les attributs, quant à eux, rentrent dans trois catégories:

\begin{itemize}
  \item les annotations de compilation; par exemple, \texttt{used} désactive
    l'avertissement «cette variable n'est pas utilisée».

  \item les optimisations; par exemple, les objets marqués \texttt{hot} sont
    groupés de telle manière qu'ils se retrouvent en cache ensemble.

  \item les annotations de bas niveau; par exemple, \verb!aligned(n)!
    spécifie qu'un objet doit être aligné sur au moins \texttt{n} bits.
\end{itemize}

Dans notre cas, toutes ces annotations peuvent être ignorées.

\section{Configuration}

Pour que le code noyau soit compilable, il est nécessaire de définir certaines
macros. En particulier, le système de configuration de Linux utilise des macros
nommées \texttt{CONFIG\_*} pour inclure ou non certaines fonctionnalités. Il a
donc fallu faire un choix; nous avons choisi la configuration par défaut. Pour
analyser des morceaux plus importants du noyau, il faudrait définir un fichier
de configuration plus important.

\section{Appels systèmes sous Linux}
\label{sec:linux-sys}

Dans cette section, nous allons voir comment ces mécanismes sont implantés dans
le noyau Linux. Une description plus détaillée pourra être trouvée dans
\cite{UnderstandingTheLinuxKernel}, ou pour le cas de la mémoire virtuelle,
\cite{LinuxVMM}.

Deux rings sont utilisés: en \ring{0}, le code noyau et en \ring{3}, le code
utilisateur.

Une notion de tâche similaire à celle décrite dans la section~\ref{sec:taches}
existe: elles s'exécutent l'une après l'autre, le changement s'effectuant sur
interruptions.

Pour faire appel aux services du noyau, le code utilisateur doit faire appel à
des appels systèmes, qui sont des fonctions exécutées par le noyau. Chaque tâche
doit donc avoir deux piles: une pile «utilisateur» qui sert pour
l'application elle-même, et une pile «noyau» qui sert aux appels système.

\begin{figure} % fig:memmap {{{
\centering
\input{fig/memmap.tex}

\caption[Espace d'adressage d'un processus]{L'espace d'adressage d'un processus.
En gris clair, les zones accessibles à tous les niveaux de privilèges: code du
programme, bibliothèques, tas, pile. En gris foncé, la mémoire du noyau,
réservée au mode privilégié.}

\label{fig:memmap}
\end{figure}
% }}}

Grâce à la mémoire virtuelle, chaque processus possède sa propre vue de la
mémoire dans son espace d'adressage (figure~\ref{fig:memmap}), et donc chacun un
ensemble de tables de pages et une valeur de \crtrois{} associée (ce mécanisme a
été abordé page~\pageref{page:mem-virt}). Au moment de changer le processus en
cours, l'ordonnanceur charge donc le \crtrois{} du nouveau processus.

Les adresses basses (inférieures à \texttt{PAGE\_OFFSET} = 3 Gio =
\texttt{0xc0000000}) sont réservées à l'utilisateur. On y trouvera par exemple:

\begin{itemize}
\item le code du programme
\item les données du programme (variables globales)
\item la pile utilisateur
\item le tas (mémoire allouée par \texttt{malloc} et fonctions similaires)
\item les bibliothèques partagées
\end{itemize}

Au dessus de \texttt{PAGE\_OFFSET}, se trouve la mémoire réservée au noyau.
Cette zone contient le code du noyau, les piles noyau des processus, etc.

\label{sec:impl-syscall}

Les programmes utilisateur s'exécutant en \ring{3}, ils ne peuvent pas contenir
d'instructions privilégiées, et donc ne peuvent pas accéder directement au
matériel. Pour qu'ils puissent interagir avec le système (afficher une sortie,
écrire sur le disque…) le mécanisme des appels système est nécessaire. Il s'agit
d'une interface de haut niveau entre les \emph{rings} 3 et 0. Du point de vue du
programmeur, il s'agit d'un ensemble de fonctions C «magiques» qui font appel
au système d'exploitation pour effectuer des opérations.

Voyons ce qui se passe derrière la magie apparente. Une explication plus
détaillée est disponible dans la documentation fournie par Intel
\cite{intelsys}.

\paragraph{Dans la bibliothèque C}

Il y a bien une fonction \texttt{getpid} présente dans la bibliothèque C du
système. C'est la fonction qui est directement appelée par le programme. Cette
fonction commence par placer le numéro de l'appel système (noté
\texttt{\_\_NR\_getpid}, valant 20 ici) dans \eax, puis les arguments éventuels
dans les registres (\ebx, \ecx, \edx, \esi{} puis \edi). Une interruption
logicielle est ensuite déclenchée (\verb!int 0x80!).

\paragraph{Dans la routine de traitement d'interruption}

Étant donné la configuration du processeur\footnote{Il est impropre de dire que
le processeur est configuré --- tout dépend uniquement de l'état de certains
registres, ici la \emph{Global Descriptor Table} et les \emph{Interrupt
Descriptor Tables}.}, elle sera traitée en \ring{0}, à un point d'entrée
prédéfini (\verb!arch/x86/kernel/entry_32.S!, \verb!ENTRY(system_call)!).

\insertcode{entry-syscall.s}

L'exécution reprend donc en \ring{0}, avec dans \esp{} le pointeur de pile noyau
du processus. Les valeurs des registres ont été préservées, la macro
\texttt{SAVE\_ALL} les place sur la pile. Ensuite, à l'étiquette
\texttt{syscall\_call}, le numéro d'appel système (toujours dans \eax) sert
d'index dans le tableau de fonctions \texttt{sys\_call\_table}.


\paragraph{Dans l'implantation de l'appel système}

Puisque les arguments sont en place sur la pile, comme dans le cas d'un appel de
fonction «classique», la convention d'appel \emph{cdecl} est respectée. La
fonction implantant l'appel système, nommée \texttt{sys\_getpid}, peut donc être
écrite en C.

On trouve cette fonction dans \texttt{kernel/timer.c}:

\insertcode{syscall-definition.c}

La macro \texttt{SYSCALL_DEFINE0} nomme la fonction \texttt{sys\_getpid}, et
définit entre autres des points d'entrée pour les fonctionnalités de débogage du
noyau. À la fin de la fonction, la valeur de retour est placée dans \eax,
conformément à la convention \emph{cdecl}.

\paragraph{Retour vers le ring 3}

Au retour de la fonction, la valeur de retour est placée à la place de \eax{} là
où les registres ont été sauvegardés sur la pile noyau
(\texttt{PT\_EFLAGS(\%esp)}). % chktex 36
L'instruction \texttt{iret} (derrière la macro
\texttt{INTERRUPT\_RETURN}) permet de restaurer les registres et de repasser en
mode utilisateur, juste après l'interruption. La fonction de la bibliothèque C
peut alors retourner au programme appelant.

\section{Risques}

Ainsi que décrit dans la section~\ref{sec:secu-syscalls}, cela peut poser un
problème de manipuler des pointeurs contrôlés par l'utilisateur au sein d'une
routine de traitement d'appel système.

Si le déréférencement est fait sans vérification, un utilisateur mal intentionné
peut forger un pointeur vers le noyau (en déterminant des adresses valides dans
l'espace noyau entre \texttt{0xc0000000} et \texttt{0xffffffff}). En provoquant
une lecture sur ce pointeur, des informations confidentielles peuvent fuiter ;
et en forçant une écriture, il est possible d'augmenter ses privilèges, par
exemple en devenant super-utilisateur (\emph{root}). En pratique, il n'est pas
toujours possible d'accéder à la mémoire. La mémoire utilisateur peut par
exemple avoir été placée en zone d'échange sur le disque, ou \emph{swap}. À ce
moment là, l'erreur provoquera tout de même un déni de service. Plus de détails
sur ce mécanisme, et le fonctionnement de la mémoire virtuelle dans Linux,
peuvent être trouvés dans~\cite{userspaceaccess}.

\section{Exemple de bug}

On décrit le cas d'un pilote vidéo qui contenait un bug de pointeur utilisateur.
Il est répertorié sur \url{http://freedesktop.org} en tant que bug \#29340.

Pour changer de mode graphique, les pilotes de GPU peuvent supporter le
\emph{Kernel Mode Setting} (KMS).

Pour configurer un périphérique, l'utilisateur communique avec le pilote noyau
avec le mécanisme d'\emph{ioctls}\footnote{
  Ce nom vient de la fonction \verb!ioctl()! pour
  \emph{Input/Output Control}.
}.
Ils sont similaires à des appels système, mais spécifiques à un périphérique
particulier. Le transfert de contrôle est similaire à ce qui a été décrit dans
la section précédente: les applications utilisateurs appellent la fonction
\texttt{ioctl()} de la bibliothèque standard, qui provoque une interruption.
Celle-ci est traitée par la fonction \texttt{sys\_ioctl()} qui appelle la
routine de traitement dans le bon pilote de périphérique.

Les fonctions implantant un \emph{ioctl} sont donc vulnérables à la
même classe d'attaques que les appels système, et donc doivent être écrits avec
une attention particulière.

Le code suivant est présent dans le pilote KMS pour les GPU AMD Radeon:

\begin{verbatim}
/* from drivers/gpu/drm/radeon/radeon_kms.c */
int radeon_info_ioctl(struct drm_device *dev,
                      void *data,
                      struct drm_file *filp) {
	struct radeon_device *rdev =
            dev->dev_private;
	struct drm_radeon_info *info;
	struct radeon_mode_info *minfo =
            &rdev->mode_info;
	uint32_t *value_ptr;
	uint32_t value;
	struct drm_crtc *crtc;
	int i, found;

	info = data;
	value_ptr = (uint32_t *)
            ((unsigned long)info->value);
	value = *value_ptr;
        [...]
}
\end{verbatim}

On peut voit que l'argument \texttt{data} est converti en un \texttt{struct
drm\_radeon\_info *}. Un pointeur \texttt{value\_ptr} est extrait de son champ
\texttt{value}, et finalement ce pointeur est déréferencé.

Cependant, l'argument \texttt{data} est un pointeur vers une structure (allouée
en espace noyau) du type suivant, dont les champs proviennent d'un appel
utilisateur de \verb!ioctl()!.

\begin{verbatim}
/* from include/drm/radeon_drm.h */
struct drm_radeon_info {
  uint32_t    request;
  uint32_t    pad;
  uint64_t    value;
};
\end{verbatim}

Pour mettre ce problème en évidence, nous avons annoté la fonction
\texttt{radeon\_info\_ioctl} de telle manière que son second paramètre soit un
pointeur noyau vers une structure contenant un champ \qUser, \texttt{value}.
Ceci est possible puisqu'avant la traduction, on efface les types présents dans
le programme C. Ainsi, un pointeur ne peut pas être distingué d'un entier
transtypé en un pointeur. Avec cette configuration, nous obtenons une erreur de
type à la ligne 16.

L'intégralité de ce code peut être trouvée en annexe~\ref{cha:code-noyau}.

\begin{figure}
  \insertcode{radeon-git-mini.diff}

  \caption[Patch résolvant le problème de pointeur utilisateur.]
      {Patch résolvant le problème de pointeur utilisateur.
       La ligne précédée par un signe \texttt{-} est supprimée et remplacée
       par les lignes précédées par un signe \texttt{+}.
      }
\label{fig:linux-patch}
\end{figure}

La bonne manière de faire a été publiée avec le numéro de \emph{commit}
\texttt{d8ab3557} (figure~\ref{fig:linux-patch}) (\texttt{DRM\_COPY\_FROM\_USER}
étant une simple macro pout \texttt{copy\_from\_user}). Dans ce cas, on
n'obtient pas d'erreur de typage.

\section{Procédure expérimentale}
\label{sec:demo-unif}

Pour utiliser notre système de types, plusieurs étapes sont nécessaires en plus
de traduire le noyau linux en \langname{}.

Afin de réaliser l'analyse, il faut annoter les sources pour créer un
environnement initial (via la variable \texttt{exttbl} décrite en
section~\ref{sec:ptrtype-archi}). Plus précisément, pour chaque source de
pointeurs souillés on ajoute un commentaire spécial \texttt{!npk userptr x}, qui
unifie le type de \texttt{x} avec $\ptrU{t}$ où $t$ est une inconnue de type.

Par rapport au code complet présent dans l'annexe~\ref{cha:code-noyau},
l'expression calculant \texttt{value_ptr} est également simplifiée. Dans le code
d'origine, \texttt{info->value} est transtypé en \texttt{unsigned long} puis en
\texttt{uint32\_t *}. En \newspeak, cela correspond à des opérateurs
\texttt{PtrToInt} et \texttt{IntToPtr} mais si on les autorise, on casse le
typage puisqu'il est alors possible de transformer n'importe quel type en un
autre. De plus, on modifie la définition de
\texttt{struct drm\_radeon\_info} pour que son champ \texttt{value} ait pour
type `uint32_t *` plutôt que `uint64_t`. En effet, dans ce cas d'étude, cet
entier est uniquement utilisé en tant que pointeur au cours de toute
l'exécution.

\begin{figure}
\insertcode{ex-drm.c}

\caption{Code du noyau annoté}
\label{fig:ex-drm}
\end{figure}

En ce qui concerne les fonctions de manipulation de pointeurs fournies
par le noyau (\texttt{get\_user}, \texttt{put\_user},
\texttt{copy\_from\_user}, \texttt{copy\_to\_user}, etc.), on ajoute à
l'environnement global leur type correct.

Enfin, on peut lancer l'inférence de type. Ainsi, sur l'exemple de la
figure~\ref{fig:ex-drm}, on obtient la sortie suivante:

\begin{Verbatim}
05-drm.c:17#1 - Cannot unify qualifiers:
  Kernel
  User
\end{Verbatim}

Cela indique qu'on a essayé d'unifier un type de la forme $\ptrK{t}$ avec un
type de la forme $\ptrU{t}$, en précisant l'emplacement où la dernière
unification a échoué.

\section*{Conclusion}

Le prototype décrit dans le chapitre~\ref{cha:implem} peut s'adapter à détecter
des bugs dans le noyau Linux. Pour le moment, il nécessite du code annoté, mais
la phase de compilation depuis le code GNU C que comporte le noyau peut déjà
être compilée automatiquement en \newspeak, puis dans une représentation proche
de \langname.

% TODO peut être un peu short

% TODO parler de ce qu'apporte cette expérimentation

% vim: spelllang=fr
