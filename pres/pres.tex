\documentclass{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}

\usepackage{tikz}

\input{gen/pygments-style.tex}
%\usepackage{xcolor}
\input{mellon.tex}
\usepackage{etoolbox}
\usepackage{xspace}
\usepackage{../switch}
\usepackage{../mathpartir}

\input{../defs.tex}
\input{../rules.tex}

\usetheme{SAS}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\usepackage{../pelagiccod}
\usepackage{booktabs}

\usepackage{amsmath,amsthm, amssymb, latexsym}
\usefonttheme[onlymath]{serif}
%\boldmath

\colorlet{codeoutcol}{MellonYellow!60}
\def\codeout#1{
    \begin{center}
    \fboxsep=2mm
    \colorbox{codeoutcol}{\BUseVerbatim{#1}}
    \end{center}
}

\usepackage{fancyvrb}

\title{Analyse de sécurité de logiciels système par typage statique}
\subtitle{Application au noyau Linux}
\author{Étienne Millon}
\date{10 juillet 2014}

\begin{document}

\AtBeginSubsection[]
{
  \addtocounter{framenumber}{-1}
  \begin{frame}<beamer>
   \frametitle{Outline}
   \tableofcontents[currentsubsection]
 \end{frame}
}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Le confused deputy problem} % TODO emph

\subsection{Le serrurier}

\begin{frame}

\begin{itemize}
\item
  j'appelle un serrurier
\item
  il peut m'ouvrir la porte
\item
  et si je lui dis que j'habite à la banque?
\end{itemize}

\end{frame}
\begin{frame}

\begin{itemize}
\item problème de confiance
\item il appliquer les droits de l'appelant…
\item …pas les siens
\item il doit vérifier que j'ai bien les droits sur la maison
\end{itemize}

\end{frame}

\subsection{Les systèmes d'exploitation}

\begin{frame}[fragile]{Séparation}
\begin{tikzpicture}
  [user/.style={fill=MellonGreen}
  ,kernel/.style={fill=MellonPink}
  ]

  % Memory zone
  %
  % #1 - start
  % #2 - end
  % #3 - color
  \newcommand{\mzone}[3]{
    \path[#3] (#1,0) rectangle (#2,1);
  }

  % Address label
  %
  % #1 - x position
  % #2 - text
  \newcommand{\alabel}[2]{
    \path (#1,1) -- ++(0,0.3) node [pos=1] {\small \tt #2};
  }

  % exec
  \mzone{0.5}{1}{user}

  % lib
  \mzone{2.5}{3.2}{user}

  % stack
  \mzone{3.7}{4}{user}

  % stack
  \mzone{5}{5.5}{user}

  % kernel
  \mzone{6}{8}{kernel}

  % contour
  \draw (0,0) rectangle (8,1);

  \node at (2, -0.7) {Programme};
  \node at (7, -0.7) {Noyau};

  \draw[>=triangle 45,<->,ultra thick] (3.8, -0.7) -- node[auto] {Appels système} ++(2, 0);
  \draw[>=triangle 45,<->,ultra thick] (7, -1) -- node[auto,swap] {Instructions
  privilégiées} ++(0, -1) node (Htop) {};

  \path (Htop) -- ++(-1,-1) node (Htopleft) {};
  \draw (Htopleft) rectangle ++(2, -2);

  \foreach \x in {0,...,9} {
      \draw ($ (Htopleft) + (0.1 + 0.2*\x,  0) $) -- ++(0,  0.3);
      \draw ($ (Htopleft) + (0.1 + 0.2*\x, -2) $) -- ++(0, -0.3);
      \draw ($ (Htopleft) + (0, -0.2*\x - 0.1) $) -- ++(-0.3, 0);
      \draw ($ (Htopleft) + (2, -0.2*\x - 0.1) $) -- ++( 0.3, 0);
   }

  \path (Htop) -- ++(0, -2) node { Matériel };

  \alabel{0}{0}
  \alabel{6}{3 Go}
  \alabel{8}{4 Go}

\end{tikzpicture}
\end{frame}

\begin{frame}{Droits}

Execution of a piece of code:

\begin{itemize}
    \item with processor at level P
    \item with privilege level C
    \item accessing data with level D
\end{itemize}

is possible iff

\[ P ≤ \min\{C; D\} \]

\end{frame}

\begin{frame}{Droits}
On x86, levels are \emph{rings}:

Kernel $= 0$ and User $= 3$.

\begin{center}
\def\modeK{~Kernel~}
\def\modeU{~User~}
\def\accOK{OK}
\def\accNO{--}
\begin{tabular}{cccc}
\toprule
  P
& C
& D
& Access \\
\midrule
  \modeK{} & \modeK{} & \modeK{} & \accOK \\
  \modeK{} & \modeK{} & \modeU{} & \accOK \\
  \modeK{} & \modeU{} & \modeK{} & \accOK \\
  \modeK{} & \modeU{} & \modeU{} & \accOK \\
  \modeU{} & \modeK{} & \modeK{} & \accNO \\
  \modeU{} & \modeK{} & \modeU{} & \accNO \\
  \modeU{} & \modeU{} & \modeK{} & \accNO \\
  \modeU{} & \modeU{} & \modeU{} & \accOK \\
\bottomrule
\end{tabular}
\end{center}

\end{frame}

\section{Contributions}

\subsection{Un langage impératif bien typé}

\begin{frame}
    \begin{itemize}
        \item C: peu de garanties
    \end{itemize}
\end{frame}

\subsection{Une sémantique basée sur les lentilles}

\begin{frame}
\frametitle{Sémantique impérative}

\begin{itemize}
\item
  Système de transitions entre états
\item
  expression + mémoire
\item
  $\mm{m}{e}{m'}{e'}$
\item
  définir $m'$ en fonction de $m$:

  \begin{itemize}
  \item $m[…]$
  \item $m[… ← v]$
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
    \begin{itemize}
        \item valeurs gauches (\emph{lvalues}): \texttt{t[20] = 1}
        \item formes:
            \begin{itemize}
                \item \texttt{var}
                \item \texttt{lv.l}
                \item \texttt{lv[e]}
                \item \texttt{*e}
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Structure de la mémoire}

\begin{itemize}
\item $m = (s, g)$
\item liste de cadres de pile + cadre de globales
\item cadre: $c = ((x_1, v_1), …, (x_n, v_n))$
\item But: exprimer

  \begin{itemize}
  \item $m[φ]$
  \item $m[φ←v]$
  \end{itemize}
\item Mise à jour complète : $m' = m[ x ← 0]$
\item Mise à jour partielle : $m' = m[x.f ← 0]$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{À la main}

\begin{align*}
(s, g)[\texttt{Local}~(2, x).f[5] ← 3] &= (s', g) \\
                   s'_i &= \begin{cases}
                             s_i & \mbox{ si } i ≠ 2\\
                             c'  & \mbox{ sinon} \\
                           \end{cases}\\
                         c &= s_{2} \mbox{ où } c_i &= (x_i, v_i) \\
                   c'_i &= (x_i, v'_i) \\
                   v'_i &= \begin{cases}
                              v_i &  \mbox{ si } i ≠ 1 \\
                              3   &  \mbox{ sinon }\\
                           \end{cases} \\
                    … & …
\end{align*}
\end{frame}

\begin{frame}\frametitle{Lentilles}

\begin{itemize}
\item
  Relation entre objet et sous-objet
\item
  $ℒ ∈ \setLens{R}{A}$
\item
  $ℒ = \begin{cases}           \mathrm{get}_ℒ : R → A \\           \mathrm{put}_ℒ : (A × R) → R \\          \end{cases}$
\item
  $\lensGet{ℒ}{\lensNodeBig{green!30}{blue!30}} = \lensInner{blue!30}$
\item
  $\lensPut{ℒ}{\lensInner{red!30}}{\lensNodeBig{green!30}{blue!30}} = \lensNodeBig{green!30}{red!30}$
\end{itemize}

\end{frame}

\subsection{Un système de types abstraits}

\begin{frame}

\begin{itemize}
\item séparer deux types de pointeurs
\item pointeurs noyau : $\ptrK{t}$

  \begin{itemize}
  \item valeur fixée à la compilation ou par le runtime
  \item ex: \texttt{\&x}, \texttt{malloc(n)}
  \item peuvent être déréférencés (\texttt{*p}, \texttt{memcpy()})
  \end{itemize}
\item pointeurs utilisateur : $\ptrU{t}$

  \begin{itemize}
  \item valeur provient d'un utilisateur non privilégié
  \item ex: paramètres d'appels systèmes
  \item doivent être vérifiés dynamiquement!
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
    \begin{mathpar}
       \disprule{Lv-Deref}

       \disprule{Addr}

       \disprule{User-Get}

       \disprule{User-Put}
    \end{mathpar}
\end{frame}

\subsection{Un prototype d'analyseur statique}

\begin{frame}

\begin{itemize}
\item 1600 lignes d'OCaml
\item utilise \newspeak (langage + compilateur)
\item mode de fonctionnement:
  \begin{itemize}
  \item compile vers un \texttt{.npk}
  \item enlève les types C
  \item infère des types plus sémantiques

      \begin{tabular}{ll}
          \toprule
          Type (C/NPK) & Type(SPK) \\
          \midrule
          \texttt{int} & $\tInt$ \\
          \texttt{unsigned long} & $\tInt$ \\
          \texttt{int *} (utilisé \texttt{x[i]}) & $\tInt~[~]$ \\
          \texttt{int *} (utilisé \texttt{*x}) & $\ptrK{\tInt}$ \\
          \texttt{int *} (argument syscall) & $\ptrU{\tInt}$ \\
          \bottomrule
      \end{tabular}
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
    Utilisé sur 2 bugs du noyau Linux

    \begin{itemize}
        \item Radeon KMS
        \item \texttt{ptrace} Blackfin
    \end{itemize}
\end{frame}

\begin{frame}
    % left bottom right top
    \includegraphics[trim=2300 1430 100 500,clip,width=\textwidth]{poster.pdf}
\end{frame}

\begin{frame}[fragile]
\begin{SaveVerbatim}{drmko}
05-drm.c:17#10 - Type clash between :
  KPtr (_a15)
  UPtr (_a8)
\end{SaveVerbatim}

Résultat de l'algorithme d'inférence -- \textbf{erreur}:

\codeout{drmko}
\end{frame}

\begin{frame}
    % left bottom right top
    \includegraphics[trim=2300 990 100 1220,clip,width=\textwidth]{poster.pdf}
\end{frame}

\begin{frame}[fragile]

\begin{SaveVerbatim}{drmok}
(06-drm-ok.c:17#6)^{
  Int tmp_cir!0;
  (06-drm-ok.c:17#6)^tmp_cir!0 <-
    copy_from_user
      ( &(value) : KPtr (d),
        value_ptr_UPtr (d) : UPtr (d),
        4 : Int); }
\end{SaveVerbatim}

Résultat de l'algorithme d'inférence -- \textbf{programme complètement annoté}:

\codeout{drmok}
\end{frame}

\section{Types abstraits pour C}

\subsection{Le problème}

\begin{frame}
    \begin{itemize}
        \item extention: comment le type est représenté
        \item intention: à quoi il sert
    \end{itemize}
\end{frame}

\subsection{Possibilités}

\begin{frame}
\begin{itemize}
\item encapsulation
\end{itemize}
\end{frame}

\section{Conclusion}

\begin{frame}
    Merci

    Questions?
\end{frame}

\end{document}
