\documentclass{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}

\usepackage{tikz}

\input{gen/pygments-style.tex}
%\usepackage{xcolor}
\input{mellon.tex}
\usepackage{etoolbox}
\usepackage{xspace}
\usepackage{../switch}
\usepackage{../mathpartir}

\input{../defs.tex}
\input{../rules.tex}

\usetheme{SAS}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes}
\usepackage{../gramster}
\usepackage{../pelagiccod}
\usepackage{booktabs}

\usepackage{amsmath,amsthm, amssymb, latexsym}
\usefonttheme[onlymath]{serif}
%\boldmath

\def\colK#1{\colorbox{MellonPink}{\strut $ #1 $}}
\def\colU#1{\colorbox{MellonGreen}{\strut $ #1 $}}
\colorlet{codeoutcol}{MellonYellow!60}
\def\codeout#1{
    \begin{center}
    \fboxsep=2mm
    \colorbox{codeoutcol}{\BUseVerbatim{#1}}
    \end{center}
}

\usepackage{fancyvrb}

\title{Analyse de sécurité de logiciels système par typage statique}
\subtitle{Application au noyau Linux}
\author{Étienne Millon}
\date{10 juillet 2014}

\begin{document}

\AtBeginSubsection[]
{
  \addtocounter{framenumber}{-1}
  \begin{frame}<beamer>
   \tableofcontents[currentsubsection]
 \end{frame}
}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Le problème des pointeurs}

\subsection{L'arnaque du serrurier}

\begin{frame}

\begin{itemize}
\item
  j'appelle un serrurier
\item
  il peut m'ouvrir la porte
\item
  et si je lui dis que j'habite chez mon voisin? à la banque?
\end{itemize}

\end{frame}
\begin{frame}

\begin{itemize}
\item problème de confiance
\item il ne doit pas appliquer ses droits…
\item …mais ceux de l'appelant
\item il doit vérifier que j'ai bien les droits sur la maison
\end{itemize}

\end{frame}

\subsection{Isolation entre utilisateur et noyau}

\begin{frame}{Espaces utilisateur et noyau}
    \begin{itemize}
        \item espace utilisateur: programmes (navigateur, …)
        \item espace noyau: pilotes
        \item matériel
    \end{itemize}
\end{frame}

% Memory zone
%
% #1 - start
% #2 - end
% #3 - color
\newcommand{\mzone}[3]{
  \path[#3] (#1,0) rectangle (#2,1);
}

% Address label
%
% #1 - x position
% #2 - text
\newcommand{\alabel}[2]{
  \path (#1,1) -- ++(0,0.3) node [pos=1] {\small \tt #2};
}
\newcommand{\addrlabel}[2]{
  \draw[<-] (#1,-0.1) -- ++(0,-0.3) node [auto,pos=1] {\small \tt #2};
  \draw[pattern=north east lines] (#1,0) rectangle ++(0.2,1);
}
\long\def\memzones{

  % exec
  \mzone{0.5}{1}{user}

  % lib
  \mzone{2.5}{3.2}{user}

  % stack
  \mzone{3.7}{4}{user}

  % stack
  \mzone{5}{5.5}{user}

  % kernel
  \mzone{6}{8}{kernel}

  % contour
  \draw (0,0) rectangle (8,1);

  \alabel{0}{0}
  \alabel{6}{3 Go}
  \alabel{8}{4 Go}

}

\begin{frame}[fragile]{Séparation}
\begin{tikzpicture}
  [user/.style={fill=MellonGreen}
  ,kernel/.style={fill=MellonPink}
  ]

  \memzones{}

  \node at (2, -0.7) {Programme};
  \node at (7, -0.7) {Noyau};

  \draw[>=triangle 45,<->,ultra thick] (3.8, -0.7) -- node[auto] {Appels système} ++(2, 0);
  \draw[>=triangle 45,<->,ultra thick] (7, -1) -- node[auto,swap] {Instructions
  privilégiées} ++(0, -1) node (Htop) {};

  \path (Htop) -- ++(-1,-1) node (Htopleft) {};
  \draw (Htopleft) rectangle ++(2, -2);

  \foreach \x in {0,...,9} {
      \draw ($ (Htopleft) + (0.1 + 0.2*\x,  0) $) -- ++(0,  0.3);
      \draw ($ (Htopleft) + (0.1 + 0.2*\x, -2) $) -- ++(0, -0.3);
      \draw ($ (Htopleft) + (0, -0.2*\x - 0.1) $) -- ++(-0.3, 0);
      \draw ($ (Htopleft) + (2, -0.2*\x - 0.1) $) -- ++( 0.3, 0);
   }

  \path (Htop) -- ++(0, -2) node { Matériel };

\end{tikzpicture}
\end{frame}

\begin{frame}
    \insertcode{gettimeofday.c}

\begin{tikzpicture}
  [user/.style={fill=MellonGreen}
  ,kernel/.style={fill=MellonPink}
  ]

  \memzones{}
  \addrlabel{2.7}{tv}
\end{tikzpicture}
\end{frame}

\begin{frame}
    \insertcode{gettimeofday-bad.c}

\begin{tikzpicture}
  [user/.style={fill=MellonGreen}
  ,kernel/.style={fill=MellonPink}
  ]

  \memzones{}
  \addrlabel{6.7}{tv}
\end{tikzpicture}
\end{frame}

\begin{frame}
\begin{itemize}
    \item il faut vérifier tous les pointeurs
    \item fonctions \texttt{copy\_from\_user}, \texttt{copy\_to\_user}
    \item test + \texttt{memcpy}
    \item ou retournent une erreur ($< 0$)
    \item but: détecter les cas où on devrait utiliser \texttt{copy\_*\_user}
\end{itemize}
\end{frame}

\section{Formalisation}

\subsection{\langname}

\begin{frame}{Les problèmes de C}
    \begin{itemize}
        \item casts
        \item arithmétique de pointeurs
        \item peu de garanties
    \end{itemize}
\end{frame}

\begin{frame}
  \begin{align*}
  \gramdef{Expressions}{e}
                 { c               }{ Constante }
                 { \opun~e         }{ Opération unaire }
                 { e~\opbin~e      }{ Opération binaire }
                 { lv              }{ Accès mémoire }
                 { lv ← e          }{ Affectation }
                 { \& lv           }{ Pointeur }
                 { f               }{ Fonction }
                 { e (e_1, …, e_n) }{ Appel de fonction }
                 { \eStruct{
                    l_1 : e_1
                    ; …
                    ; l_n : e_n }  }{ Structure }
                 { \eArray{e_1 ;…; e_n} }{ Tableau }
                 {END}
  \end{align*}
\end{frame}

\begin{frame}
  \begin{align*}
  \gramdef{Instructions}{i}
                 { \iPass          }{Instruction vide}
                 { i;i             }{Séquence}
                 { e               }{Expression}
                 { \iDecl{x}{e}{i} }{Déclaration de variable}
                 { \iIf{e}{i}{i}   }{Alternative}
                 { \iWhile{e}{i}   }{Boucle}
                 { \iReturn{e}     }{Retour de fonction}
                 {END}
  \end{align*}
\end{frame}
\subsection{Sémantique}

\begin{frame}{Sémantique impérative}

\begin{itemize}
\item
  Système de transitions entre états
\item
  expression + mémoire
\item
  $\mm{m}{e}{m'}{e'}$
\item expressions $→$ valeurs
\end{itemize}

\end{frame}

\begin{frame}
    \begin{itemize}
        \item valeurs gauches (\emph{lvalues}): \texttt{t[20] = 1}
        \item valeurs gauches $→$ chemins $φ$
        \item formes:
            \begin{itemize}
                \item \texttt{x} $→$ \texttt{(n, x)}
                \item \texttt{lv.l} $→ φ.l$
                \item \texttt{lv[e]} $→ φ[n]$
                \item \texttt{*e} $→ φ$
            \end{itemize}
        \item $\mm{m}{lv ← e}{m'}{v}$ ?
        \item ex: $x.f[5] ← 3$
        \item Mise à jour complète : $m' = m[ x ← 0]$
        \item Mise à jour partielle : $m' = m[x.f ← 0]$
    \end{itemize}
\end{frame}

\begin{frame}{Structure de la mémoire}

\begin{itemize}
\item $m = (s, g) ∈ \sMem$
\item $\sMem = \sList{\sFrame} × \sFrame$
\item liste de cadres de pile, cadre de globales
\item cadre: $c = (x_1 ↦ v_1, …, x_n ↦ v_n) ∈ \sFrame$
\item Comment exprimer:
  \begin{itemize}
  \item $m[φ]$
  \item $m[φ←v]$
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{À la main}

\begin{align*}
(s, g)[\texttt{Local}~(2, x).f[5] ← 3] &= (s', g) \\
                   s'_i &= \begin{cases}
                             s_i & \mbox{ si } i ≠ 2\\
                             c'  & \mbox{ sinon} \\
                           \end{cases}\\
                         c &= s_{2} \mbox{ où } c_i &= (x_i, v_i) \\
                   c'_i &= (x_i, v'_i) \\
                   v'_i &= \begin{cases}
                              v_i &  \mbox{ si } i ≠ 1 \\
                              3   &  \mbox{ sinon }\\
                           \end{cases} \\
                    … & …
\end{align*}
\end{frame}

\subsection{Lentilles}

\begin{frame}{Lentilles}

\begin{itemize}
\item
  Relation entre objet et sous-objet
\item
  $ℒ ∈ \setLens{R}{A}$
\item
  $ℒ = \begin{cases}           \mathrm{get}_ℒ : R → A \\           \mathrm{put}_ℒ : (A × R) → R \\          \end{cases}$
\item
  $\lensGet{ℒ}{\lensNodeBig{green!30,ultra thick}{blue!30, ultra thick}} = \lensInner{blue!30, ultra thick}$
\item
  $\lensPut{ℒ}{\lensInner{red!30, ultra thick}}{\lensNodeBig{green!30, ultra thick}{blue!30, ultra thick}} = \lensNodeBig{green!30, ultra thick}{red!30, ultra thick}$
\end{itemize}

\end{frame}

\begin{frame}

\begin{center}
\definecolor{figcola}{HTML}{EFEF52}
\definecolor{figcolb}{HTML}{52EFA1}
\definecolor{figcolc}{HTML}{52A1EF}
\definecolor{figcold}{HTML}{EFA152}
\begin{tikzpicture}
[node distance=2.5cm
,bignode/.style={draw,shape=rectangle,minimum size=1.5cm,fill=figcola}
,smallnode/.style={draw,shape=circle,minimum size=1cm,fill=figcolb}
,trinode/.style={draw,shape=regular polygon,regular polygon sides=3}
,>=triangle 45
,ultra thick
]
\node[bignode] (A) {};
\node[right of=A,smallnode] (B) {};
\node[right of=B,trinode,fill=figcolc] (C) {};
\node[below of=B,smallnode] (D) {};
\node[below of=A,node distance=5cm,bignode] (E) {};

\draw[->] (A) to node[auto] {$\mathrm{get}_{ℒ_1}$} (B);
\draw[->] (B) to (D);
\draw[->] (A) to (E);
\draw (C) |- node[auto,near end,swap] {$\mathrm{put}_{ℒ_2}$} ($(B)!0.5!(D)$);
\draw (D) |- node[auto,near end,swap] {$\mathrm{put}_{ℒ_1}$} ($(A)!0.75!(E)$);

\node[smallnode] at (A) {};
\node[trinode,fill=figcold] at (A) {};

\node[trinode,fill=figcold] at (B) {};

\node[trinode,fill=figcolc] at (D) {};

\node[smallnode] at (E) {};
\node[trinode,fill=figcolc] at (E) {};

\node[left of=A, node distance=4cm,bignode] (GA) {};
\node[below of=GA,smallnode] (GB) {};
\node[below of=GB,trinode,fill=figcold] (GC) {};

\node[smallnode] at (GA) {};

\node[trinode, fill=figcold] at (GA) {};
\node[trinode, fill=figcold] at (GB) {};

\draw [->] (GA) to node[auto] {$\mathrm{get}_{ℒ_1}$} (GB);
\draw [->] (GB) to node[auto] {$\mathrm{get}_{ℒ_2}$} (GC);

\end{tikzpicture}

\vspace{-1cm}\hspace{7cm} \fbox{$ℒ_1 \ggg ℒ_2$}

\end{center}

\end{frame}

\begin{frame}{Lentilles en sémantique}
    \[Φ ∈ \sPath → \setLens{Mem}{Val}\]

    Pour $φ = (2, x).f[5]$:

    \begin{align*}
    Φ(φ) &= \texttt{fst} \\
         &\ggg I(2) \\
         &\ggg L(x) \\
         &\ggg F(f) \\
         &\ggg T(5)
    \end{align*}
\end{frame}

\begin{frame}{Lentilles en sémantique}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  par tableau

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    $T(n) ∈ \setLens{Val}{Val}$
  \item
    $T(3) \equiv [1, 2, 3, \circled{5}]$
  \end{itemize}
\item
  par champ

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    $F(l) ∈ \setLens{Val}{Val}$
  \item
    $F(y) \equiv \{ x: 0; y: \circled{-3} \}$
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Exemple : par variable ($V$)}

\[V(v) ∈ \setLens{Mem}{Val}\]

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Pour $m ∈ Mem$, $m = ((s_1, …, s_n), g)$
\end{itemize}

\begin{align*}
V(\texttt{Global}~x) &= \texttt{snd} \ggg L(x) \\
V(\texttt{Local}~(n, x)) &= \texttt{fst} \ggg I(n) \ggg L(x) \\
\end{align*}

\end{frame}

\begin{frame}{Exemple : par chemin ($Φ$)}

\[Φ(φ) ∈ \setLens{Mem}{Val}\]

\begin{align*}
    Φ(v)    &= V(v) \\
  Φ(φ.l)    &= Φ(φ) \ggg F(l) \\
  Φ(φ[i])   &= Φ(φ) \ggg T(i) \\
  \end{align*}

\end{frame}

\subsection{Types pointeurs}

\begin{frame}{Deux types de pointeurs}

\begin{itemize}
\item séparer deux types de pointeurs
\item pointeurs noyau : $\ptrK{t}$

  \begin{itemize}
  \item valeur fixée à la compilation ou par le runtime
  \item ex: \texttt{\&x}, \texttt{malloc(n)}
  \item peuvent être déréférencés (\texttt{*p}, \texttt{memcpy()})
  \end{itemize}
\item pointeurs utilisateur : $\ptrU{t}$

  \begin{itemize}
  \item valeur provient d'un utilisateur non privilégié
  \item ex: paramètres d'appels systèmes
  \item doivent être vérifiés dynamiquement!
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Règles de typage}
    \begin{mathpar}
       \irule{Lv-Deref}
         { Γ ⊢ \colK{e} : \colK{\ptrK{t}} }
         { Γ ⊢ \colK{*~e} : t }

       \irule{Addr}
         { Γ ⊢ lv : t }
         { Γ ⊢ \& lv : \colK{\ptrK{t}} }

       \irule{User-Get}
         { Γ ⊢ \colK{e_d} : \colK{\ptrK{t}}
        \\ Γ ⊢ \colU{e_s} : \colU{\ptrU{t}}
         }
         { Γ ⊢ \uGet{\colK{e_d}}{\colU{e_s}} : \tInt }

       \irule{User-Put}
         { Γ ⊢ \colU{e_d} : \colU{\ptrU{t}}
        \\ Γ ⊢ \colK{e_s} : \colK{\ptrK{t}}
         }
         { Γ ⊢ \uPut{\colU{e_d}}{\colK{e_s}} : \tInt }
    \end{mathpar}
\end{frame}

\begin{frame}{Sûreté du typage}

\begin{theorem}[Progrès]
  Supposons que $Γ ⊢ e : t$. Soit $m$ un état mémoire tel que $\mcomp{Γ}{m}$.
  Alors l'un des cas suivants est vrai:

\begin{itemize}
  \item $∃ v ≠ Ω, e = v$
  \item $∃ (e', m'), \mm{m}{e}{m'}{e'}$
  \item $∃ Ω ∈ \{\serr{div},\serr{array},\serr{ptr}\}, \msi{m}{e} → Ω$
\end{itemize}
\end{theorem}
\end{frame}

\begin{frame}{Sûreté du typage}

\begin{theorem}[Préservation]
    Si $Γ ⊢ e : t$ et $\mm{m}{e}{m'}{v}$,
    alors $\mcomp{Γ}{\cCleanup{m'}}$ et $m' ⊧ v : τ$ où $\tComp{τ}{t}$.
\end{theorem}
\end{frame}

\section{Expérimentation}

\subsection{Analyseur statique}

\begin{frame}

\begin{itemize}
\item 1600 lignes d'OCaml
\item utilise \newspeak (langage + compilateur)
\end{itemize}

\end{frame}

\begin{frame}{Mode de fonctionnement}

  \begin{itemize}
  \item compile vers un \texttt{.npk}
  \item enlève les types C
  \item infère des types plus sémantiques
  \end{itemize}
\end{frame}

\begin{frame}{Traduction: C} \insertcode{tc-c.c} \end{frame}
\begin{frame}{Traduction: sans les types} \insertcode{tc-ml.c} \end{frame}
\begin{frame}{Traduction: types inférés} \insertcode{tc-ty.c} \end{frame}

\begin{frame}
    \centering
      \begin{tabular}{ll}
          \toprule
          C/\newspeak & \langname \\
          \midrule
          \texttt{int} & $\tInt$ \\
          \texttt{unsigned long} & $\tInt$ \\
          \texttt{int *} (utilisé \texttt{x[i]}) & $\tInt~[~]$ \\
          \texttt{int *} (utilisé \texttt{*x}) & $\ptrK{\tInt}$ \\
          \texttt{int *} (argument syscall) & $\ptrU{\tInt}$ \\
          \bottomrule
      \end{tabular}
\end{frame}

\subsection{Utilisation sur le noyau Linux}

\begin{frame}{Analyse de 2 bugs}

    \begin{itemize}
        \item Radeon KMS
        \item \texttt{ptrace} Blackfin
    \end{itemize}
\end{frame}

\begin{frame}{Code avec bug}
    % left bottom right top
    \includegraphics[trim=2300 1430 100 500,clip,width=\textwidth]{poster.pdf}
\end{frame}

\begin{frame}[fragile]{Résultat de l'algorithme d'inférence}
\begin{SaveVerbatim}{drmko}
05-drm.c:17#10 - Type clash between :
  KPtr (_a15)
  UPtr (_a8)
\end{SaveVerbatim}

\textbf{Erreur}:

\codeout{drmko}
\end{frame}

\begin{frame}{Code corrigé}
    % left bottom right top
    \includegraphics[trim=2300 990 100 1220,clip,width=\textwidth]{poster.pdf}
\end{frame}

\begin{frame}[fragile]{Résultat de l'algorithme d'inférence}

\textbf{Programme complètement annoté}:

\begin{SaveVerbatim}{drmok}
(06-drm-ok.c:17#6)^{
  Int tmp_cir!0;
  (06-drm-ok.c:17#6)^tmp_cir!0 <-
    copy_from_user
      ( &(value) : KPtr (d),
        value_ptr_UPtr (d) : UPtr (d),
        4 : Int); }
\end{SaveVerbatim}

\codeout{drmok}
\end{frame}

\section{Perspectives}

\subsection{Contributions}

\begin{frame}{Contributions}
\begin{itemize}
\item Un langage impératif bien typé
\item Une sémantique basée sur les lentilles
\item Un système de types abstraits
\item Un prototype d'analyseur statique
\end{itemize}
\end{frame}

\subsection{Analyse à plus grande échelle}

\begin{frame}
    \begin{itemize}
        \item Comment détecter les appels système?
        \item \texttt{SYSCALL\_DEFINEx}, …
        \item le reste: \texttt{ioctl}s, FS, …
    \end{itemize}
\end{frame}

\subsection{Types abstraits}

\begin{frame}{Types abstraits : exemples}
    \begin{itemize}
        \item extension: comment le type est représenté
        \item intention: à quoi il sert
        \item \texttt{int}, \texttt{int32\_t}
        \item \texttt{off\_t}, \texttt{size\_t}, \texttt{intptr\_t}
        \item Types "numéro de ligne", "numéro de colonne"
    \end{itemize}
\end{frame}

\subsection{Conclusion}

\begin{frame}
    Merci

    Questions?
\end{frame}

\end{document}
