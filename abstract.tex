\begin{headingpage}
\thispagestyle{empty}

\begin{center}\Large \textbf{Résumé}\end{center}

Les noyaux de système d'exploitation manipulent des données fournies par
les programmes utilisateur via certaines interfaces, comme les appels système.
Si celles-ci sont manipulées sans prendre une attention particulière, des
failles de sécurité peuvent apparaître, comme des fuites de données
confidentielles ou l'elévation de privilège d'un attaquant.

Le but de cette thèse est d'utiliser des techniques de typage statique afin de
détecter les manipulations dangereuses de pointeurs contrôlés par l'espace
utilisateur.

De nombreux systèmes d'exploitation, dont le noyau Linux sur lequel nous nous
basons, sont écrits dans le langage C. Afin de pouvoir appliquer les techniques
de typage statique à ce langage, on commence par isoler un sous-ensemble sûr
nommé \langname, pour lequel on définit une sémantique opérationnelle et un
système de types. Les propriétés classiques de sûreté du typage sont établies.

Dans un second temps on étend \langname pour intégrer la notion de valeur
provenant de l'espace utilisateur. On montre que l'extension triviale du système
de types brise la sûreté du typage, et que l'on peut réétablir celle-ci en
donnant un type particulier aux pointeurs dont la valeur est contrôlée par
l'espace utilisateur, forçant leur déférencement à se faire au sein d'un
ensemble limités de fonction sûres. Un cas d'étude est déroulé pour montrer que
cette technique permet de détecter un bug qui a frappé un pilote de carte
graphique AMD dans le noyau Linux.

Ces travaux ouvrent des perspectives sur deux points. D'une part, il serait
possible d'appliquer à de plus grandes parties du noyau Linux. Les diverses
interfaces qui exposent des données contrôlées par l'espace utilisateur peuvent
bénéficier de cette vérification statique. Ceci est d'autant plus vrai que les
pilotes de périphériques dont elles sont issues sont en général moins testées
que le reste du code du noyau. D'autre part, cette technique revient à
introduire des types abstraits opaques, séparant leur représentation de leur
interface. Ce concept étant absent de C, de nombreuses erreurs de programmation
notamment liées aux manipulations d'entiers peuvent également être vérifiées à
l'aide de cette méthode.

\begin{center}\Large \textbf{Abstract}\end{center}

Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh
euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad
minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut
aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in
vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla
facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent
luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Nam liber
tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod
mazim placerat facer possim assum. Typi non habent claritatem insitam; est usus
legentis in iis qui facit eorum claritatem. Investigationes demonstraverunt
lectores legere me lius quod ii legunt saepius. Claritas est etiam processus
dynamicus, qui sequitur mutationem consuetudium lectorum. Mirum est notare quam
littera gothica, quam nunc putamus parum claram, anteposuerit litterarum formas
humanitatis per seacula quarta decima et quinta decima. Eodem modo typi, qui
nunc nobis videntur parum clari, fiant sollemnes in futurum

%\begin{center}\Large \textbf{Abstract}\begin{center}

% TODO (PLAS suit)

%Manipulating user-provided pointers in the kernel of an operating system can
%lead to security flaws if done in an incautious manner. We present an efficient
%system to detect and prevent this class of erroneous memory manipulation.

%At the core of our approach is \langname, an imperative language that we equip
%with a qualified type system, where two kinds of pointers are distinguished:
%\emph{safe} pointers, whose value is statically proved to be controlled by the
%kernel, and \emph{unsafe} ones, whose value comes from userspace through
%run-time system calls. Dereferencing unsafe pointers is forbidden in a static
%manner by the means of a strong type system.

%A concrete case study is described based on a bug that affected a video driver
%in the Linux kernel. We also explain a technique to automatically translate GNU
%C code to our core language, which will enable us to analyze larger fractions of
%the kernel in order to find similar vulnerabilities.

\end{headingpage}
