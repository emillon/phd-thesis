\section{État de l'art}%{{{

\begin{itemize}
\item
Les pointeurs sur fonction rendent floue la limite qui est habituellement
présente entre instructions et données. En leur présence il est impossible de
faire une analyse de flot de contrôle indépendante du flot de données. Pour
pouvoir les traiter, il faut que le domaine abstrait en question soit assez
précis pour qu'un pointeur abstrait se concrétise en un ensemble réduit de
fonctions. Dans le cas où le domaine ne peut pas borner l'ensemble des fonctions
possibles et renvoie $\top$, l'analyse ne peut pas continuer.

\item
L'allocation dynamique de données, présente dans le langage C par le biais des
fonctions \texttt{malloc} et \texttt{free}, modifie le modèle mémoire
nécessaire. Sans celle-ci, l'ensemble des zones mémoire possibles peut être
décrit statiquement : ce sont les noms de variable. Ce qu'introduit
\texttt{malloc} au langage, c'est une zone mémoire qui n'a pas de nom, et sur
laquelle on n'a qu'un pointeur.

% TODO, bof + expand

\item
Le transtypage (\emph{casts}) entre entiers et pointeurs est particulièrement
délicat à traiter. Dans les modèles abstraits, les pointeurs sur données ou sur
fonctions n'ont pas de représentation numérique, seulement une représentation
symbolique. Même dans l'exécution concrète, la représentation numérique d'un
pointeur est lié à de nombreux choix faits par l'environnement d'exécution
(comme la randomisation de l'espace d'adressage) qui ne peuvent pas facilement
être modélisés.

\item
Les nombres flottants (types \texttt{float}, \texttt{double} et \texttt{long
double}) ont une sémantique particulière, et il n'est pas correct d'approcher
leur sémantique par une sémantique dans $ℝ$. Afin d'être correct, il faut
établir des domaines spécifiques au flottant, comme~\cite{floatpoly}. Un tour
d'horizon des difficultés liées aux flottants est effectué
dans~\cite{floatpitfalls}.

\end{itemize}

% TODO [E] setjmp/longjmp, unions
% difficultés : récursion

%}}}

\section{Évaluateur} % {{{

\begin{itemize}
\item Exp-AddrOf sur toutes les lv
\item figures gramdef : singulier ou pluriel?
\end{itemize}

Limitations :

\begin{itemize}
\item tableaux de taille dynamique ?
\end{itemize}

\subsection*{Extrait PLAS}



% }}}

\section{Typage}%{{{

\subsection*{Fonctions}

\begin{itemize}
\item
  page 50 règle CALL une remarque disant que cette règle doit être
  utilisée avec une autre qui va typer le corps de la fonction (mettre
  la ref) parce que sinon ça surprend
\item
  5.5 le fait de choisir une unique variable R t'oblige à ajouter une
  opération de suppression du R de la fonction appelante factice.
  Pourquoi ne pas générer des variables fraîches à partir du nom de la
  fonction + un identifiant unique ?
\item
  lemme 5.1 cas fonction, à quoi ça sert d'introduire la notation t'
  alors qu'il n'apparaît pas dans une règle ?
\end{itemize}

\subsection*{Rq}
(passe Sarah 17/01)

\begin{itemize}
\item
  p53 le terme de dérivation (première phrase de la preuve) n'a jamais
  été expliqué ?
\item
  lemme 5.1 constantes. Il faut expliquer à quel ensemble n et f
  appartiennent
\item
  lemme 5.2 même remarque que 5.1 concernant n et f (plus confusion f
  float et f fonction)
\item
  lemme 5.3 ça ne marche que si une variable n'apparaît qu'une fois dans
  le contexte ou avec toujours le même type (cf rem ci-dessous sur 5.3)
\item
  il manque les preuves de 5.3 et 5.4
\item
  théormèe 5.2 rappeler où a été défini l'évaluation d'une expression et
  dans quel cas elle produit des valeurs
\end{itemize}%}}}

\section{Qualificateurs}

Sarah 13/02

\begin{itemize}
\item
\item
  6.2 pourquoi ne pas nommer cette extension de C\_ML
\item
  3ème parag 6.3 choisir entre «qui représente» et «qui contrôle»
\item
  idem figure 6.2 ça serait plus clair de remettre tout
\end{itemize}

\section*{Extrait PLAS}

The main distinctiveness is that instead of having a plain pointer type
$t~*$, our one is decorated with a type qualifier $q$. This annotation expresses
who controls the value of the pointer. If the kernel controls the value of the
pointer, then it cannot be abused. On the other hand, one has to be careful
with user-controlled pointers, because the caller can abuse the kernel and
access reserved memory. The only safe case when dereferencing such a pointer is
if its value is outside the kernel's memory.

In order to avoid dangerous cases, we have to dynamically check that the
destination of every user-controlled pointer is in userspace. Kernel pointers
(that is to say, kernel-controlled pointers) can be dereferenced without further
check, but user pointers have to be manipulated with a restricted interface that
will check whether their destination is in userspace.

As mentioned before, this is done using the following constructs:%
{\small
\begin{mathpar}
    \disprule{GetU}

    \disprule{PutU}
\end{mathpar}}%
To add qualifiers to a type system, the rules of interest are those that
manipulate pointers: dereferencing, pointer arithmetic and referencing (taking
the address of a left-value).

Dereferencing the easiest one ; our goal is to authorize dereferencing only
\qKernel pointers:

{\small \[ \disprule{Lv-Deref} \]}%

Pointer arithmetic can be done inside a \qUser or \qKernel memory zone. There is
no concern of jumping from userspace to kernelspace, because pointer arithmetic
is checked at runtime: if these operators overflow or are applied to a bad
pointer (such as a pointer to an integer field), $\serr{ptr}$ is raised.

{\small \[ \disprule{Ptr-Arith} \]}%

The reference case is trickier because a type qualifier has to be synthesized.
Because it is created on the kernel stack, it has a \qKernel qualifier in all
cases:
{\small \[
  \disprule{Addr}
\]}%

The $\eTaint{\cdot}$ operator turns a \qUser pointer into a \qKernel pointer.
It is an important rule, because it is the only source of \qUser pointers in the
type system.

The return value of a function is emulated with a virtual left-value $\vRet$.%
{\small \begin{mathpar}
  \disprule{Return}

  \disprule{Fun}
\end{mathpar}}%%}}}

\section{Étude de cas}%{{{

Le paramètre \texttt{data} provient de l'espace utilisateur via un appel
système. Un appelant malveillant peut se servir de cette fonction pour lire la
mémoire du noyau à travers le message d'erreur.

Le problème est modélisé de la façon suivante : on associe à chaque variable
\texttt{x} un type de données \texttt{t}, ce que l'on note \texttt{x:t}. En
plus des types présents dans le langage C, on ajoute une distinction
supplémentaire pour les pointeurs. D'une part, les pointeurs «noyau» (de type
\texttt{t~*}) sont créés en prenant l'adresse d'un objet présent dans le code
source. D'autre part, les pointeurs «utilisateurs» (leur type est noté
\texttt{t user*}) proviennent des interfaces avec l'espace utilisateur.

Il est sûr de déréférencer un pointeur noyau, mais pas un pointeur
utilisateur. L'opérateur \texttt{*} prend donc un \texttt{t *} en entrée
et produit un \texttt{t}.

Pour faire la vérification de type sur le code du programme, on a besoin de
quelques règles. Tout d'abord, les types suivent le flot de données.
C'est-à-dire que si on trouve dans le code \texttt{a = b}, \texttt{a} et
\texttt{b} doivent avoir un type compatible. Ensuite, le qualificateur
\texttt{user} est récursif : si on a un pointeur utilisateur sur une structure,
tous les champs pointeurs de la structure sont également utilisateur. Enfin, le
déréférencement s'applique aux pointeurs noyau seulement : si le code contient
l'expression \texttt{*x}, alors il existe un type \texttt{t} tel que
\texttt{x:t*} et \texttt{*x:t}.

Appliquons ces règles à l'exemple de la figure~X : on suppose que l'interface
avec l'espace utilisateur a été correctement annotée. Cela permet de déduire que
\texttt{data:void user*}. En appliquant la première règle à la ligne 6, on en
déduit que \texttt{info:struct drm\_radeon\_info user*} (comme en C, on peut
toujours convertir de et vers un pointeur sur \texttt{void}).

Pour déduire le type de \texttt{value\_ptr} dans la ligne 7, c'est la
deuxième règle qu'il faut appliquer : le champ \texttt{value} de
la structure est de type \texttt{uint32\_t~*} mais on y accède à travers
un pointeur utilisateur, donc \texttt{value\_ptr:uint32\_t user*}.

% faux

À la ligne 8, on peut appliquer la troisième règle : à cause du déréférencement,
on en déduit que \texttt{value\_ptr:t *}, ce qui est une contradiction puisque
d'après les lignes précédentes, \texttt{value\_ptr:uint32\_t user*}.

Si la ligne 3 était remplacée par l'appel à \texttt{copy\_from\_user}, il n'y
aurait pas d'erreur de typage car cette fonction peut accepter les arguments
\texttt{(uint32\_t~*, uint32\_t user*, size\_t)}.

Le principe de cette technique (associer des types aux valeurs puis restreindre
les opérations sur certains types) peut être repris. Par exemple, si on définit
un type «numéro de bloc» comme étant un nouvel alias de \texttt{int}, on peut
considérer que multiplier deux telles valeurs est une erreur.%}}}

% Sarah 9/5

%chapeau de l'intro
%- manque de structures/liens entre les petits paragraphes.

%1.2
    %- tu pourrais ajouter un ex d'appel système en C pour expliquer le pb du déréférencement

%1.3
   %- typage fort et faible. On ne comprend pas la différence
   %- manquent des mots dans la dernière phrase de cette partie

%1.4
  %- pourquoi parler de C++ et Ada alors que tu ne vas traiter que le C ?

%1.5

%- il faudrait pour chaque front-end dire pourquoi ça n'est pas la solution retenue

%Pourquoi ne pas présenter informellement le cas d'étude dans l'intro
%pour montrer que de vrais bugs existent ?

% Emmanuel 6/5

  %Sur la première partie, je dirai que le point le plus important est de
  %justifier ta proposition à la fin du ch +apitre 3,
