\gramlr{Programmes}{
\begin{align*}
P \gramisa & (\vec{f}, \vec{v}, b) & \textrm{Fonctions, globales, initialiseur}
\end{align*}
}

\gramlr{Expressions}{
\begin{align*}
e  \gramisa & lv     & \textrm{Left-value}
\\ \gramor  & op~e   & \textrm{Opération unaire}
\\ \gramor  & e~op~e & \textrm{Opération binaire}
\\ \gramor  & cst    & \textrm{Constante}
\\ \gramor  & \& lv  & \textrm{Pointeur sur donnée}
\\ \gramor  & \& f   & \textrm{Pointeur sur fonction}
\end{align*}
}

\gramlr{Left-values}{
\begin{align*}
lv \gramisa & var      & \textrm{Variable}
\\ \gramor  & lv.champ & \textrm{Accès à un champ}
\\ \gramor  & lv[e]    & \textrm{Accès à un tableau}
\\ \gramor  & *e       & \textrm{Déréférencement}
\end{align*}
}

\gramlr{Blocs}{
\begin{align*}
b  \gramisa & i ; b & \textrm{Séquence}
\\ \gramor  & ε     & \textrm{Bloc vide}
\end{align*}
}

\gramlr{Instructions}{
\begin{align*}
i  \gramisa & lv \leftarrow e             & \textrm{Affectation}
\\ \gramor  & lv \leftarrow funexp (args) & \textrm{Appel de fonction}
\\ \gramor  & funexp (args)               & \textrm{Appel de procédure}
\\ \gramor  & \uparrow nom \{ b \}        & \textrm{Déclaration}
\\ \gramor  & if (e) \{ b \} else \{ b \} & \textrm{Alternative}
\\ \gramor  & \{ b \} label:              & \textrm{Nommage de bloc}
\\ \gramor  & \npkGoto{label}             & \textrm{Saut en avant}
\\ \gramor  & forever \{ b\}              & \textrm{Boucle infinie}
\\ \gramor  & return e                    & \textrm{Retour de fonction}
\end{align*}
}

\todo{Fonctions}
