\def\disprule#1{
  \switch{#1}
    {Cst-Int}{ \irule{Cst-Int}
                 { }
                 { Γ ⊢ i : \tInt}
    }
    {Cst-Float}{ \irule{Cst-Float}
                   { }
                   { Γ ⊢ d : \tFloat}
    }
    {Cst-Null}{ \irule{Cst-Null}
                  { }
                  { Γ ⊢ \eNull : t*}
    }
    {Cst-Unit}{ \irule{Cst-Unit}
                  { }
                  { Γ ⊢ \eUnit : \tUnit }
    }
    {Lv-Var}{ \irule{Lv-Var}
                { x : t ∈ Γ }
                { Γ ⊢ x : t }
    }
    {Lv-Deref}{ \irule{Lv-Deref}
                  { Γ ⊢ lv : t* }
                  { Γ ⊢ *lv : t }
    }
    {Lv-Index}{ \irule{Lv-Index}
                  { Γ ⊢ e : \tInt \\
                    Γ ⊢ lv : t[]
                  }
                  { Γ ⊢ lv[e] : t }
    }
    {Lv-Field}{ \irule{Lv-Field}
                  { (s, l, t_l) ∈ S \\
                    Γ ⊢ lv : \tstruct{s}
                  }
                  { Γ ⊢ lv.l : t_l }
    }
    {Op-Int}{ \irule{Op-Int}
                { \opbin ∈ \{+,-,\times,/,\&,|,\opxor,\&\&,||,\ll,\gg \} \\
                  Γ ⊢ e_1 : \tInt \\
                  Γ ⊢ e_2 : \tInt
                }{
                  Γ ⊢ e_1~\opbin~e_2 : \tInt
                }
    }
    {Op-Float}{ \irule{Op-Float}
                { \opbin ∈ \{+.,-.,\times.,/.\} \\
                  Γ ⊢ e_1 : \tFloat \\
                  Γ ⊢ e_2 : \tFloat
                }{
                  Γ ⊢ e_1~\opbin~e_2 : \tFloat
                }
    }
    {Eq-Num}{ \irule{Eq-Num}
                {t ∈ \{ \tInt, \tFloat \}}
                {\textsc{Eq}(t)}
    }
    {Eq-Ptr}{ \irule{Eq-Ptr}
                {\textsc{Eq}(t)}
                {\textsc{Eq}(t*)}
    }
    {Eq-Array}{ \irule{Eq-Array}
                  {\textsc{Eq}(t)}
                  {\textsc{Eq}(t[])}
    }
    {Op-Eq}{ \irule{Op-Eq}
             { \opbin ∈ \{=,≠\} \\
               Γ ⊢ e_1 : t \\
               Γ ⊢ e_2 : t \\
               \textsc{Eq}(t)
             }{
               Γ ⊢ e_1~\opbin~e_2 : \tInt
             }
    }
    {Op-Comparable}{ \irule{Op-Comparable}
                       { \opbin ∈ \{=,≠,≤,≥,<,>\} \\
                         Γ ⊢ e_1 : t \\
                         Γ ⊢ e_2 : t \\
                         t ∈ \{ \tInt, \tFloat \}
                       }{
                         Γ ⊢ e_1~\opbin~e_2 : \tInt
                       }
    }
    {Unop-Plus-Int}{ \irule{Unop-Plus-Int}
                       { Γ ⊢ e : \tInt }
                       { Γ ⊢ + e : \tInt }
    }
    {Unop-Plus-Float}{ \irule{Unop-Plus-Float}
                         { Γ ⊢ e : \tFloat }
                         { Γ ⊢ +. e : \tFloat }
    }
    {Unop-Minus-Int}{ \irule{Unop-Minus-Int}
                        { Γ ⊢ e : \tInt }
                        { Γ ⊢ - e : \tInt }
    }
    {Unop-Minus-Float}{ \irule{Unop-Minus-Float}
                          { Γ ⊢ e : \tFloat }
                          { Γ ⊢ -. e : \tFloat }
    }
    {Unop-Not}{ \irule{Unop-Not}
                { \opun ∈ \{ \sim, ! \} \\
                  Γ ⊢ e : \tInt
                }{
                  Γ ⊢ \opun~e : \tInt
                }
              }
    {Ptr-Arith}{ \irule{Ptr-Arith}
                   { \opbin ∈ \{ +_p, -_p \} \\
                     Γ ⊢ e_1 : t* \\
                     Γ ⊢ e_2 : \tInt \\
                   }
                   { Γ ⊢ e_1~\opbin~e_2 : t* }
               }
    {Addr}{ \irule{Addr}
              { Γ ⊢ lv : t }
              { Γ ⊢ \&lv : t* }
          }
    {Set}{ \irule{Set}
             { Γ ⊢ lv : t \\
               Γ ⊢ e : t
             }
             { Γ ⊢ lv ← e : t }
         }
    {Array}{ \irule{Array}
               { ∀ i ∈ [1;n] , Γ ⊢ e_i : t }
               { Γ ⊢ \{ e_1 ;
                       … ; e_n \}
                       : t[]
               }
           }
    {Struct}{ \irule{Struct}
                { ∀ i ∈ [1;n], Γ ⊢ e_i : t_i \\
                  ∀ i ∈ [1;n], (s, l_i, t_i) ∈ S
                }
                { Γ ⊢ \{ l_1 : e_1 ;
                     … ; l_n : e_n \}
                    : \tstruct{s}
                }
            }
    {Call}{ \irule{Call}
              { Γ ⊢ e : ( t_1 ,
                         … , t_n ) → t \\
                ∀ i ∈ [1;n], Γ ⊢ e_i : t_i
              }
              { Γ ⊢ e ( e_1
                         , …
                         , e_n
                         )
                      : t
              }
          }
    {Pass}{ \irule{Pass}
              { }
              {Γ ⊢ \iPass}
          }
    {Seq}{ \irule{Seq}
             { Γ ⊢ i_1 \\
               Γ ⊢ i_2
             }{
               Γ ⊢ i_1;i_2
             }
         }
    {Exp}{ \irule{Exp}
             { Γ ⊢ e : t }
             { Γ ⊢ e }
         }
    {If}{ \irule{If}
            { Γ ⊢ e : \tInt \\
              Γ ⊢ i_1 \\
              Γ ⊢ i_2
            }
            { Γ ⊢ \iIf{e}{i_1}{i_2} }
        }
    {While}{ \irule{While}
               { Γ ⊢ e : \tInt \\
                 Γ ⊢ i
               }
               { Γ ⊢ \iWhile{e}{i} }
           }
    {Return}{ \irule{Return}
                { Γ ⊢ \vRet ← e }
                { Γ ⊢ \iReturn{e} }
            }
    {Fun}{ \irule{Fun}
             { Γ' = (Γ - \vRet), a_1 : t_1, …, a_n : t_n,
                    l_1 : t'_1, …, l_n : t'_p,
                    \vRet : t \\
               ∀ i ∈ [1;p], Γ ⊢ e_i : t'_i \\
               Γ' ⊢ i
             }
             { Γ ⊢ \mathrm{fun} (a_1, …, a_n)
                   ((l_1, e_1), …, (l_p, e_p)) \{i\}
                    : (t_1, …, t_n) → t
             }
         }
    {Ph-Exp}{ \irule{Ph-Exp}
                { Γ ⊢ e : t }
                { \typh{Γ}{e}{Γ} }
            }
    {Ph-Var}{ \irule{Ph-Var}
                { Γ ⊢ e : t \\
                  Γ' = (x, t), Γ
                }
                { \typh{Γ}{p}{Γ'} }
            }
    {Ph-Struct}{ \irule{Ph-Struct}
                   { S' =
                     (x_1, t_1, s),
                     …
                     (x_n, t_n, s)
                   }
                   { \typh{Γ}{ \tstruct{s}
                                  \{ x_1 : t_1
                                   ; …
                                   ;  x_n : t_n
                                  \}
                              }{Γ}
                   }
               } % TODO
    {END}
}

\def\semrule#1{
  \switch{#1}
    {Ctx}{ \irule{Ctx}
             { \mm{m}{e}{m'}{e'} }
             { \mm{m}{\ctxSub{C}{e}}{m'}{\ctxSub{C}{e'}} }
    }
    {Ctx-Lv}{ \irule{Ctx-Lv}
             { \mmlv{m}{lv}{m'}{lv'} }
             { \mmlv{m}{\ctxSubL{C_L}{lv}}{m'}{\ctxSubL{C_L}{lv'}} }
    }
    {Ctx-Instr}{ \irule{Ctx-Instr}
             { \mmlv{m}{i}{m'}{i'} }
             { \mmlv{m}{\ctxSubI{C_I}{i}}{m'}{\ctxSubI{C_I}{i'}} }
    }
    {Phi-Var}{ \irule{Phi-Var}
                 { a = \mathrm{Lookup}(x, m) }
                 {
                   \mmlv{m}{x}{m}{a}
                 }
    }
    {Phi-Deref}{ \irule{Phi-Deref}
                   { }
                   { \mms{*φ}{\widehat{*}φ} }
    }
    {Phi-Struct}{ \irule{Phi-Struct}
                    {  }
                    { \mms{lv.l}{lv\widehat{.}l} }
    }
    {Phi-Array}{ \irule{Phi-Array}
                   { }
                   { \mms{φ[n]}{φ\widehat{[n]}} }
    }
    {Exp-Cst}{ \irule{Exp-Cst}
                 { }
                 {\mms{c}{\widehat{c}}}
             }
    {Exp-Fun}{ \irule{Exp-Fun}
                 { }
                 {\mms{f}{\widehat{f}}}
             }
    {Exp-Lv}{ \irule{Exp-Lv}
              { }
              {\mm{m}{φ}{m}{m[φ]_Φ}}
    }
    {Exp-UnOp}{ \irule{Exp-UnOp}
                { }
                {\mms{\opun~v}{\widehat{\opun}~v}}
    }
    {Exp-BinOp}{ \irule{Exp-BinOp}
                   { \opbin ∉ \{/, \%\} }
                   {\mms{v_1~\opbin~v_2}{v_1~\widehat{\opbin}~v_2}}
    }
    {Exp-Div}{ \irule{Exp-Div}
                 { \opbin ∈ \{/, \%\} \\
                   v_2 ≠ \widehat{0}
                 }
                 {\mms{v_1~\opbin~v_2}{v_1~\widehat{\opbin}~v_2}}
    }
    {Exp-Div-Zero}{ \irule{Exp-Div-Zero}
                 { \opbin ∈ \{/, \%\}
                 }
                 {\msi{m}{v_1~\opbin~0} → Ω_{div}}
    }
    {Exp-AddrOf}{ \irule{Exp-AddrOf}
                    { a = \mathrm{Lookup} (x, m)
                    }
                    {\mm{m}{\&x}{m}{a}}
    }
    {Exp-Set}{ \irule{Exp-Set}
                 { }
                 {\mm{m}{φ ← v}{m[φ ← v]}{v}}
    }
    {Exp-Struct}{ \irule{Exp-Struct}
                   { }
                   { \mms{ \{ l_1 : v_1 ; … ; l_n : v_n \} }
                         { \widehat{\{ l_1 : v_1 ; … ; l_n : v_n \}} }
                   }
    }
    {Exp-Array}{ \irule{Exp-Array}
                 { }
                 {
                   \mms{ [ v_1, … , v_n ] }
                       { \widehat{[ v_1, … , v_n ]} }
                 }
    }
    {Exp-Call}{ \irule{Exp-Call}
                  { f =
                    \mathrm{fun} (a_1, …, a_n)
                                 ((l'_1, e'_1), …, (l'_p, e'_p))
                                 \{ i \} \\
                    m_1 = \mathrm{Push}(m_0, ((a_1, v_1), …, (a_n, v_n))) \\
                    \evstar{m_1}{e'_1 \\ \vdots \\ e'_p}
                           {m_2}{v'_1 \\ \vdots \\ v'_p} \\
                    m_3 = \mathrm{Extend}(m_2, ((l_1, v_1), …, (l_n, v_n))) \\
                    \mm{m_3}{i}{m_4}{\iReturn{v}} \\
                    m_5 = \mathrm{Pop}(m_4) \\
                    m_6 = \mathrm{Cleanup}(m_5) \\
                  }
                  {\mm{m_0}{f (v_1, …, v_n)}{m_6}{v}}
    }
    {Seq}{ \irule{Seq}
             { \mmi{m}{i}{m'}{\iPass} }
             { \mmi{m}{(i;i')}{m'}{i'} }
    }
    {Pass}{ \irule{Pass}
              { }
              { \mmi{m}{(\iPass;i)}{m}{i} }
    }
    {Exp}{ \irule{Exp}
             { }
             { \mmi{m}{v}{m}{\iPass} }
    }
    {If-False}{ \irule{If-False}
                  { }
                  { \mmi{m}{\iIf{0}{i_t}{i_f}}{m}{i_f} }
    }
    {If-True}{ \irule{If-True}
                 { v ≠ 0 }
                 { \mmi{m}{\iIf{v}{i_t}{i_f}}{m}{i_t} }
    }
    {While}{ \irule{While}
               { }
               { \mmi{m}{\iWhile{e}{i}}{m}{\iThen{e}{i;\iWhile{e}{i}}}
               }
    }
    {Return}{ \irule{Return}
              { }
              { \mmi{m}{\iReturn{v};i}{m}{\iReturn{e}} }
    }
    {Ph-Struct}{ \irule{Ph-Struct}
                   { }
                   {\ph{m}{\tstruct{s} \{ … \}}{m}}
    }
    {Ph-Exp}{ \irule{Ph-Exp}
                {\mm{m}{e}{m'}{v}}
                {\ph{m}{e}{m'}}
            }
    {Ph-Var}{ \irule{Ph-Var}
                {\mm{m}{e}{m'}{v}}
                {\ph{(s,g)}{x = e}{(s, (x, v)::g)}}
    }
    {Ph*-Nil}{ \irule{Ph*-Nil}
                 { }
                 {\phstar{m}{[]}{m}}
    }
    {Ph*-Cons}{ \irule{Ph*-Cons}
                  {\ph{m}{p}{m'} \\
                   \phstar{m'}{ps}{m''}}
                  {\phstar{m}{p::ps}{m''}}
    }
    {END}
}

\def\figctx{
  \gramlr{Contextes}{
  \begin{align*}
  C \gramisa & C_L
  \\ \gramor & \ctxOp{C}{e}
  \\ \gramor & \ctxOp{v}{C}
  \\ \gramor & \ctxUnOp{C}
  \\ \gramor & \ctxSet{C}{e}
  \\ \gramor & \ctxSet{φ}{C}
  \\ \gramor & \{ l_1:v_1 ; … ; l_i:C ; … ; l_n:e_n \}
  \\ \gramor & [ v_1 ; … ; C ; … ; e_n ]
  \\ \gramor & C (e_1, …, e_n)
  \\ \gramor & f (v_1, …, C, …, e_n)
  \\
  \\
  C_L \gramisa & \ctxEmpty
  \\   \gramor & \ctxLvDeref{C_L}
  \\   \gramor & \ctxLvField{C_L}{l}
  \\   \gramor & \ctxLvIndex{C_L}{e}
  \\   \gramor & \ctxLvIndex{φ}{C}
  \\
  \\
  C_I \gramisa & C_I;i
  \\   \gramor & \iIf{C}{i_1}{i_2}
  \\   \gramor & \iReturn{C}
  \\   \gramor & C
  \end{align*}
  }
}
