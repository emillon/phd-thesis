\documentclass{phdthesis}

\input{pkg.tex}
\input{defs.tex}
\input{unicode.tex}

\usetikzlibrary{calc}
\usetikzlibrary{shapes}

\usepackage{fancyvrb}
\input{gen/pygments-style.tex}

\addtolength{\parskip}{\baselineskip}

\title{Titre}
\author{Étienne Millon}

\begin{document}

%\maketitle

\tableofcontents

\chapterstar{Introduction}

\part{Problématique}

\chapter{Isolation mémoire dans un système d'exploitation}

\section{Contexte}

x86, 32 bits, Linux.

\cite{UnderstandingTheLinuxKernel}

\section{Rôle d'un système d'exploitation}

\cite{tanenbaum} Mémoire, processus, périphériques, fichiers.

\section{Espace noyau, espace utilisateur}

\section{Cas de Linux}

\section{Appels système}

\chapter{Cas d'étude}

\section{Description du problème}

% But
% What you're trying to tell the audience that they don't already know (e.g. Your story.)

Un système d'exploitation moderne comme GNU/Linux est séparé en deux niveaux de
privilèges : le noyau, qui gère directement le matériel, et les applications de
l'utilisateur, qui communiquent avec le noyau par l'interface restreinte des
\emph{appels système}.

Pour assurer l'isolation, ces deux parties n'ont pas accès aux mêmes zones
mémoire (cf. figure~\ref{fig:memmap}).

% Figure memmap {{{l
\begin{figure}
\centering
\fbox{
\begin{tikzpicture}
  [scale=0.7
  ,user/.style={fill=black!20}
  ,kernel/.style={fill=black!70}
  ]

  % Memory zone
  %
  % #1 - start
  % #2 - end
  % #3 - color
  \newcommand{\mzone}[3]{
    \path[#3] (#1,0) rectangle (#2,1);
  }

  % Address label
  %
  % #1 - x position
  % #2 - text
  \newcommand{\alabel}[2]{
    \path (#1,1) -- ++(0,0.3) node [pos=1] {\small \tt #2};

  }

  % exec
  \mzone{0.5}{1}{user}

  % lib
  \mzone{2.5}{3.2}{user}

  % stack
  \mzone{3.7}{4}{user}

  % stack
  \mzone{5}{5.5}{user}

  % kernel
  \mzone{6}{8}{kernel}

  % contour
  \draw (0,0) rectangle (8,1);

  \alabel{0}{0}
  \alabel{6}{3 Go}
  \alabel{8}{4 Go}

\end{tikzpicture}
}

\caption{L'espace d'adressage d'un processus. En gris clair, les zones
accessibles à tous les niveaux de privilèges : code du programme, bibliothèques,
tas, pile. En gris foncé, la mémoire du noyau, réservée au mode privilégié.}

\label{fig:memmap}
\end{figure}
% }}}

Si le code utilisateur tente d'accéder à la mémoire du noyau, une erreur sera
déclenchée. En revanche, si cette écriture est faite au sein de l'implantation
d'un appel système, il n'y aura pas d'erreur puisque le noyau a accès à toute la
mémoire : l'isolation aura donc été brisée.

Pour celui qui implante un appel système, il faut donc empêcher qu'un pointeur
passé en paramètre référence le noyau. Autrement dit, il est indispensable de
vérifier dynamiquement que la zone dans laquelle pointe le paramètre est
accessible par l'appelant\cite{hardy88confused}.

Si au contraire un tel pointeur est déréférencé sans vérification (avec
\texttt{*} ou une fonction comme \texttt{memcpy}), le code s'exécutera
correctement mais en rendant le système vulnérable, comme le montre la
figure~\ref{fig:radeon-bug}.

% Figure bug {{{
\begin{figure}
  \insertcode{radeon-buggy.c}

  \caption{Bug freedesktop.org \#29340. Le paramètre \texttt{data} provient de
    l'espace utilisateur via un appel système. Un appelant malveillant peut se
    servir de cette fonction pour lire la mémoire du noyau à travers le message
    d'erreur.}

  \label{fig:radeon-bug}
\end{figure}
% }}}

Pour éviter cela, le noyau fournit un ensemble de fonctions qui permettent de
vérifier dynamiquement la valeur d'un pointeur avant de le déréférencer. Par
exemple, dans la figure précédente, la ligne 8 aurait dû être remplacée par :

\begin{Verbatim}
copy_from_user(&value, value_ptr, sizeof(value));
\end{Verbatim}

L'analyse présentée ici permet de vérifier automatiquement et statiquement que
les pointeurs qui proviennent de l'espace utilisateur ne sont déréférencés qu'à
travers une de ces fonctions sûres.

\section{Principes de l'analyse}

% Why the audience should believe that the results you've got aren't made up or
% flawed
Le problème est modélisé de la façon suivante : on associe à chaque variable
\texttt{x} un type de données \texttt{t}, ce que l'on note \texttt{x:t}. En
plus des types présents dans le langage C, on ajoute une distinction
supplémentaire pour les pointeurs. D'une part, les pointeurs ``noyau'' (de type
\texttt{t~*}) sont créés en prenant l'adresse d'un objet présent dans le code
source. D'autre part, les pointeurs ``utilisateurs'' (leur type est noté
\texttt{t user*}) proviennent des interfaces avec l'espace utilisateur.

Il est sûr de déréférencer un pointeur noyau, mais pas un pointeur
utilisateur. L'opérateur \texttt{*} prend donc un \texttt{t *} en entrée
et produit un \texttt{t}.

Pour faire la vérification de type sur le code du programme, on a besoin de
quelques règles. Tout d'abord, les types suivent le flot de données.
C'est-à-dire que si on trouve dans le code \texttt{a = b}, \texttt{a} et
\texttt{b} doivent avoir un type compatible. Ensuite, le qualificateur
\texttt{user} est récursif : si on a un pointeur utilisateur sur une structure,
tous les champs pointeurs de la structure sont également utilisateur. Enfin, le
déréférencement s'applique aux pointeurs noyau seulement : si le code contient
l'expression \texttt{*x}, alors il existe un type \texttt{t} tel que
\texttt{x:t*} et \texttt{*x:t}.

Appliquons ces règles à l'exemple de la figure \ref{fig:radeon-bug} : on suppose
que l'interface avec l'espace utilisateur a été correctement annotée. Cela
permet de déduire que \texttt{data:void user*}. En appliquant la première règle
à la ligne 6, on en déduit que \texttt{info:struct drm\_radeon\_info user*}
(comme en C, on peut toujours convertir de et vers un pointeur sur
\texttt{void}).

Pour déduire le type de \texttt{value\_ptr} dans la ligne 7, c'est la
deuxième règle qu'il faut appliquer : le champ \texttt{value} de
la structure est de type \texttt{uint32\_t~*} mais on y accède à travers
un pointeur utilisateur, donc \texttt{value\_ptr:uint32\_t user*}.

À la ligne 8, on peut appliquer la troisième règle : à cause du déréférencement,
on en déduit que \texttt{value\_ptr:t *}, ce qui est une contradiction puisque
d'après les lignes précédentes, \texttt{value\_ptr:uint32\_t user*}.

Si la ligne 3 était remplacée par l'appel à \texttt{copy\_from\_user}, il n'y
aurait pas d'erreur de typage car cette fonction peut accepter les arguments
\texttt{(uint32\_t~*, uint32\_t user*, size\_t)}.

\section{Implantation}

Une implantation est en cours. Le code source est d'abord prétraité par
\texttt{gcc -E} puis converti en Newspeak~\cite{newspeak}, un langage destiné à
l'analyse statique. Ce traducteur peut prendre en entrée tout le langage C, y
compris de nombreuses extensions GNU utilisées dans le noyau. En particulier,
l'exemple de la figure~\ref{fig:radeon-bug} peut être analysé.

À partir de cette représentation du programme et d'un ensemble d'annotations
globales, on propage les types dans les sous-expressions jusqu'aux feuilles.

Si aucune contradiction n'est trouvée, c'est que le code respecte la propriété
d'isolation. Sinon, cela peut signifier que le code n'est pas correct, ou bien
que le système de types n'est pas assez expressif pour le code en question.

Le prototype, disponible sur \url{http://penjili.org}, fera l'objet d'une
démonstration.

\section{Conclusion}

% Recap of your story and its implications

Nous avons montré que le problème de la manipulation de pointeurs non sûrs peut
être traité avec une technique de typage. Elle est proche des analyses menées
dans CQual~\cite{pldi99} ou Sparse~\cite{TorvaldsSparse}.

% Limitations
% Why someone might doubt your story and what you've done to get rid of as much
% doubt as possible.

Plusieurs limitations sont inhérentes à cette approche : notamment, la présence
d'unions ou de \emph{casts} entre entiers et pointeurs fait échouer l'analyse.

% Extensions

Le principe de cette technique (associer des types aux valeurs puis restreindre
les opérations sur certains types) peut être repris. Par exemple, si on définit
un type ``numéro de bloc'' comme étant un nouvel alias de \texttt{int}, on peut
considérer que multiplier deux telles valeurs est une erreur.

\chapter{État de l'art}

Analyse légère

  sparse \cite{TorvaldsSparse}

Analyse de valeurs

cousot 77 \cite{Cousot77}
Cousot 92 \cite{Cousot92-1}

Typage fort

  \cite{TAPL}

  qualifiers in haskell
  \cite{lightweight-static-capabilities}
  \cite{LZ06a}

Qualificateurs de type

  cqual :
  \cite{pldi99,usenix01,pldi02,cquk-usenix04,toplas-quals}

\part{Analyse statique par typage}

\chapter{Typage}

\section{Présentation et but}
\section{Taxonomie}

\subsection{Statique, dynamique, mixte}
\subsection{Fort, faible, sound}
\subsection{Expressivité, garanties, types dépendants}

\section{Exemples}

\subsection{Faible dynamique : Perl}
\subsection{Faible statique : C}
\subsection{Fort dynamique : Python}
\subsection{Fort statique : OCaml}
\subsection{Fort statique à effets typés : Haskell}
\subsection{Theorem prover : Coq}

\chapter{Un premier système de types}

\section{But}

$⊢ \text{memcpy} : ∀ a . (a^*, a^*, \text{size\_t}) → ()$

\section{Chaîne de compilation}

La compilation vers C est faite en trois étapes : prétraitement du code source,
compilation de C prétraité vers \newspeak{}, puis compilation de \newspeak{}
vers ce langage.

\input{fig/compil-pipeline.tex}

\subsection{Prétraitement}

\ctonewspeak{} travaillant uniquement sur du code prétraité (dans directives de
préprocesseur), la première étape consiste donc à faire passer le code par \cpp.

\subsection{Compilation (levée des ambigüités)}

Cette passe est réalisée par l'utilitaire \ctonewspeak{}. L'essentiel de la
compilation consiste à mettre à plat les définition de types, et à simplifier le
flôt de contrôle. C en effet propose de nombreuses constructions ambigües ou
redondantes.

Au contraire, \newspeak{} propose un nombre réduit de constructions. Rappelons
que le but de ce langage est de faciliter l'analyse statique : des constructions
orthogonales permettent donc d'éviter la duplication de règles sémantique, ou de
code lors de l'implémentation d'un analyseur.

Par exemple, plutôt que de fournir une boucle while, une boucle do/while et une
boucle for, \newspeak{} fournit une unique boucle \npkWhile{}. La sortie de
boucle est compilée vers un \npkGoto{}, qui est toujours un saut vers l'avant
(similaire à un "break" généralisé).

La sémantique de \newspeak{} et la traduction de C vers \newspeak{} sont
décrites dans \cite{newspeak}. En ce qui concerne l'élimination des sauts vers
l'arrière, on peut se référer à \cite{goto}.

\subsection{Annotations}

\newspeak{} a de nombreux avantages, mais pour une analyse par typage il est
trop bas niveau. Par exemple, dans le code suivant

\input{gen/struct-array.c.pyg.tex}

\section{Syntaxe}

La grammaire suivante définit un langage impératif. On suppose qu'on peut
compiler un programme écrit en C vers ce langage.

Un programme est un triplet $P = (\vec{f}, \vec{x}, b)$ constitué d'un ensemble
de fonctions, d'un ensemble de variables et d'un bloc d'instructions. Ce bloc
sera exécuté au lancement du programme ; il peut par exemple contenir le code
d'initialisation des variables globales et l'appel à la fonction principale.

\input{fig/syntax.tex}

\todo{expliquer pourquoi un while expr ne suffit pas}

Contrairement au langage C, le langage des expressions et des instructions est
séparé. Par conséquence, l'évaluation des expressions peut se faire sans effet de
bord.

\section{Sémantique (opérationnelle, à petits pas)}

On définit une sémantique opérationnelle à petits pas, sous forme d'une relation
de transition (notée $→$) entre états de l'interpréteur.

Ces états sont constitués des composantes suivantes :

\begin{itemize}
\item
  un point de contrôle $l$ dans le programme. Ils sont issus d'une
  première transformation en un graphe de flot de contrôle.
\item
  un état mémoire $σ$ qui associe à chaque variable une valeur.
\end{itemize}

\subsection{Graphe de flot de contrôle}

Dans la syntaxe ci-dessus, on peut classifier les instructions en deux familles:
celles qui définissent le flot de contrôle (if, dowith, goto, forever) et celles
qui définissent le flot de données. Une première transformation va transformer
chaque fonction en son graphe de flot de contrôle, défini comme suit :

\begin{itemize}
\item
  les nœuds sont des points de contrôle, qui représentent par exemple
  l'adresse mémoire de l'instruction qui vient d'être exécutée.
\item
  les arêtes sont soit des instructions "de données" (affectation,
  appel de fonction, déclaration), soit des conditions (ie une
  expression).
\end{itemize}

\begin{minipage}{0.5\textwidth}
\input{gen/euclide.c.pyg.tex}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\input{gen/euclide-npk.c.pyg.tex}
\end{minipage}

\input{fig/euclide.tex}

Intuitivement, on peut "passer" d'un état à un autre soit en passant par une
arête "condition" qui s'évalue à une valeur "vrai", soit en appliquant les
effets de bord d'une arête "instruction".

Dans la suite, on suppose qu'on a à notre disposition un ensemble de jugements :
$\langle l, instr, l' \rangle$ qui signifie qu'on peut passer du point $l$ au
point $l'$ en effectuant l'instruction $instr$.

\subsection{État mémoire}

La mémoire interne de l'interpréteur est une correspondance entre l'ensemble des
adresses (infini dénombrable) et l'ensemble des valeurs. Un état mémoire $σ$ est
une fonction partielle de $Addr$ vers $Val$.

Ces valeurs peuvent être de plusieurs formes :

\begin{align*}
v   ::=~ & n, f, \cNil & \text{constantes}\\
      |~ & \&a         & \text{pointeur vers l'adresse $a$}\\
      |~ & \&f         & \text{pointeur vers la fonction $f$}\\
      |~ & \top        & \text{valeur non initialisée}
\end{align*}

\todo{Pile d'appels}

\subsection{Left values}

La mémoire est organisée en adresses, mais pourtant dans le programme cette
notion n'est pas directement visible. Les accès sont réalisés à travers des
"left values".

\subsection{Jugements}

Les jugements ont les formes suivantes :

\begin{itemize}

\item $σ ⊢ lv ⇒ a$ :
  la left-value lv correspond à l'adresse mémoire a.

\item $σ ⊢ e ⇒ v$ :
  l'expression e s'évalue en v.

\item $(l, σ) → (l', σ')$ :
  permet de définir la fonction de transition principale

\end{itemize}

\subsection{Sémantique des left-values}

\begin{eqnarray*}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  σ ⊢ v ⇒ a
}
&
\irule{Eval-Lv-Deref}{
  σ ⊢ e ⇒ \&a
}{
  σ ⊢ *e ⇒ a
}
\\
\irule{Eval-Lv-Field}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ lv.f ⇒ a + f
}
&
\irule{Eval-Lv-Array}{
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ n \\
}{
  σ ⊢ lv[e] ⇒ a + n
}
\end{eqnarray*}

\subsection{Sémantique des expressions}

\begin{eqnarray*}
\irule{Eval-Cst}{
}{
  σ ⊢ c ⇒ c
}
&
\irule{Eval-Lv}{
  σ ⊢ lv ⇒ a \\
  (a, v) ∈ σ
}{
  σ ⊢ lv ⇒ v
}
\\
\irule{Eval-Unop}{
  σ ⊢ e ⇒ v
}{
  σ ⊢ op e ⇒ \widehat{op} v
}
&
\irule{Eval-Binop}{
  σ ⊢ e_1 ⇒ v_1 \\
  σ ⊢ e_2 ⇒ v_2
}{
  σ ⊢ e_1 op e_2 ⇒ v_1 \widehat{op} v_2
}
\\
\irule{Eval-AddrOf}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ \&lv ⇒ \&a
}
&
\irule{Eval-AddrOfFun}{
}{
  σ ⊢ \&f ⇒ \&f
}
\end{eqnarray*}

\subsection{Sémantique des instructions}

La règle la plus simple concerne l'affectation : on peut affecter une
expressions à une left value si elles ont le même type.

\[
\irule{Instr-Assign}{
  \langle l, lv ← e, l' \rangle \\
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ v
}{
  (l, σ) → (l', σ [ a ↦ v ])
}
\]

Déclarer une variable, c'est rendre accessible dans un bloc une variable non
initialisée, qui n'est plus accessible par la suite : Si on suppose qu'on peut
traverser le bloc interne $b$ sous un $σ$ enrichi d'une nouvelle variable $x$,
on peut donc traverser l'instruction $↑x\{b\}$.

\begin{minipage}{0.6\textwidth}
\[
\irule{Instr-Decl}{
  \langle l, ↑x \{ b \}, l' \rangle \\
  \langle l_b, b, l_b' \rangle \\
  σ' = σ ⊕ \{ x → \top \} \\
  (l_b, σ', s) → (l_b', σ'')
}{
  (l, σ) → (l', σ'' \backslash x)
}
\]
\end{minipage}
\begin{minipage}{0.4\textwidth}
\input{fig/sem-decl.tex}
\end{minipage}

\todo{fcall}

%TODO pour :
%
%\[
%\irule{Instr-Fcall}{
%  \langle l, lv ← fe(\vec{e}), l' \rangle \\
%  σ ⊢ fe ⇒ f \\
%  σ ⊢ \vec{e} ⇒ \vec{v} \\
%  σ' = σ ⊕ \{args(f) = \vec{v}\} ⊕ \{ !ret → \top \} \\
%  (Entry(f), σ') → (Exit(f), σ'') \\
%  σ'' ⊢ !ret ⇒ v_{ret} \\
%  σ'' ⊢ lv ⇒ a
%}{
%  (l, σ) → (l', σ'' \backslash (args(f) \cup \{!ret\}) ⊕ \{ a → v_{ret}\}, ?)
%}
%\]

%TODO definir $σ ⊢ fe ⇒ f$

\subsection{Sémantique des conditions}

On utilise un encodage similaire à la déclaration. Tout d'abord, on évalue la
condition dans un contexte $σ$. Si elle s'évalue en un entier non nul, et qu'une
transition à travers le bloc $i_t$ est possible, alors on peut faire passer à
travers le "if".

\begin{minipage}{0.5\textwidth}
\input{fig/sem-if.tex}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[
\irule{If-True}{
  \langle l, \iIf{e}{i_t}{i_f}, l' \rangle \\
  σ ⊢ e ⇒ n \\
  n ≠ 0 \\
  \langle l_i, i_t, l_i' \rangle \\
  (l_i, σ) → (l_i', σ')
}{
  (l, σ) → (l', σ')
}
\]

\[
\irule{If-False}{
  \langle l, \iIf{e}{i_t}{i_f}, l' \rangle \\
  σ ⊢ e ⇒ 0 \\
  \langle l_i, i_f, l_i' \rangle \\
  (l_i, σ) → (l_i', σ')
}{
  (l, σ) → (l', σ')
}
\]
\end{minipage}

\section{Règles de typage}

Dans cette section, on définit la notion de programme bien typé. L'analyse par
typage permet de vérifier qu'à chaque expression on peut associer un type, et ce
de manière cohérente entre plusieurs utilisations d'une variable.

Un jugement de typage est de la forme $Γ ⊢ e : τ$ et se lit "sous $Γ$, $e$ est
typable en $τ$". Un environnement de typage $Γ$ contient le contexte nécessaire
à l'analyse, c'est à dire le type des fonctions et variables du programme.

Les instructions et blocs, au contraire, n'ont pas de type. On note $Γ ⊢ i$ pour
"sous $Γ$, $i$ est bien typé", c'est à dire que ces sous expressions sont
typables et que les types sont en accord avec le flot de données (par exemple,
pour que l'instruction $lv ← e$ soit bien typée sous $Γ$, il faut que les types
de $lv$ et de $e$ puissent avoir le même type sous $Γ$).

Les types des valeurs sont :

\begin{align*}
τ   ::=~ & \tInt, \tFloat, \tVoid & \text{constantes}\\
    |~   &  a                     & \text{variable}\\
    |~   & (τ_1, …, τ_n) → τ_r    & \text{fonction}\\
    |~   & [τ]                    & \text{tableau}\\
    |~   & τ*                     & \text{pointeur}\\
    |~   & \{ f_1:τ_1
            ,    …
            , f_n:τ_n \}          & \text{structure}
\end{align*}

\subsection{Schémas de type}

On va associer à chaque variable globale un type. Mais faire de même pourrait
être trop restrictif. En effet, une fonction comme memcpy peut être utilisée
pour copier des tableaux d'entiers, mais aussi de flottants. On va donc associer
un schéma de types à chaque fonction.

\[
  σ ::= ∀ \vec{a} . τ
\]

En associant un schéma de type $σ$ à une fonction $f$, on indique que la
fonction pourra être utilisée avec tout type $τ$ qui est une instanciation de
$σ$.

\subsection{Programme}

Au niveau global, un programme P est bien typé (noté $⊢ P$) s'il existe un
environnement $Γ^0$ permettant de typer ses composantes (les fonctions, les
globales et le bloc d'initialisation).

\[
\irule{Prog}{
  Γ^0 = (\vec{σ}, \vec{τ}) \\
  Γ^0 ⊢ \vec{f} : \vec{σ} \\
  Γ^0 ⊢ \vec{x} : \vec{t} \\
  Γ^0 ⊢ b
}{
  ⊢ (\vec{f}, \vec{x}, b)
}
\]

\subsection{Flot de contrôle}

Les règles suivantes permettent de définir les jugements $Γ ⊢ i$. En résumé, les
instructions sont bien typées si leurs sous-instructions sont bien typées. La
seule règle supplémentaire concerne la condition du $if$ qui doit être typée en
\tInt.

\begin{eqnarray*}
&
\irule{Pass}{
}{
  Γ ⊢ ε
}
&
\irule{Seq}{
  Γ ⊢ s \\
  Γ ⊢ b
}{
  Γ ⊢ s;b
}
\\
&
\irule{Forever}{
  Γ ⊢ b
}{
  Γ ⊢ forever \{ b \}
}
&
\irule{If}{
  Γ ⊢ e : \tInt \\
  Γ ⊢ i_t \\
  Γ ⊢ i_f
}{
  Γ ⊢ \iIf{e}{i_t}{i_f}
} \\
&
\irule{Goto}{
}{
  Γ ⊢ goto l
}
&
\irule{DoWith}{
  Γ ⊢ b
}{
  Γ ⊢ \{ b \} l:
}
\end{eqnarray*}

\subsection{Left values}

On étend la relation de typage aux left values : chaque left value, vue comme
une expression, peut être typée.

\begin{eqnarray*}
\irule{Lv-Var}{
  (v, τ) ∈ Γ
}{
  Γ ⊢ v : τ
}
&
\irule{Lv-Field}{
  Γ ⊢ lv : τ_s \\
  (f, τ_f) ∈ τ_s
}{
  Γ ⊢ lv.f : τ_f
}
\\
\irule{Lv-Deref}{
  Γ ⊢ e : τ*
}{
  Γ ⊢ *e : τ
}
&
\irule{Lv-Array}{
  Γ ⊢ lv : [τ] \\
  Γ ⊢ e : \tInt
}{
  Γ ⊢ lv[e] : τ
}
\end{eqnarray*}

\subsection{Expressions}
\begin{eqnarray*}
\irule{Const-Int}{
}{
  Γ ⊢ n : \tInt
}
\\
\irule{Const-Float}{
}{
  Γ ⊢ f : \tFloat
}
\\
\irule{Const-Nil}{
}{
  Γ ⊢ \cNil : τ*
}
\\
\irule{Op-Int}{
  op ∈ \{+,-,×,/,\&,|,\&\&,||,⋘,⋙\} \\
  Γ ⊢ e_1 : \tInt \\
  Γ ⊢ e_2 : \tInt
}{
  Γ ⊢ e_1 op e_2 : \tInt
}
\\
\irule{Op-Float}{
  op ∈ \{+.,-.,×.,/.\} \\
  Γ ⊢ e_1 : \tFloat \\
  Γ ⊢ e_2 : \tFloat
}{
  Γ ⊢ e_1 \mathrm{op}~ e_2 : \tFloat
}
\\
\irule{Op-Cmp}{
  op ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : τ \\
  Γ ⊢ e_2 : τ \\
  τ ∈ \{ \tInt, \tFloat \}
}{
  Γ ⊢ e_1  \mathrm{op} e_2 : \tInt
}
\\
\irule{Unop-Minus}{
  τ ∈ \{ \tInt, \tFloat \} \\
  Γ ⊢ e : τ
}{
  Γ ⊢ -e : τ
}
\\
\irule{Unop-Not}{
  op ∈ \{ \tilde, ! \}
  Γ ⊢ e : \tInt
}{
  Γ ⊢ op e : \tInt
}
\\
\irule{AddrOf}{
  Γ ⊢ lv : τ
}{
  Γ ⊢ \&lv : τ*
}
\\
\irule{AddrOfFun}{
  Γ ⊢ f : σ \\
  τ ≤ σ
}{
  Γ ⊢ \&lv : τ
}
\end{eqnarray*}

\subsection{Fonctions}

Pour typer une fonction, on commence par ajouter ses paramètres dans
l'environnement de typage, et on type la définition de la fonction. Le type
résultant est généralisé.

\[
\irule{Fun}{
  Γ' = Γ ⊕ \{ args(f) = \vec{τ} \} \\
  Γ' ⊢ body(f) \\
  Γ' ⊢ !ret : τ_r
}{
  Γ ⊢ f : Gen(\vec{τ} → τ_r, Γ)
}
\]

\subsection{Instructions}

\begin{eqnarray*}
\irule{Decl}{
  Γ ⊕ \{x : τ\} ⊢ b
}{
  Γ ⊢ ↑x \{b\}
}
\\
\irule{Assign}{
  Γ ⊢ lv : τ \\
  Γ ⊢ e  : τ
}{
  Γ ⊢ lv ← e
}
\\
\irule{Fcall}{
  Γ ⊢ lv : τ_{ret} \\
  Γ ⊢ fe : σ \\
  Γ ⊢ \vec{e} : \vec{τ} \\
  (\vec{τ} → τ_r) ≤ σ
}{
  Γ ⊢ lv ← fe(\vec{e})
}
\end{eqnarray*}

\section{Limitations}
\subsection{Programmes non typables}
\subsection{Incohérences}

\chapter{Système avec le qualificateur "user"}

\section{Éditions et ajouts}
\section{Passage sur le cas d'étude}

\section{Propriété d'isolation mémoire}

Le déréférencement d'un pointeur dont la valeur est contrôlée par l'utilisateur
ne peut se faire qu'à travers une fonction qui vérifie la sûreté de celui-ci.

\chapter{Système avec le qualificateur "sz"}

\section{But}
\section{Annotation de \texttt{string.h}}

\chapter{Implantation}

\chapterstar{Conclusion}

\begin{itemize}
  \item Limitations
  \item Perspectives
\end{itemize}

\chapterstar{Bibliographie}

\bibliographystyle{alpha}
\bibliography{typ}
\end{document}
