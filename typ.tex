\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{mathpartir}
\usepackage{syntax}
\usepackage{amssymb}

\input{defs.tex}
\input{unicode.tex}

\begin{document}

\section{Syntaxe}

\begin{minipage}{0.6\textwidth}
\begin{grammar}
<programme> ::= ( fonctions , globales , <bloc> )

    <expr> ::= <lval>
          \alt unop <expr>
          \alt <expr> binop <expr>
          \alt cst
          \alt \& <lval>
          \alt \& fonction

    <lval> ::= var
          \alt <lval> . champ
          \alt <lval> [ <expr> ]
          \alt * <expr>
\end{grammar}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{grammar}
     <bloc> ::= <instr> ; <bloc>
           \alt $ε$

    <instr> ::= <lval> $←$ <expr>
           \alt <lval> $←$ funexp (args)
           \alt  $∅ ←$ funexp (args)
           \alt $↑$ nom \{ <bloc> \}
           \alt if (<expr>) \{ <bloc> \}
           \alt \{ <bloc> \} label:
           \alt goto label
           \alt forever \{ <bloc> \}

\end{grammar}
\end{minipage}

\section{Sémantique}

Sémantique concrète : un état est constitué d'un point de contrôle $p$ et d'un
état mémoire $σ$.

\subsection{Valeurs}

Les valeurs peuvent être :

\begin{itemize}
\item $n$ : un entier
\item $\&a$ : un pointeur vers l'adresse $a$
\item $\&f$ : un pointeur vers la fonction $f$
\end{itemize}

\subsection{Jugements}

Les jugements ont les formes suivantes :

\begin{itemize}

\item $σ ⊢ lv ⇒ a$ :
  la left-value lv correspond à l'adresse mémoire a.

\item $σ ⊢ e ⇒ v$ :
  l'expression e s'évalue en v.

\item $<l, instr, l'>$ :
  on peut passer du point l au point l' en effectuant
  l'instruction instr.

\item $<l, cond, l'>$ :
  on peut passer du point l au point l' si cond est vraie.

\item $(l, σ) → (l', σ')$ :
  permet de définir la fonction de transition principale

\end{itemize}

\subsection{Sémantique des left-values}

\begin{eqnarray*}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  σ ⊢ v ⇒ a
}
&
\irule{Eval-Lv-Deref}{
  σ ⊢ e ⇒ \&a
}{
  σ ⊢ *e ⇒ a
}
\\
\irule{Eval-Lv-Field}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ lv.f ⇒ a + f
}
&
\irule{Eval-Lv-Array}{
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ n \\
}{
  σ ⊢ lv[e] ⇒ a + n
}
\end{eqnarray*}

\subsection{Sémantique des expressions}

\begin{eqnarray*}
\irule{Eval-Cst}{
}{
  σ ⊢ c ⇒ c
}
&
\irule{Eval-Lv}{
  σ ⊢ lv ⇒ a \\
  (a, v) ∈ σ
}{
  σ ⊢ lv ⇒ v
}
\\
\irule{Eval-Unop}{
  σ ⊢ e ⇒ v
}{
  σ ⊢ op e ⇒ \widehat{op} v
}
&
\irule{Eval-Binop}{
  σ ⊢ e_1 ⇒ v_1 \\
  σ ⊢ e_2 ⇒ v_2
}{
  σ ⊢ e_1 op e_2 ⇒ v_1 \widehat{op} v_2
}
\\
\irule{Eval-AddrOf}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ \&lv ⇒ \&a
}
&
\irule{Eval-AddrOfFun}{
}{
  σ ⊢ \&f ⇒ \&f
}
\end{eqnarray*}

\subsection{Sémantique des instructions}

\begin{eqnarray*}
\irule{Instr-Assign}{
  \langle l, lv ← e, l' \rangle \\
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ v
}{
  (l, σ) → (l', σ ⊕ \{ a → v \})
}
\\
\irule{Instr-Decl}{
  \langle l, ↑x \{ b \}, l' \rangle \\
  σ' = σ ⊕ \{ x → \top \} \\
  \langle l_b, b, l_b' \rangle \\
  (l_b, σ') → (l_b', σ'')
}{
  (l, σ) → (l', σ'' \backslash x)
}
\\
\irule{Instr-Fcall}{
  \langle l, lv ← fe(\vec{e}), l' \rangle \\
  σ ⊢ fe ⇒ f \\
  σ ⊢ \vec{e} ⇒ \vec{v} \\
  σ' = σ ⊕ formals(f, \vec{v}) ⊕ \{ !ret → \top \} \\
  (Entry(f), σ') → (Exit(f), σ'') \\
  σ'' ⊢ !ret ⇒ v_{ret} \\
  σ'' ⊢ lv ⇒ a
}{
  (l, σ) → (l', σ'' \backslash (formals(f) \cup \{!ret\}) ⊕ \{ a → v_{ret}\})
}
\\
\irule{Instr-Fcall-Void}{
  \langle l, ∅ ← fe(\vec{e}), l' \rangle \\
  σ ⊢ fe ⇒ f \\
  σ ⊢ \vec{e} ⇒ \vec{v} \\
  σ' = σ ⊕ formals(f, \vec{v}) \\
  (Entry(f), σ') → (Exit(f), σ'')
}{
  (l, σ) → (l', σ'' \backslash formals(f))
}
\end{eqnarray*}

TODO definir $σ ⊢ fe ⇒ f$

\subsection{Sémantique des conditions}

\[ \irule{Cond}{
  \langle l, e, l' \rangle \\
  σ ⊢ e ⇒ n \\
  n ≠ 0
}{
  (l, σ) → (l', σ)
} \]

\section{Typage}

\subsection{Jugements}

\begin{itemize}
\item $Γ ⊢ b$ :
  sous $Γ$, $b$ est bien typé.
\item $Γ ⊢ e : τ$ :
  sous $Γ$, $e$ est typable en $τ$.
\end{itemize}

\subsection{Flôt de contrôle}

\begin{eqnarray*}
\irule{Pass}{
}{
  Γ ⊢ ε
}
&
\irule{Seq}{
  Γ ⊢ s \\
  Γ ⊢ b
}{
  Γ ⊢ s;b
}
\\
\irule{Forever}{
  Γ ⊢ b
}{
  Γ ⊢ forever \{ b \}
}
&
\irule{If}{
  Γ ⊢ e : Int \\
  Γ ⊢ b
}{
  Γ ⊢ if (e) \{ b \}
} \\
\irule{Goto}{
}{
  Γ ⊢ goto l
}
&
\irule{DoWith}{
  Γ ⊢ b
}{
  Γ ⊢ \{ b \} l:
}
\\
\irule{Decl}{
  Γ ⊕ {x : τ} ⊢ b
}{
  Γ ⊢ ↑x \{b\}
}
&
\irule{Assign}{
  Γ ⊢ lv : τ \\
  Γ ⊢ e  : τ
}{
  Γ ⊢ lv ← e
}
\end{eqnarray*}

\subsection{Expressions}
\begin{eqnarray*}
\irule{Const-Int}{
}{
  Γ ⊢ n : Int
}
&
\irule{Const-Float}{
}{
  Γ ⊢ f : Float
}
\\
\irule{Op-Int}{
  op ∈ \{+,-,×,/,\&,|,\&\&,||,⋘,⋙\} \\
  Γ ⊢ e_1 : Int \\
  Γ ⊢ e_2 : Int
}{
  Γ ⊢ e_1 op e_2 : Int
}
\\
\irule{Op-Float}{
  op ∈ \{+,-,×,/\} \\
  Γ ⊢ e_1 : Float \\
  Γ ⊢ e_2 : Float
}{
  Γ ⊢ e_1 op e_2 : Float
}
\\
\irule{Op-Cmp}{
  op ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : Int \\
  Γ ⊢ e_2 : Int
}{
  Γ ⊢ e_1 op e_2 : Int
}
\\
\irule{Unop-Minus}{
  τ ∈ \{ Int, Float \} \\
  Γ ⊢ e : τ
}{
  Γ ⊢ -e : τ
}
&
\irule{Unop-Not}{
  op ∈ \{ \tilde, ! \}
  Γ ⊢ e : Int
}{
  Γ ⊢ op e : Int
}
\end{eqnarray*}

\end{document}
