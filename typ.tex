\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}

\usepackage{mathpartir}
\usepackage{syntax}
\usepackage{amssymb}
\usepackage{a4wide}

\addtolength{\parskip}{\baselineskip}

\input{defs.tex}
\input{unicode.tex}

\begin{document}

\section{Syntaxe}

La grammaire suivante définit un langage impératif. On suppose qu'on peut
compiler un programme écrit en C vers ce langage.

\begin{grammar}
<programme> ::= ( fonctions , globales , <bloc> )
\end{grammar}
\begin{minipage}{0.4\textwidth}
\begin{grammar}
    <expr> ::= <lval>
          \alt unop <expr>
          \alt <expr> binop <expr>
          \alt cst
          \alt \& <lval>
          \alt \& fonction

    <lval> ::= var
          \alt <lval> . champ
          \alt <lval> [ <expr> ]
          \alt * <expr>
\end{grammar}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{grammar}
     <bloc> ::= <instr> ; <bloc>
           \alt $ε$

    <instr> ::= <lval> $←$ <expr>
           \alt <lval> $←$ funexp (args)
           \alt  $∅ ←$ funexp (args)
           \alt $↑$ nom \{ <bloc> \}
           \alt if (<expr>) \{ <bloc> \}
           \alt \{ <bloc> \} label:
           \alt goto label
           \alt forever \{ <bloc> \}

\end{grammar}
\end{minipage}

Contrairement au langage C, le langage des expressions et des instructions est
séparé. Par conséquence, l'évaluation des expressions peut se faire sans effet de
bord.

\section{Sémantique}

On définit une sémantique opérationnelle à petits pas. Pour ce faire, on
convertit le programme en son graphe de flôt de contrôle, qui va nous permettre
de raisonner en terme de points de contrôle sur lesquels s'appuira la
sémantique.

\subsection{Graphe de flôt de contrôle}

Dans la syntaxe ci-dessus, on peut classifier les instructions en deux familles:
celles qui définissent le flôt de contrôle (if, dowith, goto, forever) et celles
qui définissent le flôt de données. Une première transformation va transformer
chaque fonction en son graphe de flôt de contrôle, défini comme suit :

\begin{itemize}
\item
  les nœuds sont des points de contrôle, qui représentent par exemple
  l'adresse mémoire de l'instruction qui vient d'être exécutée.
\item
  les arêtes sont soit des instructions ``de données'' (affectation,
  appel de fonction, déclaration), soit des conditions (ie une
  expression).
\end{itemize}

Intuitivement, on peut "passer" d'un état à un autre soit en passant par une
arête "condition" qui s'évalue à une valeur "vrai", soit en appliquant les
effets de bord d'une arête "instruction".

Dans la suite, on suppose qu'on a à notre disposition un ensemble de jugements :
$\langle l, instr, l' \rangle$ qui signifie qu'on peut passer du point $l$ au
point $l'$ en effectuant l'instruction $instr$.

\subsection{État mémoire}

La mémoire interne de l'interpréteur est une correspondance entre l'ensemble des
adresses (infini dénombrable) et l'ensemble des valeurs. Un état mémoire $σ$ est
une fonction partielle de $Addr$ vers $Val$.

Ces valeurs peuvent être de plusieurs formes (disjointes) :

\begin{itemize}
\item $n$ : un entier
\item $f$ : un flottant
\item $\&a$ : un pointeur vers l'adresse $a$
\item $\&f$ : un pointeur vers la fonction $f$
\item $Nil$ : un pointeur nul
\item $\top$ : une valeur non initialisée
\end{itemize}

\subsection{Left values}

La mémoire est organisée en adresses, mais pourtant dans le programme cette
notion n'est pas directement visible. Les accès sont réalisés à travers des
"left values".

\subsection{Jugements}


L'état de l'interpréteur est un couple $(l, σ)$, où $l$ est un point de contrôle
et $σ$ un état mémoire.  La sémantique consiste en une fonction de transition
$→$ entre ces couples.

Les jugements ont les formes suivantes :

\begin{itemize}

\item $σ ⊢ lv ⇒ a$ :
  la left-value lv correspond à l'adresse mémoire a.

\item $σ ⊢ e ⇒ v$ :
  l'expression e s'évalue en v.

\item $(l, σ) → (l', σ')$ :
  permet de définir la fonction de transition principale

\end{itemize}

\subsection{Sémantique des left-values}

\begin{eqnarray*}
\irule{Eval-Lv-Var}{
  (v, a) ∈ σ
}{
  σ ⊢ v ⇒ a
}
&
\irule{Eval-Lv-Deref}{
  σ ⊢ e ⇒ \&a
}{
  σ ⊢ *e ⇒ a
}
\\
\irule{Eval-Lv-Field}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ lv.f ⇒ a + f
}
&
\irule{Eval-Lv-Array}{
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ n \\
}{
  σ ⊢ lv[e] ⇒ a + n
}
\end{eqnarray*}

\subsection{Sémantique des expressions}

\begin{eqnarray*}
\irule{Eval-Cst}{
}{
  σ ⊢ c ⇒ c
}
&
\irule{Eval-Lv}{
  σ ⊢ lv ⇒ a \\
  (a, v) ∈ σ
}{
  σ ⊢ lv ⇒ v
}
\\
\irule{Eval-Unop}{
  σ ⊢ e ⇒ v
}{
  σ ⊢ op e ⇒ \widehat{op} v
}
&
\irule{Eval-Binop}{
  σ ⊢ e_1 ⇒ v_1 \\
  σ ⊢ e_2 ⇒ v_2
}{
  σ ⊢ e_1 op e_2 ⇒ v_1 \widehat{op} v_2
}
\\
\irule{Eval-AddrOf}{
  σ ⊢ lv ⇒ a
}{
  σ ⊢ \&lv ⇒ \&a
}
&
\irule{Eval-AddrOfFun}{
}{
  σ ⊢ \&f ⇒ \&f
}
\end{eqnarray*}

\subsection{Sémantique des instructions}

\begin{eqnarray*}
\irule{Instr-Assign}{
  \langle l, lv ← e, l' \rangle \\
  σ ⊢ lv ⇒ a \\
  σ ⊢ e ⇒ v
}{
  (l, σ) → (l', σ ⊕ \{ a → v \})
}
\\
\irule{Instr-Decl}{
  \langle l, ↑x \{ b \}, l' \rangle \\
  σ' = σ ⊕ \{ x → \top \} \\
  \langle l_b, b, l_b' \rangle \\
  (l_b, σ') → (l_b', σ'')
}{
  (l, σ) → (l', σ'' \backslash x)
}
\\
\irule{Instr-Fcall}{
  \langle l, lv ← fe(\vec{e}), l' \rangle \\
  σ ⊢ fe ⇒ f \\
  σ ⊢ \vec{e} ⇒ \vec{v} \\
  σ' = σ ⊕ \{args(f) = \vec{v}\} ⊕ \{ !ret → \top \} \\
  (Entry(f), σ') → (Exit(f), σ'') \\
  σ'' ⊢ !ret ⇒ v_{ret} \\
  σ'' ⊢ lv ⇒ a
}{
  (l, σ) → (l', σ'' \backslash (args(f) \cup \{!ret\}) ⊕ \{ a → v_{ret}\})
}
\\
\irule{Instr-Fcall-Void}{
  \langle l, ∅ ← fe(\vec{e}), l' \rangle \\
  σ ⊢ fe ⇒ f \\
  σ ⊢ \vec{e} ⇒ \vec{v} \\
  σ' = σ ⊕ \{args(f)  = \vec{v}\} \\
  (Entry(f), σ') → (Exit(f), σ'')
}{
  (l, σ) → (l', σ'' \backslash args(f))
}
\end{eqnarray*}

TODO definir $σ ⊢ fe ⇒ f$

\subsection{Sémantique des conditions}

\begin{eqnarray*}
\irule{If-True}{
  \langle l, if(e) \{ i_t \} else \{ i_f \}, l' \rangle \\
  σ ⊢ e : n \\
  n ≠ 0 \\
  \langle l_i, i_t, l_i' \rangle \\
  (l_i, σ) → (l_i', σ')
}{
  (l, σ) → (l', σ')
}
\\
\irule{If-False}{
  \langle l, if(e) \{ i_t \} else \{ i_f \}, l' \rangle \\
  σ ⊢ e : 0 \\
  \langle l_i, i_f, l_i' \rangle \\
  (l_i, σ) → (l_i', σ')
}{
  (l, σ) → (l', σ')
}
\\
\end{eqnarray*}

\section{Typage}

Dans cette section, on définit la notion de programme bien typé. L'analyse par
typage permet de vérifier qu'à chaque expression on peut associer un type, et ce
de manière cohérente entre plusieurs utilisations d'une variable.

Un jugement de typage est de la forme $Γ ⊢ e : τ$ et se lit "sous $Γ$, $e$ est
typable en $τ$". Un environnement de typage $Γ$ contient le contexte nécessaire
à l'analyse, c'est à dire le type des fonctions et variables du programme.

Les instructions et blocs, au contraire, n'ont pas de type. On note $Γ ⊢ i$ pour
"sous $Γ$, $i$ est bien typé", c'est à dire que ces sous expressions sont
typables et que les types sont en accord avec le flot de contrôle entre
variables (par exemple, pour que l'instruction $lv ← e$ soit bien typée sous
$Γ$, il faut que les types de $lv$ et de $e$ puissent avoir le même type sous
$Γ$).

Au niveau global, un programme P est bien typé (noté $⊢ P$) s'il existe un
environnement permettant de typer ses composantes (les fonctions, les globales
et le bloc d'initialisation).

\subsection{Programme}

\[
\irule{Prog}{
  Γ^0 = (\vec{σ}, \vec{τ}) \\
  Γ^0 ⊢ \vec{f} : \vec{σ} \\
  Γ^0 ⊢ \vec{x} : \vec{t} \\
  Γ^0 ⊢ b
}{
  ⊢ (\vec{f}, \vec{x}, b)
}
\]

\subsection{Flôt de contrôle}

\begin{eqnarray*}
\irule{Pass}{
}{
  Γ ⊢ ε
}
&
\irule{Seq}{
  Γ ⊢ s \\
  Γ ⊢ b
}{
  Γ ⊢ s;b
}
\\
\irule{Forever}{
  Γ ⊢ b
}{
  Γ ⊢ forever \{ b \}
}
&
\irule{If}{
  Γ ⊢ e : Int \\
  Γ ⊢ b
}{
  Γ ⊢ if (e) \{ b \}
} \\
\irule{Goto}{
}{
  Γ ⊢ goto l
}
&
\irule{DoWith}{
  Γ ⊢ b
}{
  Γ ⊢ \{ b \} l:
}
\end{eqnarray*}

\subsection{Left values}

\begin{eqnarray*}
\irule{Lv-Var}{
  (v, τ) ∈ Γ
}{
  Γ ⊢ v : τ
}
&
\irule{Lv-Field}{
  Γ ⊢ lv : τ_s \\
  (f, τ_f) ∈ τ_s
}{
  Γ ⊢ lv.f : τ_f
}
\\
\irule{Lv-Deref}{
  Γ ⊢ e : τ*
}{
  Γ ⊢ *e : τ
}
&
\irule{Lv-Array}{
  Γ ⊢ lv : [τ] \\
  Γ ⊢ e : Int
}{
  Γ ⊢ lv[e] : τ
}
\end{eqnarray*}

\subsection{Expressions}
\begin{eqnarray*}
\irule{Const-Int}{
}{
  Γ ⊢ n : Int
}
\\
\irule{Const-Float}{
}{
  Γ ⊢ f : Float
}
\\
\irule{Const-Nil}{
}{
  Γ ⊢ Nil : τ*
}
\\
\irule{Top}{
}{
  Γ ⊢ Top : τ
}
\\
\irule{Op-Int}{
  op ∈ \{+,-,×,/,\&,|,\&\&,||,⋘,⋙\} \\
  Γ ⊢ e_1 : Int \\
  Γ ⊢ e_2 : Int
}{
  Γ ⊢ e_1 op e_2 : Int
}
\\
\irule{Op-Float}{
  op ∈ \{+,-,×,/\} \\
  Γ ⊢ e_1 : Float \\
  Γ ⊢ e_2 : Float
}{
  Γ ⊢ e_1 op e_2 : Float
}
\\
\irule{Op-Cmp}{
  op ∈ \{=,≠,≤,≥,<,>\} \\
  Γ ⊢ e_1 : Int \\
  Γ ⊢ e_2 : Int
}{
  Γ ⊢ e_1 op e_2 : Int
}
\\
\irule{Unop-Minus}{
  τ ∈ \{ Int, Float \} \\
  Γ ⊢ e : τ
}{
  Γ ⊢ -e : τ
}
\\
\irule{Unop-Not}{
  op ∈ \{ \tilde, ! \}
  Γ ⊢ e : Int
}{
  Γ ⊢ op e : Int
}
\\
\irule{AddrOf}{
  Γ ⊢ lv : τ
}{
  Γ ⊢ \&lv : τ*
}
\\
\irule{AddrOfFun}{
  Γ ⊢ f : σ \\
  τ ≤ σ
}{
  Γ ⊢ \&lv : τ
}
\end{eqnarray*}

\subsection{Fonctions}

\[
\irule{Fun}{
  Γ' = Γ ⊕ \{ args(f) = \vec{τ} \} \\
  Γ' ⊢ body(f) \\
  Γ' ⊢ !ret : τ_r
}{
  Γ ⊢ f : Gen(\vec{τ} → τ_r, Γ)
}
\]

\[
\irule{Fun-Void}{
  Γ' = Γ ⊕ \{ args(f) = \vec{τ} \} \\
  Γ' ⊢ body(f)
}{
  Γ ⊢ f : Gen(\vec{τ} → ∅, Γ)
}
\]

\subsection{Instructions}

\begin{eqnarray*}
\irule{Decl}{
  Γ ⊕ \{x : τ\} ⊢ b
}{
  Γ ⊢ ↑x \{b\}
}
\\
\irule{Assign}{
  Γ ⊢ lv : τ \\
  Γ ⊢ e  : τ
}{
  Γ ⊢ lv ← e
}
\\
\irule{Fcall}{
  Γ ⊢ lv : τ_{ret} \\
  Γ ⊢ fe : σ \\
  Γ ⊢ \vec{e} : \vec{τ} \\
  (\vec{τ} → τ_r) ≤ σ
}{
  Γ ⊢ lv ← fe(\vec{e})
}
\\
\irule{Fcall-Void}{
  Γ ⊢ fe : σ \\
  Γ ⊢ \vec{e} : \vec{τ} \\
  (\vec{τ} → ∅) ≤ σ
}{
  Γ ⊢ ∅ ← fe(\vec{e})
}
\end{eqnarray*}

\end{document}
